
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Family
 * 
 */
export type Family = $Result.DefaultSelection<Prisma.$FamilyPayload>
/**
 * Model FamilyMembership
 * 
 */
export type FamilyMembership = $Result.DefaultSelection<Prisma.$FamilyMembershipPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model PostFileAttachment
 * 
 */
export type PostFileAttachment = $Result.DefaultSelection<Prisma.$PostFileAttachmentPayload>
/**
 * Model CommentFileAttachment
 * 
 */
export type CommentFileAttachment = $Result.DefaultSelection<Prisma.$CommentFileAttachmentPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model PostLike
 * 
 */
export type PostLike = $Result.DefaultSelection<Prisma.$PostLikePayload>
/**
 * Model CommentLike
 * 
 */
export type CommentLike = $Result.DefaultSelection<Prisma.$CommentLikePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model FamilyMemberPermission
 * 
 */
export type FamilyMemberPermission = $Result.DefaultSelection<Prisma.$FamilyMemberPermissionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER',
  PREFER_NOT_TO_SAY: 'PREFER_NOT_TO_SAY'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const MemberStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DECEASED: 'DECEASED',
  ARCHIVED: 'ARCHIVED'
};

export type MemberStatus = (typeof MemberStatus)[keyof typeof MemberStatus]


export const FamilyRole: {
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  HEAD: 'HEAD',
  VIEWER: 'VIEWER'
};

export type FamilyRole = (typeof FamilyRole)[keyof typeof FamilyRole]


export const MembershipType: {
  MAIN: 'MAIN',
  SUB: 'SUB'
};

export type MembershipType = (typeof MembershipType)[keyof typeof MembershipType]


export const InvitationStatus: {
  VALID: 'VALID',
  USED: 'USED',
  EXPIRED: 'EXPIRED',
  REVOKED: 'REVOKED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const PostVisibility: {
  PUBLIC: 'PUBLIC',
  FAMILY: 'FAMILY',
  SUBFAMILY: 'SUBFAMILY'
};

export type PostVisibility = (typeof PostVisibility)[keyof typeof PostVisibility]


export const NotificationType: {
  POST_LIKE: 'POST_LIKE',
  COMMENT_LIKE: 'COMMENT_LIKE',
  NEW_COMMENT: 'NEW_COMMENT',
  NEW_POST: 'NEW_POST',
  MENTION: 'MENTION'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const FileType: {
  IMAGE: 'IMAGE',
  DOCUMENT: 'DOCUMENT',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO'
};

export type FileType = (typeof FileType)[keyof typeof FileType]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type MemberStatus = $Enums.MemberStatus

export const MemberStatus: typeof $Enums.MemberStatus

export type FamilyRole = $Enums.FamilyRole

export const FamilyRole: typeof $Enums.FamilyRole

export type MembershipType = $Enums.MembershipType

export const MembershipType: typeof $Enums.MembershipType

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type PostVisibility = $Enums.PostVisibility

export const PostVisibility: typeof $Enums.PostVisibility

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.family`: Exposes CRUD operations for the **Family** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Families
    * const families = await prisma.family.findMany()
    * ```
    */
  get family(): Prisma.FamilyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyMembership`: Exposes CRUD operations for the **FamilyMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyMemberships
    * const familyMemberships = await prisma.familyMembership.findMany()
    * ```
    */
  get familyMembership(): Prisma.FamilyMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postFileAttachment`: Exposes CRUD operations for the **PostFileAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostFileAttachments
    * const postFileAttachments = await prisma.postFileAttachment.findMany()
    * ```
    */
  get postFileAttachment(): Prisma.PostFileAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentFileAttachment`: Exposes CRUD operations for the **CommentFileAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentFileAttachments
    * const commentFileAttachments = await prisma.commentFileAttachment.findMany()
    * ```
    */
  get commentFileAttachment(): Prisma.CommentFileAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postLike`: Exposes CRUD operations for the **PostLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostLikes
    * const postLikes = await prisma.postLike.findMany()
    * ```
    */
  get postLike(): Prisma.PostLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentLike`: Exposes CRUD operations for the **CommentLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentLikes
    * const commentLikes = await prisma.commentLike.findMany()
    * ```
    */
  get commentLike(): Prisma.CommentLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyMemberPermission`: Exposes CRUD operations for the **FamilyMemberPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyMemberPermissions
    * const familyMemberPermissions = await prisma.familyMemberPermission.findMany()
    * ```
    */
  get familyMemberPermission(): Prisma.FamilyMemberPermissionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Member: 'Member',
    Family: 'Family',
    FamilyMembership: 'FamilyMembership',
    Invitation: 'Invitation',
    File: 'File',
    PostFileAttachment: 'PostFileAttachment',
    CommentFileAttachment: 'CommentFileAttachment',
    Post: 'Post',
    Comment: 'Comment',
    PostLike: 'PostLike',
    CommentLike: 'CommentLike',
    Notification: 'Notification',
    FamilyMemberPermission: 'FamilyMemberPermission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "member" | "family" | "familyMembership" | "invitation" | "file" | "postFileAttachment" | "commentFileAttachment" | "post" | "comment" | "postLike" | "commentLike" | "notification" | "familyMemberPermission"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Family: {
        payload: Prisma.$FamilyPayload<ExtArgs>
        fields: Prisma.FamilyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>
          }
          findFirst: {
            args: Prisma.FamilyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>
          }
          findMany: {
            args: Prisma.FamilyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>[]
          }
          create: {
            args: Prisma.FamilyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>
          }
          createMany: {
            args: Prisma.FamilyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FamilyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>[]
          }
          delete: {
            args: Prisma.FamilyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>
          }
          update: {
            args: Prisma.FamilyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>
          }
          deleteMany: {
            args: Prisma.FamilyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FamilyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>[]
          }
          upsert: {
            args: Prisma.FamilyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyPayload>
          }
          aggregate: {
            args: Prisma.FamilyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamily>
          }
          groupBy: {
            args: Prisma.FamilyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyCountAggregateOutputType> | number
          }
        }
      }
      FamilyMembership: {
        payload: Prisma.$FamilyMembershipPayload<ExtArgs>
        fields: Prisma.FamilyMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>
          }
          findFirst: {
            args: Prisma.FamilyMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>
          }
          findMany: {
            args: Prisma.FamilyMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>[]
          }
          create: {
            args: Prisma.FamilyMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>
          }
          createMany: {
            args: Prisma.FamilyMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FamilyMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>[]
          }
          delete: {
            args: Prisma.FamilyMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>
          }
          update: {
            args: Prisma.FamilyMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>
          }
          deleteMany: {
            args: Prisma.FamilyMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FamilyMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>[]
          }
          upsert: {
            args: Prisma.FamilyMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMembershipPayload>
          }
          aggregate: {
            args: Prisma.FamilyMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyMembership>
          }
          groupBy: {
            args: Prisma.FamilyMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyMembershipCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      PostFileAttachment: {
        payload: Prisma.$PostFileAttachmentPayload<ExtArgs>
        fields: Prisma.PostFileAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFileAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFileAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>
          }
          findFirst: {
            args: Prisma.PostFileAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFileAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>
          }
          findMany: {
            args: Prisma.PostFileAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>[]
          }
          create: {
            args: Prisma.PostFileAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>
          }
          createMany: {
            args: Prisma.PostFileAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostFileAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>[]
          }
          delete: {
            args: Prisma.PostFileAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>
          }
          update: {
            args: Prisma.PostFileAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.PostFileAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostFileAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostFileAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.PostFileAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostFileAttachmentPayload>
          }
          aggregate: {
            args: Prisma.PostFileAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostFileAttachment>
          }
          groupBy: {
            args: Prisma.PostFileAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostFileAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostFileAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<PostFileAttachmentCountAggregateOutputType> | number
          }
        }
      }
      CommentFileAttachment: {
        payload: Prisma.$CommentFileAttachmentPayload<ExtArgs>
        fields: Prisma.CommentFileAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFileAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFileAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>
          }
          findFirst: {
            args: Prisma.CommentFileAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFileAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>
          }
          findMany: {
            args: Prisma.CommentFileAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>[]
          }
          create: {
            args: Prisma.CommentFileAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>
          }
          createMany: {
            args: Prisma.CommentFileAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentFileAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>[]
          }
          delete: {
            args: Prisma.CommentFileAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>
          }
          update: {
            args: Prisma.CommentFileAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.CommentFileAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentFileAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentFileAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.CommentFileAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentFileAttachmentPayload>
          }
          aggregate: {
            args: Prisma.CommentFileAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentFileAttachment>
          }
          groupBy: {
            args: Prisma.CommentFileAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentFileAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentFileAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentFileAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      PostLike: {
        payload: Prisma.$PostLikePayload<ExtArgs>
        fields: Prisma.PostLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          findFirst: {
            args: Prisma.PostLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          findMany: {
            args: Prisma.PostLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
          }
          create: {
            args: Prisma.PostLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          createMany: {
            args: Prisma.PostLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
          }
          delete: {
            args: Prisma.PostLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          update: {
            args: Prisma.PostLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          deleteMany: {
            args: Prisma.PostLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
          }
          upsert: {
            args: Prisma.PostLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          aggregate: {
            args: Prisma.PostLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostLike>
          }
          groupBy: {
            args: Prisma.PostLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostLikeCountArgs<ExtArgs>
            result: $Utils.Optional<PostLikeCountAggregateOutputType> | number
          }
        }
      }
      CommentLike: {
        payload: Prisma.$CommentLikePayload<ExtArgs>
        fields: Prisma.CommentLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>
          }
          findFirst: {
            args: Prisma.CommentLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>
          }
          findMany: {
            args: Prisma.CommentLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>[]
          }
          create: {
            args: Prisma.CommentLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>
          }
          createMany: {
            args: Prisma.CommentLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>[]
          }
          delete: {
            args: Prisma.CommentLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>
          }
          update: {
            args: Prisma.CommentLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>
          }
          deleteMany: {
            args: Prisma.CommentLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>[]
          }
          upsert: {
            args: Prisma.CommentLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentLikePayload>
          }
          aggregate: {
            args: Prisma.CommentLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentLike>
          }
          groupBy: {
            args: Prisma.CommentLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentLikeCountArgs<ExtArgs>
            result: $Utils.Optional<CommentLikeCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      FamilyMemberPermission: {
        payload: Prisma.$FamilyMemberPermissionPayload<ExtArgs>
        fields: Prisma.FamilyMemberPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyMemberPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyMemberPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>
          }
          findFirst: {
            args: Prisma.FamilyMemberPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyMemberPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>
          }
          findMany: {
            args: Prisma.FamilyMemberPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>[]
          }
          create: {
            args: Prisma.FamilyMemberPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>
          }
          createMany: {
            args: Prisma.FamilyMemberPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FamilyMemberPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>[]
          }
          delete: {
            args: Prisma.FamilyMemberPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>
          }
          update: {
            args: Prisma.FamilyMemberPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>
          }
          deleteMany: {
            args: Prisma.FamilyMemberPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyMemberPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FamilyMemberPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>[]
          }
          upsert: {
            args: Prisma.FamilyMemberPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPermissionPayload>
          }
          aggregate: {
            args: Prisma.FamilyMemberPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyMemberPermission>
          }
          groupBy: {
            args: Prisma.FamilyMemberPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyMemberPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberPermissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    member?: MemberOmit
    family?: FamilyOmit
    familyMembership?: FamilyMembershipOmit
    invitation?: InvitationOmit
    file?: FileOmit
    postFileAttachment?: PostFileAttachmentOmit
    commentFileAttachment?: CommentFileAttachmentOmit
    post?: PostOmit
    comment?: CommentOmit
    postLike?: PostLikeOmit
    commentLike?: CommentLikeOmit
    notification?: NotificationOmit
    familyMemberPermission?: FamilyMemberPermissionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sentInvitations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentInvitations?: boolean | UserCountOutputTypeCountSentInvitationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    parents: number
    children: number
    spouses: number
    spousesReverse: number
    familyMemberships: number
    sentInvitations: number
    createdFamilies: number
    headedFamilies: number
    posts: number
    comments: number
    postLikes: number
    commentLikes: number
    notifications: number
    triggeredNotifications: number
    uploadedFiles: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | MemberCountOutputTypeCountParentsArgs
    children?: boolean | MemberCountOutputTypeCountChildrenArgs
    spouses?: boolean | MemberCountOutputTypeCountSpousesArgs
    spousesReverse?: boolean | MemberCountOutputTypeCountSpousesReverseArgs
    familyMemberships?: boolean | MemberCountOutputTypeCountFamilyMembershipsArgs
    sentInvitations?: boolean | MemberCountOutputTypeCountSentInvitationsArgs
    createdFamilies?: boolean | MemberCountOutputTypeCountCreatedFamiliesArgs
    headedFamilies?: boolean | MemberCountOutputTypeCountHeadedFamiliesArgs
    posts?: boolean | MemberCountOutputTypeCountPostsArgs
    comments?: boolean | MemberCountOutputTypeCountCommentsArgs
    postLikes?: boolean | MemberCountOutputTypeCountPostLikesArgs
    commentLikes?: boolean | MemberCountOutputTypeCountCommentLikesArgs
    notifications?: boolean | MemberCountOutputTypeCountNotificationsArgs
    triggeredNotifications?: boolean | MemberCountOutputTypeCountTriggeredNotificationsArgs
    uploadedFiles?: boolean | MemberCountOutputTypeCountUploadedFilesArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSpousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSpousesReverseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountFamilyMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMembershipWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCreatedFamiliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountHeadedFamiliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountPostLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCommentLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentLikeWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountTriggeredNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountUploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type FamilyCountOutputType
   */

  export type FamilyCountOutputType = {
    subFamilies: number
    memberships: number
    invitations: number
  }

  export type FamilyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subFamilies?: boolean | FamilyCountOutputTypeCountSubFamiliesArgs
    memberships?: boolean | FamilyCountOutputTypeCountMembershipsArgs
    invitations?: boolean | FamilyCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * FamilyCountOutputType without action
   */
  export type FamilyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyCountOutputType
     */
    select?: FamilyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FamilyCountOutputType without action
   */
  export type FamilyCountOutputTypeCountSubFamiliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyWhereInput
  }

  /**
   * FamilyCountOutputType without action
   */
  export type FamilyCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMembershipWhereInput
  }

  /**
   * FamilyCountOutputType without action
   */
  export type FamilyCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * Count Type FamilyMembershipCountOutputType
   */

  export type FamilyMembershipCountOutputType = {
    familyMemberPermissions: number
  }

  export type FamilyMembershipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMemberPermissions?: boolean | FamilyMembershipCountOutputTypeCountFamilyMemberPermissionsArgs
  }

  // Custom InputTypes
  /**
   * FamilyMembershipCountOutputType without action
   */
  export type FamilyMembershipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembershipCountOutputType
     */
    select?: FamilyMembershipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FamilyMembershipCountOutputType without action
   */
  export type FamilyMembershipCountOutputTypeCountFamilyMemberPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberPermissionWhereInput
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    postAttachments: number
    commentAttachments: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postAttachments?: boolean | FileCountOutputTypeCountPostAttachmentsArgs
    commentAttachments?: boolean | FileCountOutputTypeCountCommentAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountPostAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostFileAttachmentWhereInput
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountCommentAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentFileAttachmentWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    likes: number
    fileAttachments: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    likes?: boolean | PostCountOutputTypeCountLikesArgs
    fileAttachments?: boolean | PostCountOutputTypeCountFileAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountFileAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostFileAttachmentWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
    likes: number
    fileAttachments: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
    likes?: boolean | CommentCountOutputTypeCountLikesArgs
    fileAttachments?: boolean | CommentCountOutputTypeCountFileAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentLikeWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountFileAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentFileAttachmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    memberId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    memberId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    password: number
    emailVerified: number
    phoneVerified: number
    isActive: number
    createdAt: number
    updatedAt: number
    memberId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    emailVerified?: true
    phoneVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    memberId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    emailVerified?: true
    phoneVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    memberId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    emailVerified?: true
    phoneVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    memberId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    password: string
    emailVerified: boolean
    phoneVerified: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    memberId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberId?: boolean
    member?: boolean | User$memberArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberId?: boolean
    member?: boolean | User$memberArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberId?: boolean
    member?: boolean | User$memberArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone" | "password" | "emailVerified" | "phoneVerified" | "isActive" | "createdAt" | "updatedAt" | "memberId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | User$memberArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | User$memberArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | User$memberArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs> | null
      sentInvitations: Prisma.$InvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      password: string
      emailVerified: boolean
      phoneVerified: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      memberId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends User$memberArgs<ExtArgs> = {}>(args?: Subset<T, User$memberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sentInvitations<T extends User$sentInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly memberId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.member
   */
  export type User$memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * User.sentInvitations
   */
  export type User$sentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    name: string | null
    gender: $Enums.Gender | null
    status: $Enums.MemberStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    color: string | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    name: string | null
    gender: $Enums.Gender | null
    status: $Enums.MemberStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    color: string | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    name: number
    gender: number
    status: number
    createdAt: number
    updatedAt: number
    personalInfo: number
    color: number
    parentColors: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    color?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    color?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    personalInfo?: true
    color?: true
    parentColors?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    name: string
    gender: $Enums.Gender | null
    status: $Enums.MemberStatus
    createdAt: Date
    updatedAt: Date
    personalInfo: JsonValue | null
    color: string | null
    parentColors: string[]
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean
    color?: boolean
    parentColors?: boolean
    parents?: boolean | Member$parentsArgs<ExtArgs>
    children?: boolean | Member$childrenArgs<ExtArgs>
    spouses?: boolean | Member$spousesArgs<ExtArgs>
    spousesReverse?: boolean | Member$spousesReverseArgs<ExtArgs>
    familyMemberships?: boolean | Member$familyMembershipsArgs<ExtArgs>
    user?: boolean | Member$userArgs<ExtArgs>
    sentInvitations?: boolean | Member$sentInvitationsArgs<ExtArgs>
    createdFamilies?: boolean | Member$createdFamiliesArgs<ExtArgs>
    headedFamilies?: boolean | Member$headedFamiliesArgs<ExtArgs>
    posts?: boolean | Member$postsArgs<ExtArgs>
    comments?: boolean | Member$commentsArgs<ExtArgs>
    postLikes?: boolean | Member$postLikesArgs<ExtArgs>
    commentLikes?: boolean | Member$commentLikesArgs<ExtArgs>
    notifications?: boolean | Member$notificationsArgs<ExtArgs>
    triggeredNotifications?: boolean | Member$triggeredNotificationsArgs<ExtArgs>
    uploadedFiles?: boolean | Member$uploadedFilesArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean
    color?: boolean
    parentColors?: boolean
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean
    color?: boolean
    parentColors?: boolean
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    name?: boolean
    gender?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalInfo?: boolean
    color?: boolean
    parentColors?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "gender" | "status" | "createdAt" | "updatedAt" | "personalInfo" | "color" | "parentColors", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | Member$parentsArgs<ExtArgs>
    children?: boolean | Member$childrenArgs<ExtArgs>
    spouses?: boolean | Member$spousesArgs<ExtArgs>
    spousesReverse?: boolean | Member$spousesReverseArgs<ExtArgs>
    familyMemberships?: boolean | Member$familyMembershipsArgs<ExtArgs>
    user?: boolean | Member$userArgs<ExtArgs>
    sentInvitations?: boolean | Member$sentInvitationsArgs<ExtArgs>
    createdFamilies?: boolean | Member$createdFamiliesArgs<ExtArgs>
    headedFamilies?: boolean | Member$headedFamiliesArgs<ExtArgs>
    posts?: boolean | Member$postsArgs<ExtArgs>
    comments?: boolean | Member$commentsArgs<ExtArgs>
    postLikes?: boolean | Member$postLikesArgs<ExtArgs>
    commentLikes?: boolean | Member$commentLikesArgs<ExtArgs>
    notifications?: boolean | Member$notificationsArgs<ExtArgs>
    triggeredNotifications?: boolean | Member$triggeredNotificationsArgs<ExtArgs>
    uploadedFiles?: boolean | Member$uploadedFilesArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      parents: Prisma.$MemberPayload<ExtArgs>[]
      children: Prisma.$MemberPayload<ExtArgs>[]
      spouses: Prisma.$MemberPayload<ExtArgs>[]
      spousesReverse: Prisma.$MemberPayload<ExtArgs>[]
      familyMemberships: Prisma.$FamilyMembershipPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      sentInvitations: Prisma.$InvitationPayload<ExtArgs>[]
      createdFamilies: Prisma.$FamilyPayload<ExtArgs>[]
      headedFamilies: Prisma.$FamilyPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      postLikes: Prisma.$PostLikePayload<ExtArgs>[]
      commentLikes: Prisma.$CommentLikePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      triggeredNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      uploadedFiles: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      gender: $Enums.Gender | null
      status: $Enums.MemberStatus
      createdAt: Date
      updatedAt: Date
      personalInfo: Prisma.JsonValue | null
      color: string | null
      parentColors: string[]
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parents<T extends Member$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    children<T extends Member$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Member$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spouses<T extends Member$spousesArgs<ExtArgs> = {}>(args?: Subset<T, Member$spousesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spousesReverse<T extends Member$spousesReverseArgs<ExtArgs> = {}>(args?: Subset<T, Member$spousesReverseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    familyMemberships<T extends Member$familyMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Member$familyMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Member$userArgs<ExtArgs> = {}>(args?: Subset<T, Member$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sentInvitations<T extends Member$sentInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, Member$sentInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdFamilies<T extends Member$createdFamiliesArgs<ExtArgs> = {}>(args?: Subset<T, Member$createdFamiliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    headedFamilies<T extends Member$headedFamiliesArgs<ExtArgs> = {}>(args?: Subset<T, Member$headedFamiliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Member$postsArgs<ExtArgs> = {}>(args?: Subset<T, Member$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Member$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postLikes<T extends Member$postLikesArgs<ExtArgs> = {}>(args?: Subset<T, Member$postLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentLikes<T extends Member$commentLikesArgs<ExtArgs> = {}>(args?: Subset<T, Member$commentLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Member$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Member$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    triggeredNotifications<T extends Member$triggeredNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Member$triggeredNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedFiles<T extends Member$uploadedFilesArgs<ExtArgs> = {}>(args?: Subset<T, Member$uploadedFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly name: FieldRef<"Member", 'String'>
    readonly gender: FieldRef<"Member", 'Gender'>
    readonly status: FieldRef<"Member", 'MemberStatus'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly personalInfo: FieldRef<"Member", 'Json'>
    readonly color: FieldRef<"Member", 'String'>
    readonly parentColors: FieldRef<"Member", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.parents
   */
  export type Member$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member.children
   */
  export type Member$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member.spouses
   */
  export type Member$spousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member.spousesReverse
   */
  export type Member$spousesReverseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member.familyMemberships
   */
  export type Member$familyMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    where?: FamilyMembershipWhereInput
    orderBy?: FamilyMembershipOrderByWithRelationInput | FamilyMembershipOrderByWithRelationInput[]
    cursor?: FamilyMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMembershipScalarFieldEnum | FamilyMembershipScalarFieldEnum[]
  }

  /**
   * Member.user
   */
  export type Member$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Member.sentInvitations
   */
  export type Member$sentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Member.createdFamilies
   */
  export type Member$createdFamiliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    where?: FamilyWhereInput
    orderBy?: FamilyOrderByWithRelationInput | FamilyOrderByWithRelationInput[]
    cursor?: FamilyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyScalarFieldEnum | FamilyScalarFieldEnum[]
  }

  /**
   * Member.headedFamilies
   */
  export type Member$headedFamiliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    where?: FamilyWhereInput
    orderBy?: FamilyOrderByWithRelationInput | FamilyOrderByWithRelationInput[]
    cursor?: FamilyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyScalarFieldEnum | FamilyScalarFieldEnum[]
  }

  /**
   * Member.posts
   */
  export type Member$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Member.comments
   */
  export type Member$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Member.postLikes
   */
  export type Member$postLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    cursor?: PostLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * Member.commentLikes
   */
  export type Member$commentLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    where?: CommentLikeWhereInput
    orderBy?: CommentLikeOrderByWithRelationInput | CommentLikeOrderByWithRelationInput[]
    cursor?: CommentLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentLikeScalarFieldEnum | CommentLikeScalarFieldEnum[]
  }

  /**
   * Member.notifications
   */
  export type Member$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Member.triggeredNotifications
   */
  export type Member$triggeredNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Member.uploadedFiles
   */
  export type Member$uploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Family
   */

  export type AggregateFamily = {
    _count: FamilyCountAggregateOutputType | null
    _min: FamilyMinAggregateOutputType | null
    _max: FamilyMaxAggregateOutputType | null
  }

  export type FamilyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSubFamily: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    headOfFamilyId: string | null
    parentFamilyId: string | null
  }

  export type FamilyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSubFamily: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    headOfFamilyId: string | null
    parentFamilyId: string | null
  }

  export type FamilyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isSubFamily: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    creatorId: number
    headOfFamilyId: number
    parentFamilyId: number
    _all: number
  }


  export type FamilyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSubFamily?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    headOfFamilyId?: true
    parentFamilyId?: true
  }

  export type FamilyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSubFamily?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    headOfFamilyId?: true
    parentFamilyId?: true
  }

  export type FamilyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSubFamily?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    headOfFamilyId?: true
    parentFamilyId?: true
    _all?: true
  }

  export type FamilyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Family to aggregate.
     */
    where?: FamilyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Families to fetch.
     */
    orderBy?: FamilyOrderByWithRelationInput | FamilyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Families from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Families.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Families
    **/
    _count?: true | FamilyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyMaxAggregateInputType
  }

  export type GetFamilyAggregateType<T extends FamilyAggregateArgs> = {
        [P in keyof T & keyof AggregateFamily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamily[P]>
      : GetScalarType<T[P], AggregateFamily[P]>
  }




  export type FamilyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyWhereInput
    orderBy?: FamilyOrderByWithAggregationInput | FamilyOrderByWithAggregationInput[]
    by: FamilyScalarFieldEnum[] | FamilyScalarFieldEnum
    having?: FamilyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyCountAggregateInputType | true
    _min?: FamilyMinAggregateInputType
    _max?: FamilyMaxAggregateInputType
  }

  export type FamilyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isSubFamily: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    creatorId: string
    headOfFamilyId: string | null
    parentFamilyId: string | null
    _count: FamilyCountAggregateOutputType | null
    _min: FamilyMinAggregateOutputType | null
    _max: FamilyMaxAggregateOutputType | null
  }

  type GetFamilyGroupByPayload<T extends FamilyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyGroupByOutputType[P]>
        }
      >
    >


  export type FamilySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSubFamily?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    headOfFamilyId?: boolean
    parentFamilyId?: boolean
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    headOfFamily?: boolean | Family$headOfFamilyArgs<ExtArgs>
    parentFamily?: boolean | Family$parentFamilyArgs<ExtArgs>
    subFamilies?: boolean | Family$subFamiliesArgs<ExtArgs>
    memberships?: boolean | Family$membershipsArgs<ExtArgs>
    invitations?: boolean | Family$invitationsArgs<ExtArgs>
    _count?: boolean | FamilyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["family"]>

  export type FamilySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSubFamily?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    headOfFamilyId?: boolean
    parentFamilyId?: boolean
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    headOfFamily?: boolean | Family$headOfFamilyArgs<ExtArgs>
    parentFamily?: boolean | Family$parentFamilyArgs<ExtArgs>
  }, ExtArgs["result"]["family"]>

  export type FamilySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSubFamily?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    headOfFamilyId?: boolean
    parentFamilyId?: boolean
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    headOfFamily?: boolean | Family$headOfFamilyArgs<ExtArgs>
    parentFamily?: boolean | Family$parentFamilyArgs<ExtArgs>
  }, ExtArgs["result"]["family"]>

  export type FamilySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isSubFamily?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    headOfFamilyId?: boolean
    parentFamilyId?: boolean
  }

  export type FamilyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isSubFamily" | "deletedAt" | "createdAt" | "updatedAt" | "creatorId" | "headOfFamilyId" | "parentFamilyId", ExtArgs["result"]["family"]>
  export type FamilyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    headOfFamily?: boolean | Family$headOfFamilyArgs<ExtArgs>
    parentFamily?: boolean | Family$parentFamilyArgs<ExtArgs>
    subFamilies?: boolean | Family$subFamiliesArgs<ExtArgs>
    memberships?: boolean | Family$membershipsArgs<ExtArgs>
    invitations?: boolean | Family$invitationsArgs<ExtArgs>
    _count?: boolean | FamilyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FamilyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    headOfFamily?: boolean | Family$headOfFamilyArgs<ExtArgs>
    parentFamily?: boolean | Family$parentFamilyArgs<ExtArgs>
  }
  export type FamilyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | MemberDefaultArgs<ExtArgs>
    headOfFamily?: boolean | Family$headOfFamilyArgs<ExtArgs>
    parentFamily?: boolean | Family$parentFamilyArgs<ExtArgs>
  }

  export type $FamilyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Family"
    objects: {
      creator: Prisma.$MemberPayload<ExtArgs>
      headOfFamily: Prisma.$MemberPayload<ExtArgs> | null
      parentFamily: Prisma.$FamilyPayload<ExtArgs> | null
      subFamilies: Prisma.$FamilyPayload<ExtArgs>[]
      memberships: Prisma.$FamilyMembershipPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isSubFamily: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
      creatorId: string
      headOfFamilyId: string | null
      parentFamilyId: string | null
    }, ExtArgs["result"]["family"]>
    composites: {}
  }

  type FamilyGetPayload<S extends boolean | null | undefined | FamilyDefaultArgs> = $Result.GetResult<Prisma.$FamilyPayload, S>

  type FamilyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyCountAggregateInputType | true
    }

  export interface FamilyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Family'], meta: { name: 'Family' } }
    /**
     * Find zero or one Family that matches the filter.
     * @param {FamilyFindUniqueArgs} args - Arguments to find a Family
     * @example
     * // Get one Family
     * const family = await prisma.family.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyFindUniqueArgs>(args: SelectSubset<T, FamilyFindUniqueArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Family that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyFindUniqueOrThrowArgs} args - Arguments to find a Family
     * @example
     * // Get one Family
     * const family = await prisma.family.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Family that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyFindFirstArgs} args - Arguments to find a Family
     * @example
     * // Get one Family
     * const family = await prisma.family.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyFindFirstArgs>(args?: SelectSubset<T, FamilyFindFirstArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Family that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyFindFirstOrThrowArgs} args - Arguments to find a Family
     * @example
     * // Get one Family
     * const family = await prisma.family.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Families that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Families
     * const families = await prisma.family.findMany()
     * 
     * // Get first 10 Families
     * const families = await prisma.family.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyWithIdOnly = await prisma.family.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyFindManyArgs>(args?: SelectSubset<T, FamilyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Family.
     * @param {FamilyCreateArgs} args - Arguments to create a Family.
     * @example
     * // Create one Family
     * const Family = await prisma.family.create({
     *   data: {
     *     // ... data to create a Family
     *   }
     * })
     * 
     */
    create<T extends FamilyCreateArgs>(args: SelectSubset<T, FamilyCreateArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Families.
     * @param {FamilyCreateManyArgs} args - Arguments to create many Families.
     * @example
     * // Create many Families
     * const family = await prisma.family.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyCreateManyArgs>(args?: SelectSubset<T, FamilyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Families and returns the data saved in the database.
     * @param {FamilyCreateManyAndReturnArgs} args - Arguments to create many Families.
     * @example
     * // Create many Families
     * const family = await prisma.family.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Families and only return the `id`
     * const familyWithIdOnly = await prisma.family.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FamilyCreateManyAndReturnArgs>(args?: SelectSubset<T, FamilyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Family.
     * @param {FamilyDeleteArgs} args - Arguments to delete one Family.
     * @example
     * // Delete one Family
     * const Family = await prisma.family.delete({
     *   where: {
     *     // ... filter to delete one Family
     *   }
     * })
     * 
     */
    delete<T extends FamilyDeleteArgs>(args: SelectSubset<T, FamilyDeleteArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Family.
     * @param {FamilyUpdateArgs} args - Arguments to update one Family.
     * @example
     * // Update one Family
     * const family = await prisma.family.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyUpdateArgs>(args: SelectSubset<T, FamilyUpdateArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Families.
     * @param {FamilyDeleteManyArgs} args - Arguments to filter Families to delete.
     * @example
     * // Delete a few Families
     * const { count } = await prisma.family.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyDeleteManyArgs>(args?: SelectSubset<T, FamilyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Families.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Families
     * const family = await prisma.family.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyUpdateManyArgs>(args: SelectSubset<T, FamilyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Families and returns the data updated in the database.
     * @param {FamilyUpdateManyAndReturnArgs} args - Arguments to update many Families.
     * @example
     * // Update many Families
     * const family = await prisma.family.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Families and only return the `id`
     * const familyWithIdOnly = await prisma.family.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FamilyUpdateManyAndReturnArgs>(args: SelectSubset<T, FamilyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Family.
     * @param {FamilyUpsertArgs} args - Arguments to update or create a Family.
     * @example
     * // Update or create a Family
     * const family = await prisma.family.upsert({
     *   create: {
     *     // ... data to create a Family
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Family we want to update
     *   }
     * })
     */
    upsert<T extends FamilyUpsertArgs>(args: SelectSubset<T, FamilyUpsertArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Families.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyCountArgs} args - Arguments to filter Families to count.
     * @example
     * // Count the number of Families
     * const count = await prisma.family.count({
     *   where: {
     *     // ... the filter for the Families we want to count
     *   }
     * })
    **/
    count<T extends FamilyCountArgs>(
      args?: Subset<T, FamilyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Family.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyAggregateArgs>(args: Subset<T, FamilyAggregateArgs>): Prisma.PrismaPromise<GetFamilyAggregateType<T>>

    /**
     * Group by Family.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyGroupByArgs['orderBy'] }
        : { orderBy?: FamilyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Family model
   */
  readonly fields: FamilyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Family.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    headOfFamily<T extends Family$headOfFamilyArgs<ExtArgs> = {}>(args?: Subset<T, Family$headOfFamilyArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parentFamily<T extends Family$parentFamilyArgs<ExtArgs> = {}>(args?: Subset<T, Family$parentFamilyArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subFamilies<T extends Family$subFamiliesArgs<ExtArgs> = {}>(args?: Subset<T, Family$subFamiliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends Family$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Family$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Family$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Family$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Family model
   */
  interface FamilyFieldRefs {
    readonly id: FieldRef<"Family", 'String'>
    readonly name: FieldRef<"Family", 'String'>
    readonly description: FieldRef<"Family", 'String'>
    readonly isSubFamily: FieldRef<"Family", 'Boolean'>
    readonly deletedAt: FieldRef<"Family", 'DateTime'>
    readonly createdAt: FieldRef<"Family", 'DateTime'>
    readonly updatedAt: FieldRef<"Family", 'DateTime'>
    readonly creatorId: FieldRef<"Family", 'String'>
    readonly headOfFamilyId: FieldRef<"Family", 'String'>
    readonly parentFamilyId: FieldRef<"Family", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Family findUnique
   */
  export type FamilyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * Filter, which Family to fetch.
     */
    where: FamilyWhereUniqueInput
  }

  /**
   * Family findUniqueOrThrow
   */
  export type FamilyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * Filter, which Family to fetch.
     */
    where: FamilyWhereUniqueInput
  }

  /**
   * Family findFirst
   */
  export type FamilyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * Filter, which Family to fetch.
     */
    where?: FamilyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Families to fetch.
     */
    orderBy?: FamilyOrderByWithRelationInput | FamilyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Families.
     */
    cursor?: FamilyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Families from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Families.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Families.
     */
    distinct?: FamilyScalarFieldEnum | FamilyScalarFieldEnum[]
  }

  /**
   * Family findFirstOrThrow
   */
  export type FamilyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * Filter, which Family to fetch.
     */
    where?: FamilyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Families to fetch.
     */
    orderBy?: FamilyOrderByWithRelationInput | FamilyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Families.
     */
    cursor?: FamilyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Families from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Families.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Families.
     */
    distinct?: FamilyScalarFieldEnum | FamilyScalarFieldEnum[]
  }

  /**
   * Family findMany
   */
  export type FamilyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * Filter, which Families to fetch.
     */
    where?: FamilyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Families to fetch.
     */
    orderBy?: FamilyOrderByWithRelationInput | FamilyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Families.
     */
    cursor?: FamilyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Families from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Families.
     */
    skip?: number
    distinct?: FamilyScalarFieldEnum | FamilyScalarFieldEnum[]
  }

  /**
   * Family create
   */
  export type FamilyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * The data needed to create a Family.
     */
    data: XOR<FamilyCreateInput, FamilyUncheckedCreateInput>
  }

  /**
   * Family createMany
   */
  export type FamilyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Families.
     */
    data: FamilyCreateManyInput | FamilyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Family createManyAndReturn
   */
  export type FamilyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * The data used to create many Families.
     */
    data: FamilyCreateManyInput | FamilyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Family update
   */
  export type FamilyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * The data needed to update a Family.
     */
    data: XOR<FamilyUpdateInput, FamilyUncheckedUpdateInput>
    /**
     * Choose, which Family to update.
     */
    where: FamilyWhereUniqueInput
  }

  /**
   * Family updateMany
   */
  export type FamilyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Families.
     */
    data: XOR<FamilyUpdateManyMutationInput, FamilyUncheckedUpdateManyInput>
    /**
     * Filter which Families to update
     */
    where?: FamilyWhereInput
    /**
     * Limit how many Families to update.
     */
    limit?: number
  }

  /**
   * Family updateManyAndReturn
   */
  export type FamilyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * The data used to update Families.
     */
    data: XOR<FamilyUpdateManyMutationInput, FamilyUncheckedUpdateManyInput>
    /**
     * Filter which Families to update
     */
    where?: FamilyWhereInput
    /**
     * Limit how many Families to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Family upsert
   */
  export type FamilyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * The filter to search for the Family to update in case it exists.
     */
    where: FamilyWhereUniqueInput
    /**
     * In case the Family found by the `where` argument doesn't exist, create a new Family with this data.
     */
    create: XOR<FamilyCreateInput, FamilyUncheckedCreateInput>
    /**
     * In case the Family was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyUpdateInput, FamilyUncheckedUpdateInput>
  }

  /**
   * Family delete
   */
  export type FamilyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    /**
     * Filter which Family to delete.
     */
    where: FamilyWhereUniqueInput
  }

  /**
   * Family deleteMany
   */
  export type FamilyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Families to delete
     */
    where?: FamilyWhereInput
    /**
     * Limit how many Families to delete.
     */
    limit?: number
  }

  /**
   * Family.headOfFamily
   */
  export type Family$headOfFamilyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Family.parentFamily
   */
  export type Family$parentFamilyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    where?: FamilyWhereInput
  }

  /**
   * Family.subFamilies
   */
  export type Family$subFamiliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
    where?: FamilyWhereInput
    orderBy?: FamilyOrderByWithRelationInput | FamilyOrderByWithRelationInput[]
    cursor?: FamilyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyScalarFieldEnum | FamilyScalarFieldEnum[]
  }

  /**
   * Family.memberships
   */
  export type Family$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    where?: FamilyMembershipWhereInput
    orderBy?: FamilyMembershipOrderByWithRelationInput | FamilyMembershipOrderByWithRelationInput[]
    cursor?: FamilyMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMembershipScalarFieldEnum | FamilyMembershipScalarFieldEnum[]
  }

  /**
   * Family.invitations
   */
  export type Family$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Family without action
   */
  export type FamilyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Family
     */
    select?: FamilySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Family
     */
    omit?: FamilyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyInclude<ExtArgs> | null
  }


  /**
   * Model FamilyMembership
   */

  export type AggregateFamilyMembership = {
    _count: FamilyMembershipCountAggregateOutputType | null
    _min: FamilyMembershipMinAggregateOutputType | null
    _max: FamilyMembershipMaxAggregateOutputType | null
  }

  export type FamilyMembershipMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    memberId: string | null
    familyId: string | null
    role: $Enums.FamilyRole | null
    type: $Enums.MembershipType | null
    autoEnrolled: boolean | null
    manuallyEdited: boolean | null
    isActive: boolean | null
    joinDate: Date | null
  }

  export type FamilyMembershipMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    memberId: string | null
    familyId: string | null
    role: $Enums.FamilyRole | null
    type: $Enums.MembershipType | null
    autoEnrolled: boolean | null
    manuallyEdited: boolean | null
    isActive: boolean | null
    joinDate: Date | null
  }

  export type FamilyMembershipCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    memberId: number
    familyId: number
    role: number
    type: number
    autoEnrolled: number
    manuallyEdited: number
    isActive: number
    joinDate: number
    _all: number
  }


  export type FamilyMembershipMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    memberId?: true
    familyId?: true
    role?: true
    type?: true
    autoEnrolled?: true
    manuallyEdited?: true
    isActive?: true
    joinDate?: true
  }

  export type FamilyMembershipMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    memberId?: true
    familyId?: true
    role?: true
    type?: true
    autoEnrolled?: true
    manuallyEdited?: true
    isActive?: true
    joinDate?: true
  }

  export type FamilyMembershipCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    memberId?: true
    familyId?: true
    role?: true
    type?: true
    autoEnrolled?: true
    manuallyEdited?: true
    isActive?: true
    joinDate?: true
    _all?: true
  }

  export type FamilyMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMembership to aggregate.
     */
    where?: FamilyMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMemberships to fetch.
     */
    orderBy?: FamilyMembershipOrderByWithRelationInput | FamilyMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyMemberships
    **/
    _count?: true | FamilyMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyMembershipMaxAggregateInputType
  }

  export type GetFamilyMembershipAggregateType<T extends FamilyMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyMembership[P]>
      : GetScalarType<T[P], AggregateFamilyMembership[P]>
  }




  export type FamilyMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMembershipWhereInput
    orderBy?: FamilyMembershipOrderByWithAggregationInput | FamilyMembershipOrderByWithAggregationInput[]
    by: FamilyMembershipScalarFieldEnum[] | FamilyMembershipScalarFieldEnum
    having?: FamilyMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyMembershipCountAggregateInputType | true
    _min?: FamilyMembershipMinAggregateInputType
    _max?: FamilyMembershipMaxAggregateInputType
  }

  export type FamilyMembershipGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    memberId: string
    familyId: string
    role: $Enums.FamilyRole
    type: $Enums.MembershipType
    autoEnrolled: boolean
    manuallyEdited: boolean
    isActive: boolean
    joinDate: Date
    _count: FamilyMembershipCountAggregateOutputType | null
    _min: FamilyMembershipMinAggregateOutputType | null
    _max: FamilyMembershipMaxAggregateOutputType | null
  }

  type GetFamilyMembershipGroupByPayload<T extends FamilyMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyMembershipGroupByOutputType[P]>
        }
      >
    >


  export type FamilyMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberId?: boolean
    familyId?: boolean
    role?: boolean
    type?: boolean
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    family?: boolean | FamilyDefaultArgs<ExtArgs>
    familyMemberPermissions?: boolean | FamilyMembership$familyMemberPermissionsArgs<ExtArgs>
    _count?: boolean | FamilyMembershipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMembership"]>

  export type FamilyMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberId?: boolean
    familyId?: boolean
    role?: boolean
    type?: boolean
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    family?: boolean | FamilyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMembership"]>

  export type FamilyMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberId?: boolean
    familyId?: boolean
    role?: boolean
    type?: boolean
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    family?: boolean | FamilyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMembership"]>

  export type FamilyMembershipSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberId?: boolean
    familyId?: boolean
    role?: boolean
    type?: boolean
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: boolean
  }

  export type FamilyMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "memberId" | "familyId" | "role" | "type" | "autoEnrolled" | "manuallyEdited" | "isActive" | "joinDate", ExtArgs["result"]["familyMembership"]>
  export type FamilyMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    family?: boolean | FamilyDefaultArgs<ExtArgs>
    familyMemberPermissions?: boolean | FamilyMembership$familyMemberPermissionsArgs<ExtArgs>
    _count?: boolean | FamilyMembershipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FamilyMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    family?: boolean | FamilyDefaultArgs<ExtArgs>
  }
  export type FamilyMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    family?: boolean | FamilyDefaultArgs<ExtArgs>
  }

  export type $FamilyMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyMembership"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      family: Prisma.$FamilyPayload<ExtArgs>
      familyMemberPermissions: Prisma.$FamilyMemberPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      memberId: string
      familyId: string
      role: $Enums.FamilyRole
      type: $Enums.MembershipType
      autoEnrolled: boolean
      manuallyEdited: boolean
      isActive: boolean
      joinDate: Date
    }, ExtArgs["result"]["familyMembership"]>
    composites: {}
  }

  type FamilyMembershipGetPayload<S extends boolean | null | undefined | FamilyMembershipDefaultArgs> = $Result.GetResult<Prisma.$FamilyMembershipPayload, S>

  type FamilyMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyMembershipCountAggregateInputType | true
    }

  export interface FamilyMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyMembership'], meta: { name: 'FamilyMembership' } }
    /**
     * Find zero or one FamilyMembership that matches the filter.
     * @param {FamilyMembershipFindUniqueArgs} args - Arguments to find a FamilyMembership
     * @example
     * // Get one FamilyMembership
     * const familyMembership = await prisma.familyMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyMembershipFindUniqueArgs>(args: SelectSubset<T, FamilyMembershipFindUniqueArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyMembershipFindUniqueOrThrowArgs} args - Arguments to find a FamilyMembership
     * @example
     * // Get one FamilyMembership
     * const familyMembership = await prisma.familyMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMembershipFindFirstArgs} args - Arguments to find a FamilyMembership
     * @example
     * // Get one FamilyMembership
     * const familyMembership = await prisma.familyMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyMembershipFindFirstArgs>(args?: SelectSubset<T, FamilyMembershipFindFirstArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMembershipFindFirstOrThrowArgs} args - Arguments to find a FamilyMembership
     * @example
     * // Get one FamilyMembership
     * const familyMembership = await prisma.familyMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyMemberships
     * const familyMemberships = await prisma.familyMembership.findMany()
     * 
     * // Get first 10 FamilyMemberships
     * const familyMemberships = await prisma.familyMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyMembershipWithIdOnly = await prisma.familyMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyMembershipFindManyArgs>(args?: SelectSubset<T, FamilyMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyMembership.
     * @param {FamilyMembershipCreateArgs} args - Arguments to create a FamilyMembership.
     * @example
     * // Create one FamilyMembership
     * const FamilyMembership = await prisma.familyMembership.create({
     *   data: {
     *     // ... data to create a FamilyMembership
     *   }
     * })
     * 
     */
    create<T extends FamilyMembershipCreateArgs>(args: SelectSubset<T, FamilyMembershipCreateArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyMemberships.
     * @param {FamilyMembershipCreateManyArgs} args - Arguments to create many FamilyMemberships.
     * @example
     * // Create many FamilyMemberships
     * const familyMembership = await prisma.familyMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyMembershipCreateManyArgs>(args?: SelectSubset<T, FamilyMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FamilyMemberships and returns the data saved in the database.
     * @param {FamilyMembershipCreateManyAndReturnArgs} args - Arguments to create many FamilyMemberships.
     * @example
     * // Create many FamilyMemberships
     * const familyMembership = await prisma.familyMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FamilyMemberships and only return the `id`
     * const familyMembershipWithIdOnly = await prisma.familyMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FamilyMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, FamilyMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FamilyMembership.
     * @param {FamilyMembershipDeleteArgs} args - Arguments to delete one FamilyMembership.
     * @example
     * // Delete one FamilyMembership
     * const FamilyMembership = await prisma.familyMembership.delete({
     *   where: {
     *     // ... filter to delete one FamilyMembership
     *   }
     * })
     * 
     */
    delete<T extends FamilyMembershipDeleteArgs>(args: SelectSubset<T, FamilyMembershipDeleteArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyMembership.
     * @param {FamilyMembershipUpdateArgs} args - Arguments to update one FamilyMembership.
     * @example
     * // Update one FamilyMembership
     * const familyMembership = await prisma.familyMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyMembershipUpdateArgs>(args: SelectSubset<T, FamilyMembershipUpdateArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyMemberships.
     * @param {FamilyMembershipDeleteManyArgs} args - Arguments to filter FamilyMemberships to delete.
     * @example
     * // Delete a few FamilyMemberships
     * const { count } = await prisma.familyMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyMembershipDeleteManyArgs>(args?: SelectSubset<T, FamilyMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyMemberships
     * const familyMembership = await prisma.familyMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyMembershipUpdateManyArgs>(args: SelectSubset<T, FamilyMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMemberships and returns the data updated in the database.
     * @param {FamilyMembershipUpdateManyAndReturnArgs} args - Arguments to update many FamilyMemberships.
     * @example
     * // Update many FamilyMemberships
     * const familyMembership = await prisma.familyMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FamilyMemberships and only return the `id`
     * const familyMembershipWithIdOnly = await prisma.familyMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FamilyMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, FamilyMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FamilyMembership.
     * @param {FamilyMembershipUpsertArgs} args - Arguments to update or create a FamilyMembership.
     * @example
     * // Update or create a FamilyMembership
     * const familyMembership = await prisma.familyMembership.upsert({
     *   create: {
     *     // ... data to create a FamilyMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyMembership we want to update
     *   }
     * })
     */
    upsert<T extends FamilyMembershipUpsertArgs>(args: SelectSubset<T, FamilyMembershipUpsertArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMembershipCountArgs} args - Arguments to filter FamilyMemberships to count.
     * @example
     * // Count the number of FamilyMemberships
     * const count = await prisma.familyMembership.count({
     *   where: {
     *     // ... the filter for the FamilyMemberships we want to count
     *   }
     * })
    **/
    count<T extends FamilyMembershipCountArgs>(
      args?: Subset<T, FamilyMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyMembershipAggregateArgs>(args: Subset<T, FamilyMembershipAggregateArgs>): Prisma.PrismaPromise<GetFamilyMembershipAggregateType<T>>

    /**
     * Group by FamilyMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyMembershipGroupByArgs['orderBy'] }
        : { orderBy?: FamilyMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyMembership model
   */
  readonly fields: FamilyMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    family<T extends FamilyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyDefaultArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    familyMemberPermissions<T extends FamilyMembership$familyMemberPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMembership$familyMemberPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyMembership model
   */
  interface FamilyMembershipFieldRefs {
    readonly id: FieldRef<"FamilyMembership", 'String'>
    readonly createdAt: FieldRef<"FamilyMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"FamilyMembership", 'DateTime'>
    readonly memberId: FieldRef<"FamilyMembership", 'String'>
    readonly familyId: FieldRef<"FamilyMembership", 'String'>
    readonly role: FieldRef<"FamilyMembership", 'FamilyRole'>
    readonly type: FieldRef<"FamilyMembership", 'MembershipType'>
    readonly autoEnrolled: FieldRef<"FamilyMembership", 'Boolean'>
    readonly manuallyEdited: FieldRef<"FamilyMembership", 'Boolean'>
    readonly isActive: FieldRef<"FamilyMembership", 'Boolean'>
    readonly joinDate: FieldRef<"FamilyMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyMembership findUnique
   */
  export type FamilyMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMembership to fetch.
     */
    where: FamilyMembershipWhereUniqueInput
  }

  /**
   * FamilyMembership findUniqueOrThrow
   */
  export type FamilyMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMembership to fetch.
     */
    where: FamilyMembershipWhereUniqueInput
  }

  /**
   * FamilyMembership findFirst
   */
  export type FamilyMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMembership to fetch.
     */
    where?: FamilyMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMemberships to fetch.
     */
    orderBy?: FamilyMembershipOrderByWithRelationInput | FamilyMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMemberships.
     */
    cursor?: FamilyMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMemberships.
     */
    distinct?: FamilyMembershipScalarFieldEnum | FamilyMembershipScalarFieldEnum[]
  }

  /**
   * FamilyMembership findFirstOrThrow
   */
  export type FamilyMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMembership to fetch.
     */
    where?: FamilyMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMemberships to fetch.
     */
    orderBy?: FamilyMembershipOrderByWithRelationInput | FamilyMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMemberships.
     */
    cursor?: FamilyMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMemberships.
     */
    distinct?: FamilyMembershipScalarFieldEnum | FamilyMembershipScalarFieldEnum[]
  }

  /**
   * FamilyMembership findMany
   */
  export type FamilyMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMemberships to fetch.
     */
    where?: FamilyMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMemberships to fetch.
     */
    orderBy?: FamilyMembershipOrderByWithRelationInput | FamilyMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyMemberships.
     */
    cursor?: FamilyMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMemberships.
     */
    skip?: number
    distinct?: FamilyMembershipScalarFieldEnum | FamilyMembershipScalarFieldEnum[]
  }

  /**
   * FamilyMembership create
   */
  export type FamilyMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyMembership.
     */
    data: XOR<FamilyMembershipCreateInput, FamilyMembershipUncheckedCreateInput>
  }

  /**
   * FamilyMembership createMany
   */
  export type FamilyMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyMemberships.
     */
    data: FamilyMembershipCreateManyInput | FamilyMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyMembership createManyAndReturn
   */
  export type FamilyMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many FamilyMemberships.
     */
    data: FamilyMembershipCreateManyInput | FamilyMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FamilyMembership update
   */
  export type FamilyMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyMembership.
     */
    data: XOR<FamilyMembershipUpdateInput, FamilyMembershipUncheckedUpdateInput>
    /**
     * Choose, which FamilyMembership to update.
     */
    where: FamilyMembershipWhereUniqueInput
  }

  /**
   * FamilyMembership updateMany
   */
  export type FamilyMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyMemberships.
     */
    data: XOR<FamilyMembershipUpdateManyMutationInput, FamilyMembershipUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMemberships to update
     */
    where?: FamilyMembershipWhereInput
    /**
     * Limit how many FamilyMemberships to update.
     */
    limit?: number
  }

  /**
   * FamilyMembership updateManyAndReturn
   */
  export type FamilyMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * The data used to update FamilyMemberships.
     */
    data: XOR<FamilyMembershipUpdateManyMutationInput, FamilyMembershipUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMemberships to update
     */
    where?: FamilyMembershipWhereInput
    /**
     * Limit how many FamilyMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FamilyMembership upsert
   */
  export type FamilyMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyMembership to update in case it exists.
     */
    where: FamilyMembershipWhereUniqueInput
    /**
     * In case the FamilyMembership found by the `where` argument doesn't exist, create a new FamilyMembership with this data.
     */
    create: XOR<FamilyMembershipCreateInput, FamilyMembershipUncheckedCreateInput>
    /**
     * In case the FamilyMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyMembershipUpdateInput, FamilyMembershipUncheckedUpdateInput>
  }

  /**
   * FamilyMembership delete
   */
  export type FamilyMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
    /**
     * Filter which FamilyMembership to delete.
     */
    where: FamilyMembershipWhereUniqueInput
  }

  /**
   * FamilyMembership deleteMany
   */
  export type FamilyMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMemberships to delete
     */
    where?: FamilyMembershipWhereInput
    /**
     * Limit how many FamilyMemberships to delete.
     */
    limit?: number
  }

  /**
   * FamilyMembership.familyMemberPermissions
   */
  export type FamilyMembership$familyMemberPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    where?: FamilyMemberPermissionWhereInput
    orderBy?: FamilyMemberPermissionOrderByWithRelationInput | FamilyMemberPermissionOrderByWithRelationInput[]
    cursor?: FamilyMemberPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMemberPermissionScalarFieldEnum | FamilyMemberPermissionScalarFieldEnum[]
  }

  /**
   * FamilyMembership without action
   */
  export type FamilyMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMembership
     */
    select?: FamilyMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMembership
     */
    omit?: FamilyMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMembershipInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    code: string | null
    createdAt: Date | null
    expiresAt: Date | null
    status: $Enums.InvitationStatus | null
    usedAt: Date | null
    acceptedBy: string | null
    familyId: string | null
    inviterUserId: string | null
    inviterMemberId: string | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    code: string | null
    createdAt: Date | null
    expiresAt: Date | null
    status: $Enums.InvitationStatus | null
    usedAt: Date | null
    acceptedBy: string | null
    familyId: string | null
    inviterUserId: string | null
    inviterMemberId: string | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    code: number
    createdAt: number
    expiresAt: number
    status: number
    usedAt: number
    acceptedBy: number
    familyId: number
    inviterUserId: number
    inviterMemberId: number
    memberStub: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    code?: true
    createdAt?: true
    expiresAt?: true
    status?: true
    usedAt?: true
    acceptedBy?: true
    familyId?: true
    inviterUserId?: true
    inviterMemberId?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    code?: true
    createdAt?: true
    expiresAt?: true
    status?: true
    usedAt?: true
    acceptedBy?: true
    familyId?: true
    inviterUserId?: true
    inviterMemberId?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    code?: true
    createdAt?: true
    expiresAt?: true
    status?: true
    usedAt?: true
    acceptedBy?: true
    familyId?: true
    inviterUserId?: true
    inviterMemberId?: true
    memberStub?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    code: string
    createdAt: Date
    expiresAt: Date
    status: $Enums.InvitationStatus
    usedAt: Date | null
    acceptedBy: string | null
    familyId: string
    inviterUserId: string | null
    inviterMemberId: string | null
    memberStub: JsonValue | null
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    status?: boolean
    usedAt?: boolean
    acceptedBy?: boolean
    familyId?: boolean
    inviterUserId?: boolean
    inviterMemberId?: boolean
    memberStub?: boolean
    family?: boolean | FamilyDefaultArgs<ExtArgs>
    inviterUser?: boolean | Invitation$inviterUserArgs<ExtArgs>
    inviterMember?: boolean | Invitation$inviterMemberArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    status?: boolean
    usedAt?: boolean
    acceptedBy?: boolean
    familyId?: boolean
    inviterUserId?: boolean
    inviterMemberId?: boolean
    memberStub?: boolean
    family?: boolean | FamilyDefaultArgs<ExtArgs>
    inviterUser?: boolean | Invitation$inviterUserArgs<ExtArgs>
    inviterMember?: boolean | Invitation$inviterMemberArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    status?: boolean
    usedAt?: boolean
    acceptedBy?: boolean
    familyId?: boolean
    inviterUserId?: boolean
    inviterMemberId?: boolean
    memberStub?: boolean
    family?: boolean | FamilyDefaultArgs<ExtArgs>
    inviterUser?: boolean | Invitation$inviterUserArgs<ExtArgs>
    inviterMember?: boolean | Invitation$inviterMemberArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    status?: boolean
    usedAt?: boolean
    acceptedBy?: boolean
    familyId?: boolean
    inviterUserId?: boolean
    inviterMemberId?: boolean
    memberStub?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "createdAt" | "expiresAt" | "status" | "usedAt" | "acceptedBy" | "familyId" | "inviterUserId" | "inviterMemberId" | "memberStub", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    family?: boolean | FamilyDefaultArgs<ExtArgs>
    inviterUser?: boolean | Invitation$inviterUserArgs<ExtArgs>
    inviterMember?: boolean | Invitation$inviterMemberArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    family?: boolean | FamilyDefaultArgs<ExtArgs>
    inviterUser?: boolean | Invitation$inviterUserArgs<ExtArgs>
    inviterMember?: boolean | Invitation$inviterMemberArgs<ExtArgs>
  }
  export type InvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    family?: boolean | FamilyDefaultArgs<ExtArgs>
    inviterUser?: boolean | Invitation$inviterUserArgs<ExtArgs>
    inviterMember?: boolean | Invitation$inviterMemberArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      family: Prisma.$FamilyPayload<ExtArgs>
      inviterUser: Prisma.$UserPayload<ExtArgs> | null
      inviterMember: Prisma.$MemberPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      createdAt: Date
      expiresAt: Date
      status: $Enums.InvitationStatus
      usedAt: Date | null
      acceptedBy: string | null
      familyId: string
      inviterUserId: string | null
      inviterMemberId: string | null
      memberStub: Prisma.JsonValue | null
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    family<T extends FamilyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyDefaultArgs<ExtArgs>>): Prisma__FamilyClient<$Result.GetResult<Prisma.$FamilyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviterUser<T extends Invitation$inviterUserArgs<ExtArgs> = {}>(args?: Subset<T, Invitation$inviterUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inviterMember<T extends Invitation$inviterMemberArgs<ExtArgs> = {}>(args?: Subset<T, Invitation$inviterMemberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly code: FieldRef<"Invitation", 'String'>
    readonly createdAt: FieldRef<"Invitation", 'DateTime'>
    readonly expiresAt: FieldRef<"Invitation", 'DateTime'>
    readonly status: FieldRef<"Invitation", 'InvitationStatus'>
    readonly usedAt: FieldRef<"Invitation", 'DateTime'>
    readonly acceptedBy: FieldRef<"Invitation", 'String'>
    readonly familyId: FieldRef<"Invitation", 'String'>
    readonly inviterUserId: FieldRef<"Invitation", 'String'>
    readonly inviterMemberId: FieldRef<"Invitation", 'String'>
    readonly memberStub: FieldRef<"Invitation", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation.inviterUser
   */
  export type Invitation$inviterUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Invitation.inviterMember
   */
  export type Invitation$inviterMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    type: $Enums.FileType | null
    createdAt: Date | null
    updatedAt: Date | null
    uploadedBy: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    type: $Enums.FileType | null
    createdAt: Date | null
    updatedAt: Date | null
    uploadedBy: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    url: number
    type: number
    createdAt: number
    updatedAt: number
    uploadedBy: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    uploadedBy?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    uploadedBy?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    uploadedBy?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt: Date
    updatedAt: Date
    uploadedBy: string
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedBy?: boolean
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
    postAttachments?: boolean | File$postAttachmentsArgs<ExtArgs>
    commentAttachments?: boolean | File$commentAttachmentsArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedBy?: boolean
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedBy?: boolean
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedBy?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "mimeType" | "size" | "url" | "type" | "createdAt" | "updatedAt" | "uploadedBy", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
    postAttachments?: boolean | File$postAttachmentsArgs<ExtArgs>
    commentAttachments?: boolean | File$commentAttachmentsArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      uploader: Prisma.$MemberPayload<ExtArgs>
      postAttachments: Prisma.$PostFileAttachmentPayload<ExtArgs>[]
      commentAttachments: Prisma.$CommentFileAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalName: string
      mimeType: string
      size: number
      url: string
      type: $Enums.FileType
      createdAt: Date
      updatedAt: Date
      uploadedBy: string
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    postAttachments<T extends File$postAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, File$postAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentAttachments<T extends File$commentAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, File$commentAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly filename: FieldRef<"File", 'String'>
    readonly originalName: FieldRef<"File", 'String'>
    readonly mimeType: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly url: FieldRef<"File", 'String'>
    readonly type: FieldRef<"File", 'FileType'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly uploadedBy: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.postAttachments
   */
  export type File$postAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    where?: PostFileAttachmentWhereInput
    orderBy?: PostFileAttachmentOrderByWithRelationInput | PostFileAttachmentOrderByWithRelationInput[]
    cursor?: PostFileAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostFileAttachmentScalarFieldEnum | PostFileAttachmentScalarFieldEnum[]
  }

  /**
   * File.commentAttachments
   */
  export type File$commentAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    where?: CommentFileAttachmentWhereInput
    orderBy?: CommentFileAttachmentOrderByWithRelationInput | CommentFileAttachmentOrderByWithRelationInput[]
    cursor?: CommentFileAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentFileAttachmentScalarFieldEnum | CommentFileAttachmentScalarFieldEnum[]
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model PostFileAttachment
   */

  export type AggregatePostFileAttachment = {
    _count: PostFileAttachmentCountAggregateOutputType | null
    _avg: PostFileAttachmentAvgAggregateOutputType | null
    _sum: PostFileAttachmentSumAggregateOutputType | null
    _min: PostFileAttachmentMinAggregateOutputType | null
    _max: PostFileAttachmentMaxAggregateOutputType | null
  }

  export type PostFileAttachmentAvgAggregateOutputType = {
    order: number | null
  }

  export type PostFileAttachmentSumAggregateOutputType = {
    order: number | null
  }

  export type PostFileAttachmentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    fileId: string | null
    order: number | null
  }

  export type PostFileAttachmentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    fileId: string | null
    order: number | null
  }

  export type PostFileAttachmentCountAggregateOutputType = {
    id: number
    postId: number
    fileId: number
    order: number
    _all: number
  }


  export type PostFileAttachmentAvgAggregateInputType = {
    order?: true
  }

  export type PostFileAttachmentSumAggregateInputType = {
    order?: true
  }

  export type PostFileAttachmentMinAggregateInputType = {
    id?: true
    postId?: true
    fileId?: true
    order?: true
  }

  export type PostFileAttachmentMaxAggregateInputType = {
    id?: true
    postId?: true
    fileId?: true
    order?: true
  }

  export type PostFileAttachmentCountAggregateInputType = {
    id?: true
    postId?: true
    fileId?: true
    order?: true
    _all?: true
  }

  export type PostFileAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostFileAttachment to aggregate.
     */
    where?: PostFileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostFileAttachments to fetch.
     */
    orderBy?: PostFileAttachmentOrderByWithRelationInput | PostFileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostFileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostFileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostFileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostFileAttachments
    **/
    _count?: true | PostFileAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostFileAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostFileAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostFileAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostFileAttachmentMaxAggregateInputType
  }

  export type GetPostFileAttachmentAggregateType<T extends PostFileAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePostFileAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostFileAttachment[P]>
      : GetScalarType<T[P], AggregatePostFileAttachment[P]>
  }




  export type PostFileAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostFileAttachmentWhereInput
    orderBy?: PostFileAttachmentOrderByWithAggregationInput | PostFileAttachmentOrderByWithAggregationInput[]
    by: PostFileAttachmentScalarFieldEnum[] | PostFileAttachmentScalarFieldEnum
    having?: PostFileAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostFileAttachmentCountAggregateInputType | true
    _avg?: PostFileAttachmentAvgAggregateInputType
    _sum?: PostFileAttachmentSumAggregateInputType
    _min?: PostFileAttachmentMinAggregateInputType
    _max?: PostFileAttachmentMaxAggregateInputType
  }

  export type PostFileAttachmentGroupByOutputType = {
    id: string
    postId: string
    fileId: string
    order: number
    _count: PostFileAttachmentCountAggregateOutputType | null
    _avg: PostFileAttachmentAvgAggregateOutputType | null
    _sum: PostFileAttachmentSumAggregateOutputType | null
    _min: PostFileAttachmentMinAggregateOutputType | null
    _max: PostFileAttachmentMaxAggregateOutputType | null
  }

  type GetPostFileAttachmentGroupByPayload<T extends PostFileAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostFileAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostFileAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostFileAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], PostFileAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type PostFileAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    fileId?: boolean
    order?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postFileAttachment"]>

  export type PostFileAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    fileId?: boolean
    order?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postFileAttachment"]>

  export type PostFileAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    fileId?: boolean
    order?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postFileAttachment"]>

  export type PostFileAttachmentSelectScalar = {
    id?: boolean
    postId?: boolean
    fileId?: boolean
    order?: boolean
  }

  export type PostFileAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "fileId" | "order", ExtArgs["result"]["postFileAttachment"]>
  export type PostFileAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type PostFileAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type PostFileAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }

  export type $PostFileAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostFileAttachment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      file: Prisma.$FilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      fileId: string
      order: number
    }, ExtArgs["result"]["postFileAttachment"]>
    composites: {}
  }

  type PostFileAttachmentGetPayload<S extends boolean | null | undefined | PostFileAttachmentDefaultArgs> = $Result.GetResult<Prisma.$PostFileAttachmentPayload, S>

  type PostFileAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFileAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostFileAttachmentCountAggregateInputType | true
    }

  export interface PostFileAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostFileAttachment'], meta: { name: 'PostFileAttachment' } }
    /**
     * Find zero or one PostFileAttachment that matches the filter.
     * @param {PostFileAttachmentFindUniqueArgs} args - Arguments to find a PostFileAttachment
     * @example
     * // Get one PostFileAttachment
     * const postFileAttachment = await prisma.postFileAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFileAttachmentFindUniqueArgs>(args: SelectSubset<T, PostFileAttachmentFindUniqueArgs<ExtArgs>>): Prisma__PostFileAttachmentClient<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostFileAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFileAttachmentFindUniqueOrThrowArgs} args - Arguments to find a PostFileAttachment
     * @example
     * // Get one PostFileAttachment
     * const postFileAttachment = await prisma.postFileAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFileAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFileAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostFileAttachmentClient<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostFileAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFileAttachmentFindFirstArgs} args - Arguments to find a PostFileAttachment
     * @example
     * // Get one PostFileAttachment
     * const postFileAttachment = await prisma.postFileAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFileAttachmentFindFirstArgs>(args?: SelectSubset<T, PostFileAttachmentFindFirstArgs<ExtArgs>>): Prisma__PostFileAttachmentClient<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostFileAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFileAttachmentFindFirstOrThrowArgs} args - Arguments to find a PostFileAttachment
     * @example
     * // Get one PostFileAttachment
     * const postFileAttachment = await prisma.postFileAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFileAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFileAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostFileAttachmentClient<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostFileAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFileAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostFileAttachments
     * const postFileAttachments = await prisma.postFileAttachment.findMany()
     * 
     * // Get first 10 PostFileAttachments
     * const postFileAttachments = await prisma.postFileAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postFileAttachmentWithIdOnly = await prisma.postFileAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFileAttachmentFindManyArgs>(args?: SelectSubset<T, PostFileAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostFileAttachment.
     * @param {PostFileAttachmentCreateArgs} args - Arguments to create a PostFileAttachment.
     * @example
     * // Create one PostFileAttachment
     * const PostFileAttachment = await prisma.postFileAttachment.create({
     *   data: {
     *     // ... data to create a PostFileAttachment
     *   }
     * })
     * 
     */
    create<T extends PostFileAttachmentCreateArgs>(args: SelectSubset<T, PostFileAttachmentCreateArgs<ExtArgs>>): Prisma__PostFileAttachmentClient<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostFileAttachments.
     * @param {PostFileAttachmentCreateManyArgs} args - Arguments to create many PostFileAttachments.
     * @example
     * // Create many PostFileAttachments
     * const postFileAttachment = await prisma.postFileAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostFileAttachmentCreateManyArgs>(args?: SelectSubset<T, PostFileAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostFileAttachments and returns the data saved in the database.
     * @param {PostFileAttachmentCreateManyAndReturnArgs} args - Arguments to create many PostFileAttachments.
     * @example
     * // Create many PostFileAttachments
     * const postFileAttachment = await prisma.postFileAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostFileAttachments and only return the `id`
     * const postFileAttachmentWithIdOnly = await prisma.postFileAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostFileAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PostFileAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostFileAttachment.
     * @param {PostFileAttachmentDeleteArgs} args - Arguments to delete one PostFileAttachment.
     * @example
     * // Delete one PostFileAttachment
     * const PostFileAttachment = await prisma.postFileAttachment.delete({
     *   where: {
     *     // ... filter to delete one PostFileAttachment
     *   }
     * })
     * 
     */
    delete<T extends PostFileAttachmentDeleteArgs>(args: SelectSubset<T, PostFileAttachmentDeleteArgs<ExtArgs>>): Prisma__PostFileAttachmentClient<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostFileAttachment.
     * @param {PostFileAttachmentUpdateArgs} args - Arguments to update one PostFileAttachment.
     * @example
     * // Update one PostFileAttachment
     * const postFileAttachment = await prisma.postFileAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostFileAttachmentUpdateArgs>(args: SelectSubset<T, PostFileAttachmentUpdateArgs<ExtArgs>>): Prisma__PostFileAttachmentClient<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostFileAttachments.
     * @param {PostFileAttachmentDeleteManyArgs} args - Arguments to filter PostFileAttachments to delete.
     * @example
     * // Delete a few PostFileAttachments
     * const { count } = await prisma.postFileAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostFileAttachmentDeleteManyArgs>(args?: SelectSubset<T, PostFileAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostFileAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFileAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostFileAttachments
     * const postFileAttachment = await prisma.postFileAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostFileAttachmentUpdateManyArgs>(args: SelectSubset<T, PostFileAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostFileAttachments and returns the data updated in the database.
     * @param {PostFileAttachmentUpdateManyAndReturnArgs} args - Arguments to update many PostFileAttachments.
     * @example
     * // Update many PostFileAttachments
     * const postFileAttachment = await prisma.postFileAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostFileAttachments and only return the `id`
     * const postFileAttachmentWithIdOnly = await prisma.postFileAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostFileAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PostFileAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostFileAttachment.
     * @param {PostFileAttachmentUpsertArgs} args - Arguments to update or create a PostFileAttachment.
     * @example
     * // Update or create a PostFileAttachment
     * const postFileAttachment = await prisma.postFileAttachment.upsert({
     *   create: {
     *     // ... data to create a PostFileAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostFileAttachment we want to update
     *   }
     * })
     */
    upsert<T extends PostFileAttachmentUpsertArgs>(args: SelectSubset<T, PostFileAttachmentUpsertArgs<ExtArgs>>): Prisma__PostFileAttachmentClient<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostFileAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFileAttachmentCountArgs} args - Arguments to filter PostFileAttachments to count.
     * @example
     * // Count the number of PostFileAttachments
     * const count = await prisma.postFileAttachment.count({
     *   where: {
     *     // ... the filter for the PostFileAttachments we want to count
     *   }
     * })
    **/
    count<T extends PostFileAttachmentCountArgs>(
      args?: Subset<T, PostFileAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostFileAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostFileAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFileAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostFileAttachmentAggregateArgs>(args: Subset<T, PostFileAttachmentAggregateArgs>): Prisma.PrismaPromise<GetPostFileAttachmentAggregateType<T>>

    /**
     * Group by PostFileAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFileAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostFileAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostFileAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: PostFileAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostFileAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostFileAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostFileAttachment model
   */
  readonly fields: PostFileAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostFileAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostFileAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    file<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostFileAttachment model
   */
  interface PostFileAttachmentFieldRefs {
    readonly id: FieldRef<"PostFileAttachment", 'String'>
    readonly postId: FieldRef<"PostFileAttachment", 'String'>
    readonly fileId: FieldRef<"PostFileAttachment", 'String'>
    readonly order: FieldRef<"PostFileAttachment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PostFileAttachment findUnique
   */
  export type PostFileAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostFileAttachment to fetch.
     */
    where: PostFileAttachmentWhereUniqueInput
  }

  /**
   * PostFileAttachment findUniqueOrThrow
   */
  export type PostFileAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostFileAttachment to fetch.
     */
    where: PostFileAttachmentWhereUniqueInput
  }

  /**
   * PostFileAttachment findFirst
   */
  export type PostFileAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostFileAttachment to fetch.
     */
    where?: PostFileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostFileAttachments to fetch.
     */
    orderBy?: PostFileAttachmentOrderByWithRelationInput | PostFileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostFileAttachments.
     */
    cursor?: PostFileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostFileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostFileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostFileAttachments.
     */
    distinct?: PostFileAttachmentScalarFieldEnum | PostFileAttachmentScalarFieldEnum[]
  }

  /**
   * PostFileAttachment findFirstOrThrow
   */
  export type PostFileAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostFileAttachment to fetch.
     */
    where?: PostFileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostFileAttachments to fetch.
     */
    orderBy?: PostFileAttachmentOrderByWithRelationInput | PostFileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostFileAttachments.
     */
    cursor?: PostFileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostFileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostFileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostFileAttachments.
     */
    distinct?: PostFileAttachmentScalarFieldEnum | PostFileAttachmentScalarFieldEnum[]
  }

  /**
   * PostFileAttachment findMany
   */
  export type PostFileAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostFileAttachments to fetch.
     */
    where?: PostFileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostFileAttachments to fetch.
     */
    orderBy?: PostFileAttachmentOrderByWithRelationInput | PostFileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostFileAttachments.
     */
    cursor?: PostFileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostFileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostFileAttachments.
     */
    skip?: number
    distinct?: PostFileAttachmentScalarFieldEnum | PostFileAttachmentScalarFieldEnum[]
  }

  /**
   * PostFileAttachment create
   */
  export type PostFileAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PostFileAttachment.
     */
    data: XOR<PostFileAttachmentCreateInput, PostFileAttachmentUncheckedCreateInput>
  }

  /**
   * PostFileAttachment createMany
   */
  export type PostFileAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostFileAttachments.
     */
    data: PostFileAttachmentCreateManyInput | PostFileAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostFileAttachment createManyAndReturn
   */
  export type PostFileAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many PostFileAttachments.
     */
    data: PostFileAttachmentCreateManyInput | PostFileAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostFileAttachment update
   */
  export type PostFileAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PostFileAttachment.
     */
    data: XOR<PostFileAttachmentUpdateInput, PostFileAttachmentUncheckedUpdateInput>
    /**
     * Choose, which PostFileAttachment to update.
     */
    where: PostFileAttachmentWhereUniqueInput
  }

  /**
   * PostFileAttachment updateMany
   */
  export type PostFileAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostFileAttachments.
     */
    data: XOR<PostFileAttachmentUpdateManyMutationInput, PostFileAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PostFileAttachments to update
     */
    where?: PostFileAttachmentWhereInput
    /**
     * Limit how many PostFileAttachments to update.
     */
    limit?: number
  }

  /**
   * PostFileAttachment updateManyAndReturn
   */
  export type PostFileAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update PostFileAttachments.
     */
    data: XOR<PostFileAttachmentUpdateManyMutationInput, PostFileAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PostFileAttachments to update
     */
    where?: PostFileAttachmentWhereInput
    /**
     * Limit how many PostFileAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostFileAttachment upsert
   */
  export type PostFileAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PostFileAttachment to update in case it exists.
     */
    where: PostFileAttachmentWhereUniqueInput
    /**
     * In case the PostFileAttachment found by the `where` argument doesn't exist, create a new PostFileAttachment with this data.
     */
    create: XOR<PostFileAttachmentCreateInput, PostFileAttachmentUncheckedCreateInput>
    /**
     * In case the PostFileAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostFileAttachmentUpdateInput, PostFileAttachmentUncheckedUpdateInput>
  }

  /**
   * PostFileAttachment delete
   */
  export type PostFileAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter which PostFileAttachment to delete.
     */
    where: PostFileAttachmentWhereUniqueInput
  }

  /**
   * PostFileAttachment deleteMany
   */
  export type PostFileAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostFileAttachments to delete
     */
    where?: PostFileAttachmentWhereInput
    /**
     * Limit how many PostFileAttachments to delete.
     */
    limit?: number
  }

  /**
   * PostFileAttachment without action
   */
  export type PostFileAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model CommentFileAttachment
   */

  export type AggregateCommentFileAttachment = {
    _count: CommentFileAttachmentCountAggregateOutputType | null
    _min: CommentFileAttachmentMinAggregateOutputType | null
    _max: CommentFileAttachmentMaxAggregateOutputType | null
  }

  export type CommentFileAttachmentMinAggregateOutputType = {
    id: string | null
    commentId: string | null
    fileId: string | null
  }

  export type CommentFileAttachmentMaxAggregateOutputType = {
    id: string | null
    commentId: string | null
    fileId: string | null
  }

  export type CommentFileAttachmentCountAggregateOutputType = {
    id: number
    commentId: number
    fileId: number
    _all: number
  }


  export type CommentFileAttachmentMinAggregateInputType = {
    id?: true
    commentId?: true
    fileId?: true
  }

  export type CommentFileAttachmentMaxAggregateInputType = {
    id?: true
    commentId?: true
    fileId?: true
  }

  export type CommentFileAttachmentCountAggregateInputType = {
    id?: true
    commentId?: true
    fileId?: true
    _all?: true
  }

  export type CommentFileAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentFileAttachment to aggregate.
     */
    where?: CommentFileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentFileAttachments to fetch.
     */
    orderBy?: CommentFileAttachmentOrderByWithRelationInput | CommentFileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentFileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentFileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentFileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentFileAttachments
    **/
    _count?: true | CommentFileAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentFileAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentFileAttachmentMaxAggregateInputType
  }

  export type GetCommentFileAttachmentAggregateType<T extends CommentFileAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentFileAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentFileAttachment[P]>
      : GetScalarType<T[P], AggregateCommentFileAttachment[P]>
  }




  export type CommentFileAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentFileAttachmentWhereInput
    orderBy?: CommentFileAttachmentOrderByWithAggregationInput | CommentFileAttachmentOrderByWithAggregationInput[]
    by: CommentFileAttachmentScalarFieldEnum[] | CommentFileAttachmentScalarFieldEnum
    having?: CommentFileAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentFileAttachmentCountAggregateInputType | true
    _min?: CommentFileAttachmentMinAggregateInputType
    _max?: CommentFileAttachmentMaxAggregateInputType
  }

  export type CommentFileAttachmentGroupByOutputType = {
    id: string
    commentId: string
    fileId: string
    _count: CommentFileAttachmentCountAggregateOutputType | null
    _min: CommentFileAttachmentMinAggregateOutputType | null
    _max: CommentFileAttachmentMaxAggregateOutputType | null
  }

  type GetCommentFileAttachmentGroupByPayload<T extends CommentFileAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentFileAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentFileAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentFileAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentFileAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type CommentFileAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    fileId?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentFileAttachment"]>

  export type CommentFileAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    fileId?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentFileAttachment"]>

  export type CommentFileAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    fileId?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentFileAttachment"]>

  export type CommentFileAttachmentSelectScalar = {
    id?: boolean
    commentId?: boolean
    fileId?: boolean
  }

  export type CommentFileAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commentId" | "fileId", ExtArgs["result"]["commentFileAttachment"]>
  export type CommentFileAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type CommentFileAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }
  export type CommentFileAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    file?: boolean | FileDefaultArgs<ExtArgs>
  }

  export type $CommentFileAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentFileAttachment"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      file: Prisma.$FilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commentId: string
      fileId: string
    }, ExtArgs["result"]["commentFileAttachment"]>
    composites: {}
  }

  type CommentFileAttachmentGetPayload<S extends boolean | null | undefined | CommentFileAttachmentDefaultArgs> = $Result.GetResult<Prisma.$CommentFileAttachmentPayload, S>

  type CommentFileAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFileAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentFileAttachmentCountAggregateInputType | true
    }

  export interface CommentFileAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentFileAttachment'], meta: { name: 'CommentFileAttachment' } }
    /**
     * Find zero or one CommentFileAttachment that matches the filter.
     * @param {CommentFileAttachmentFindUniqueArgs} args - Arguments to find a CommentFileAttachment
     * @example
     * // Get one CommentFileAttachment
     * const commentFileAttachment = await prisma.commentFileAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFileAttachmentFindUniqueArgs>(args: SelectSubset<T, CommentFileAttachmentFindUniqueArgs<ExtArgs>>): Prisma__CommentFileAttachmentClient<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentFileAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFileAttachmentFindUniqueOrThrowArgs} args - Arguments to find a CommentFileAttachment
     * @example
     * // Get one CommentFileAttachment
     * const commentFileAttachment = await prisma.commentFileAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFileAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFileAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentFileAttachmentClient<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentFileAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFileAttachmentFindFirstArgs} args - Arguments to find a CommentFileAttachment
     * @example
     * // Get one CommentFileAttachment
     * const commentFileAttachment = await prisma.commentFileAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFileAttachmentFindFirstArgs>(args?: SelectSubset<T, CommentFileAttachmentFindFirstArgs<ExtArgs>>): Prisma__CommentFileAttachmentClient<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentFileAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFileAttachmentFindFirstOrThrowArgs} args - Arguments to find a CommentFileAttachment
     * @example
     * // Get one CommentFileAttachment
     * const commentFileAttachment = await prisma.commentFileAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFileAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFileAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentFileAttachmentClient<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentFileAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFileAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentFileAttachments
     * const commentFileAttachments = await prisma.commentFileAttachment.findMany()
     * 
     * // Get first 10 CommentFileAttachments
     * const commentFileAttachments = await prisma.commentFileAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentFileAttachmentWithIdOnly = await prisma.commentFileAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFileAttachmentFindManyArgs>(args?: SelectSubset<T, CommentFileAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentFileAttachment.
     * @param {CommentFileAttachmentCreateArgs} args - Arguments to create a CommentFileAttachment.
     * @example
     * // Create one CommentFileAttachment
     * const CommentFileAttachment = await prisma.commentFileAttachment.create({
     *   data: {
     *     // ... data to create a CommentFileAttachment
     *   }
     * })
     * 
     */
    create<T extends CommentFileAttachmentCreateArgs>(args: SelectSubset<T, CommentFileAttachmentCreateArgs<ExtArgs>>): Prisma__CommentFileAttachmentClient<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentFileAttachments.
     * @param {CommentFileAttachmentCreateManyArgs} args - Arguments to create many CommentFileAttachments.
     * @example
     * // Create many CommentFileAttachments
     * const commentFileAttachment = await prisma.commentFileAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentFileAttachmentCreateManyArgs>(args?: SelectSubset<T, CommentFileAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentFileAttachments and returns the data saved in the database.
     * @param {CommentFileAttachmentCreateManyAndReturnArgs} args - Arguments to create many CommentFileAttachments.
     * @example
     * // Create many CommentFileAttachments
     * const commentFileAttachment = await prisma.commentFileAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentFileAttachments and only return the `id`
     * const commentFileAttachmentWithIdOnly = await prisma.commentFileAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentFileAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentFileAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentFileAttachment.
     * @param {CommentFileAttachmentDeleteArgs} args - Arguments to delete one CommentFileAttachment.
     * @example
     * // Delete one CommentFileAttachment
     * const CommentFileAttachment = await prisma.commentFileAttachment.delete({
     *   where: {
     *     // ... filter to delete one CommentFileAttachment
     *   }
     * })
     * 
     */
    delete<T extends CommentFileAttachmentDeleteArgs>(args: SelectSubset<T, CommentFileAttachmentDeleteArgs<ExtArgs>>): Prisma__CommentFileAttachmentClient<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentFileAttachment.
     * @param {CommentFileAttachmentUpdateArgs} args - Arguments to update one CommentFileAttachment.
     * @example
     * // Update one CommentFileAttachment
     * const commentFileAttachment = await prisma.commentFileAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentFileAttachmentUpdateArgs>(args: SelectSubset<T, CommentFileAttachmentUpdateArgs<ExtArgs>>): Prisma__CommentFileAttachmentClient<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentFileAttachments.
     * @param {CommentFileAttachmentDeleteManyArgs} args - Arguments to filter CommentFileAttachments to delete.
     * @example
     * // Delete a few CommentFileAttachments
     * const { count } = await prisma.commentFileAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentFileAttachmentDeleteManyArgs>(args?: SelectSubset<T, CommentFileAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentFileAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFileAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentFileAttachments
     * const commentFileAttachment = await prisma.commentFileAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentFileAttachmentUpdateManyArgs>(args: SelectSubset<T, CommentFileAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentFileAttachments and returns the data updated in the database.
     * @param {CommentFileAttachmentUpdateManyAndReturnArgs} args - Arguments to update many CommentFileAttachments.
     * @example
     * // Update many CommentFileAttachments
     * const commentFileAttachment = await prisma.commentFileAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentFileAttachments and only return the `id`
     * const commentFileAttachmentWithIdOnly = await prisma.commentFileAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentFileAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentFileAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentFileAttachment.
     * @param {CommentFileAttachmentUpsertArgs} args - Arguments to update or create a CommentFileAttachment.
     * @example
     * // Update or create a CommentFileAttachment
     * const commentFileAttachment = await prisma.commentFileAttachment.upsert({
     *   create: {
     *     // ... data to create a CommentFileAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentFileAttachment we want to update
     *   }
     * })
     */
    upsert<T extends CommentFileAttachmentUpsertArgs>(args: SelectSubset<T, CommentFileAttachmentUpsertArgs<ExtArgs>>): Prisma__CommentFileAttachmentClient<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentFileAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFileAttachmentCountArgs} args - Arguments to filter CommentFileAttachments to count.
     * @example
     * // Count the number of CommentFileAttachments
     * const count = await prisma.commentFileAttachment.count({
     *   where: {
     *     // ... the filter for the CommentFileAttachments we want to count
     *   }
     * })
    **/
    count<T extends CommentFileAttachmentCountArgs>(
      args?: Subset<T, CommentFileAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentFileAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentFileAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFileAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentFileAttachmentAggregateArgs>(args: Subset<T, CommentFileAttachmentAggregateArgs>): Prisma.PrismaPromise<GetCommentFileAttachmentAggregateType<T>>

    /**
     * Group by CommentFileAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFileAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentFileAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentFileAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: CommentFileAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentFileAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentFileAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentFileAttachment model
   */
  readonly fields: CommentFileAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentFileAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentFileAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    file<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentFileAttachment model
   */
  interface CommentFileAttachmentFieldRefs {
    readonly id: FieldRef<"CommentFileAttachment", 'String'>
    readonly commentId: FieldRef<"CommentFileAttachment", 'String'>
    readonly fileId: FieldRef<"CommentFileAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CommentFileAttachment findUnique
   */
  export type CommentFileAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentFileAttachment to fetch.
     */
    where: CommentFileAttachmentWhereUniqueInput
  }

  /**
   * CommentFileAttachment findUniqueOrThrow
   */
  export type CommentFileAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentFileAttachment to fetch.
     */
    where: CommentFileAttachmentWhereUniqueInput
  }

  /**
   * CommentFileAttachment findFirst
   */
  export type CommentFileAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentFileAttachment to fetch.
     */
    where?: CommentFileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentFileAttachments to fetch.
     */
    orderBy?: CommentFileAttachmentOrderByWithRelationInput | CommentFileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentFileAttachments.
     */
    cursor?: CommentFileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentFileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentFileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentFileAttachments.
     */
    distinct?: CommentFileAttachmentScalarFieldEnum | CommentFileAttachmentScalarFieldEnum[]
  }

  /**
   * CommentFileAttachment findFirstOrThrow
   */
  export type CommentFileAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentFileAttachment to fetch.
     */
    where?: CommentFileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentFileAttachments to fetch.
     */
    orderBy?: CommentFileAttachmentOrderByWithRelationInput | CommentFileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentFileAttachments.
     */
    cursor?: CommentFileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentFileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentFileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentFileAttachments.
     */
    distinct?: CommentFileAttachmentScalarFieldEnum | CommentFileAttachmentScalarFieldEnum[]
  }

  /**
   * CommentFileAttachment findMany
   */
  export type CommentFileAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentFileAttachments to fetch.
     */
    where?: CommentFileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentFileAttachments to fetch.
     */
    orderBy?: CommentFileAttachmentOrderByWithRelationInput | CommentFileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentFileAttachments.
     */
    cursor?: CommentFileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentFileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentFileAttachments.
     */
    skip?: number
    distinct?: CommentFileAttachmentScalarFieldEnum | CommentFileAttachmentScalarFieldEnum[]
  }

  /**
   * CommentFileAttachment create
   */
  export type CommentFileAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentFileAttachment.
     */
    data: XOR<CommentFileAttachmentCreateInput, CommentFileAttachmentUncheckedCreateInput>
  }

  /**
   * CommentFileAttachment createMany
   */
  export type CommentFileAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentFileAttachments.
     */
    data: CommentFileAttachmentCreateManyInput | CommentFileAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentFileAttachment createManyAndReturn
   */
  export type CommentFileAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many CommentFileAttachments.
     */
    data: CommentFileAttachmentCreateManyInput | CommentFileAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentFileAttachment update
   */
  export type CommentFileAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentFileAttachment.
     */
    data: XOR<CommentFileAttachmentUpdateInput, CommentFileAttachmentUncheckedUpdateInput>
    /**
     * Choose, which CommentFileAttachment to update.
     */
    where: CommentFileAttachmentWhereUniqueInput
  }

  /**
   * CommentFileAttachment updateMany
   */
  export type CommentFileAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentFileAttachments.
     */
    data: XOR<CommentFileAttachmentUpdateManyMutationInput, CommentFileAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which CommentFileAttachments to update
     */
    where?: CommentFileAttachmentWhereInput
    /**
     * Limit how many CommentFileAttachments to update.
     */
    limit?: number
  }

  /**
   * CommentFileAttachment updateManyAndReturn
   */
  export type CommentFileAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update CommentFileAttachments.
     */
    data: XOR<CommentFileAttachmentUpdateManyMutationInput, CommentFileAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which CommentFileAttachments to update
     */
    where?: CommentFileAttachmentWhereInput
    /**
     * Limit how many CommentFileAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentFileAttachment upsert
   */
  export type CommentFileAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentFileAttachment to update in case it exists.
     */
    where: CommentFileAttachmentWhereUniqueInput
    /**
     * In case the CommentFileAttachment found by the `where` argument doesn't exist, create a new CommentFileAttachment with this data.
     */
    create: XOR<CommentFileAttachmentCreateInput, CommentFileAttachmentUncheckedCreateInput>
    /**
     * In case the CommentFileAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentFileAttachmentUpdateInput, CommentFileAttachmentUncheckedUpdateInput>
  }

  /**
   * CommentFileAttachment delete
   */
  export type CommentFileAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    /**
     * Filter which CommentFileAttachment to delete.
     */
    where: CommentFileAttachmentWhereUniqueInput
  }

  /**
   * CommentFileAttachment deleteMany
   */
  export type CommentFileAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentFileAttachments to delete
     */
    where?: CommentFileAttachmentWhereInput
    /**
     * Limit how many CommentFileAttachments to delete.
     */
    limit?: number
  }

  /**
   * CommentFileAttachment without action
   */
  export type CommentFileAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    likesCount: number | null
  }

  export type PostSumAggregateOutputType = {
    likesCount: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    content: string | null
    videoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    visibility: $Enums.PostVisibility | null
    authorId: string | null
    familyId: string | null
    likesCount: number | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    content: string | null
    videoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    visibility: $Enums.PostVisibility | null
    authorId: string | null
    familyId: string | null
    likesCount: number | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    content: number
    imageUrls: number
    videoUrl: number
    createdAt: number
    updatedAt: number
    visibility: number
    authorId: number
    familyId: number
    likesCount: number
    editHistory: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    likesCount?: true
  }

  export type PostSumAggregateInputType = {
    likesCount?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    content?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
    visibility?: true
    authorId?: true
    familyId?: true
    likesCount?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    content?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
    visibility?: true
    authorId?: true
    familyId?: true
    likesCount?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    content?: true
    imageUrls?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
    visibility?: true
    authorId?: true
    familyId?: true
    likesCount?: true
    editHistory?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    content: string
    imageUrls: string[]
    videoUrl: string | null
    createdAt: Date
    updatedAt: Date
    visibility: $Enums.PostVisibility
    authorId: string
    familyId: string | null
    likesCount: number
    editHistory: JsonValue | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    imageUrls?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visibility?: boolean
    authorId?: boolean
    familyId?: boolean
    likesCount?: boolean
    editHistory?: boolean
    author?: boolean | MemberDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    fileAttachments?: boolean | Post$fileAttachmentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    imageUrls?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visibility?: boolean
    authorId?: boolean
    familyId?: boolean
    likesCount?: boolean
    editHistory?: boolean
    author?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    imageUrls?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visibility?: boolean
    authorId?: boolean
    familyId?: boolean
    likesCount?: boolean
    editHistory?: boolean
    author?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    content?: boolean
    imageUrls?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visibility?: boolean
    authorId?: boolean
    familyId?: boolean
    likesCount?: boolean
    editHistory?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "imageUrls" | "videoUrl" | "createdAt" | "updatedAt" | "visibility" | "authorId" | "familyId" | "likesCount" | "editHistory", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | MemberDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    fileAttachments?: boolean | Post$fileAttachmentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$MemberPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$PostLikePayload<ExtArgs>[]
      fileAttachments: Prisma.$PostFileAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      imageUrls: string[]
      videoUrl: string | null
      createdAt: Date
      updatedAt: Date
      visibility: $Enums.PostVisibility
      authorId: string
      familyId: string | null
      likesCount: number
      editHistory: Prisma.JsonValue | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Post$likesArgs<ExtArgs> = {}>(args?: Subset<T, Post$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileAttachments<T extends Post$fileAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$fileAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostFileAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly imageUrls: FieldRef<"Post", 'String[]'>
    readonly videoUrl: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly visibility: FieldRef<"Post", 'PostVisibility'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly familyId: FieldRef<"Post", 'String'>
    readonly likesCount: FieldRef<"Post", 'Int'>
    readonly editHistory: FieldRef<"Post", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.likes
   */
  export type Post$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    cursor?: PostLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * Post.fileAttachments
   */
  export type Post$fileAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostFileAttachment
     */
    select?: PostFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostFileAttachment
     */
    omit?: PostFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostFileAttachmentInclude<ExtArgs> | null
    where?: PostFileAttachmentWhereInput
    orderBy?: PostFileAttachmentOrderByWithRelationInput | PostFileAttachmentOrderByWithRelationInput[]
    cursor?: PostFileAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostFileAttachmentScalarFieldEnum | PostFileAttachmentScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    likesCount: number | null
  }

  export type CommentSumAggregateOutputType = {
    likesCount: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postId: string | null
    authorId: string | null
    parentCommentId: string | null
    likesCount: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postId: string | null
    authorId: string | null
    parentCommentId: string | null
    likesCount: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    postId: number
    authorId: number
    parentCommentId: number
    likesCount: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    likesCount?: true
  }

  export type CommentSumAggregateInputType = {
    likesCount?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    authorId?: true
    parentCommentId?: true
    likesCount?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    authorId?: true
    parentCommentId?: true
    likesCount?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    authorId?: true
    parentCommentId?: true
    likesCount?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    postId: string
    authorId: string
    parentCommentId: string | null
    likesCount: number
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    authorId?: boolean
    parentCommentId?: boolean
    likesCount?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    likes?: boolean | Comment$likesArgs<ExtArgs>
    fileAttachments?: boolean | Comment$fileAttachmentsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    authorId?: boolean
    parentCommentId?: boolean
    likesCount?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    authorId?: boolean
    parentCommentId?: boolean
    likesCount?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    authorId?: boolean
    parentCommentId?: boolean
    likesCount?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "imageUrl" | "createdAt" | "updatedAt" | "postId" | "authorId" | "parentCommentId" | "likesCount", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    likes?: boolean | Comment$likesArgs<ExtArgs>
    fileAttachments?: boolean | Comment$fileAttachmentsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      author: Prisma.$MemberPayload<ExtArgs>
      parentComment: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$CommentLikePayload<ExtArgs>[]
      fileAttachments: Prisma.$CommentFileAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
      postId: string
      authorId: string
      parentCommentId: string | null
      likesCount: number
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentComment<T extends Comment$parentCommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentCommentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Comment$likesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fileAttachments<T extends Comment$fileAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$fileAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentFileAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly imageUrl: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly parentCommentId: FieldRef<"Comment", 'String'>
    readonly likesCount: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parentComment
   */
  export type Comment$parentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.likes
   */
  export type Comment$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    where?: CommentLikeWhereInput
    orderBy?: CommentLikeOrderByWithRelationInput | CommentLikeOrderByWithRelationInput[]
    cursor?: CommentLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentLikeScalarFieldEnum | CommentLikeScalarFieldEnum[]
  }

  /**
   * Comment.fileAttachments
   */
  export type Comment$fileAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentFileAttachment
     */
    select?: CommentFileAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentFileAttachment
     */
    omit?: CommentFileAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentFileAttachmentInclude<ExtArgs> | null
    where?: CommentFileAttachmentWhereInput
    orderBy?: CommentFileAttachmentOrderByWithRelationInput | CommentFileAttachmentOrderByWithRelationInput[]
    cursor?: CommentFileAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentFileAttachmentScalarFieldEnum | CommentFileAttachmentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model PostLike
   */

  export type AggregatePostLike = {
    _count: PostLikeCountAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  export type PostLikeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    postId: string | null
    memberId: string | null
  }

  export type PostLikeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    postId: string | null
    memberId: string | null
  }

  export type PostLikeCountAggregateOutputType = {
    id: number
    createdAt: number
    postId: number
    memberId: number
    _all: number
  }


  export type PostLikeMinAggregateInputType = {
    id?: true
    createdAt?: true
    postId?: true
    memberId?: true
  }

  export type PostLikeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    postId?: true
    memberId?: true
  }

  export type PostLikeCountAggregateInputType = {
    id?: true
    createdAt?: true
    postId?: true
    memberId?: true
    _all?: true
  }

  export type PostLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostLike to aggregate.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostLikes
    **/
    _count?: true | PostLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostLikeMaxAggregateInputType
  }

  export type GetPostLikeAggregateType<T extends PostLikeAggregateArgs> = {
        [P in keyof T & keyof AggregatePostLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostLike[P]>
      : GetScalarType<T[P], AggregatePostLike[P]>
  }




  export type PostLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithAggregationInput | PostLikeOrderByWithAggregationInput[]
    by: PostLikeScalarFieldEnum[] | PostLikeScalarFieldEnum
    having?: PostLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostLikeCountAggregateInputType | true
    _min?: PostLikeMinAggregateInputType
    _max?: PostLikeMaxAggregateInputType
  }

  export type PostLikeGroupByOutputType = {
    id: string
    createdAt: Date
    postId: string
    memberId: string
    _count: PostLikeCountAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  type GetPostLikeGroupByPayload<T extends PostLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
            : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
        }
      >
    >


  export type PostLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    postId?: boolean
    memberId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postLike"]>

  export type PostLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    postId?: boolean
    memberId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postLike"]>

  export type PostLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    postId?: boolean
    memberId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postLike"]>

  export type PostLikeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    postId?: boolean
    memberId?: boolean
  }

  export type PostLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "postId" | "memberId", ExtArgs["result"]["postLike"]>
  export type PostLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PostLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PostLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $PostLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostLike"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      postId: string
      memberId: string
    }, ExtArgs["result"]["postLike"]>
    composites: {}
  }

  type PostLikeGetPayload<S extends boolean | null | undefined | PostLikeDefaultArgs> = $Result.GetResult<Prisma.$PostLikePayload, S>

  type PostLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostLikeCountAggregateInputType | true
    }

  export interface PostLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostLike'], meta: { name: 'PostLike' } }
    /**
     * Find zero or one PostLike that matches the filter.
     * @param {PostLikeFindUniqueArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostLikeFindUniqueArgs>(args: SelectSubset<T, PostLikeFindUniqueArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostLikeFindUniqueOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, PostLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostLikeFindFirstArgs>(args?: SelectSubset<T, PostLikeFindFirstArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, PostLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostLikes
     * const postLikes = await prisma.postLike.findMany()
     * 
     * // Get first 10 PostLikes
     * const postLikes = await prisma.postLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postLikeWithIdOnly = await prisma.postLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostLikeFindManyArgs>(args?: SelectSubset<T, PostLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostLike.
     * @param {PostLikeCreateArgs} args - Arguments to create a PostLike.
     * @example
     * // Create one PostLike
     * const PostLike = await prisma.postLike.create({
     *   data: {
     *     // ... data to create a PostLike
     *   }
     * })
     * 
     */
    create<T extends PostLikeCreateArgs>(args: SelectSubset<T, PostLikeCreateArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostLikes.
     * @param {PostLikeCreateManyArgs} args - Arguments to create many PostLikes.
     * @example
     * // Create many PostLikes
     * const postLike = await prisma.postLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostLikeCreateManyArgs>(args?: SelectSubset<T, PostLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostLikes and returns the data saved in the database.
     * @param {PostLikeCreateManyAndReturnArgs} args - Arguments to create many PostLikes.
     * @example
     * // Create many PostLikes
     * const postLike = await prisma.postLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostLikes and only return the `id`
     * const postLikeWithIdOnly = await prisma.postLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, PostLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostLike.
     * @param {PostLikeDeleteArgs} args - Arguments to delete one PostLike.
     * @example
     * // Delete one PostLike
     * const PostLike = await prisma.postLike.delete({
     *   where: {
     *     // ... filter to delete one PostLike
     *   }
     * })
     * 
     */
    delete<T extends PostLikeDeleteArgs>(args: SelectSubset<T, PostLikeDeleteArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostLike.
     * @param {PostLikeUpdateArgs} args - Arguments to update one PostLike.
     * @example
     * // Update one PostLike
     * const postLike = await prisma.postLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostLikeUpdateArgs>(args: SelectSubset<T, PostLikeUpdateArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostLikes.
     * @param {PostLikeDeleteManyArgs} args - Arguments to filter PostLikes to delete.
     * @example
     * // Delete a few PostLikes
     * const { count } = await prisma.postLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostLikeDeleteManyArgs>(args?: SelectSubset<T, PostLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostLikes
     * const postLike = await prisma.postLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostLikeUpdateManyArgs>(args: SelectSubset<T, PostLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostLikes and returns the data updated in the database.
     * @param {PostLikeUpdateManyAndReturnArgs} args - Arguments to update many PostLikes.
     * @example
     * // Update many PostLikes
     * const postLike = await prisma.postLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostLikes and only return the `id`
     * const postLikeWithIdOnly = await prisma.postLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, PostLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostLike.
     * @param {PostLikeUpsertArgs} args - Arguments to update or create a PostLike.
     * @example
     * // Update or create a PostLike
     * const postLike = await prisma.postLike.upsert({
     *   create: {
     *     // ... data to create a PostLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostLike we want to update
     *   }
     * })
     */
    upsert<T extends PostLikeUpsertArgs>(args: SelectSubset<T, PostLikeUpsertArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeCountArgs} args - Arguments to filter PostLikes to count.
     * @example
     * // Count the number of PostLikes
     * const count = await prisma.postLike.count({
     *   where: {
     *     // ... the filter for the PostLikes we want to count
     *   }
     * })
    **/
    count<T extends PostLikeCountArgs>(
      args?: Subset<T, PostLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostLikeAggregateArgs>(args: Subset<T, PostLikeAggregateArgs>): Prisma.PrismaPromise<GetPostLikeAggregateType<T>>

    /**
     * Group by PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostLikeGroupByArgs['orderBy'] }
        : { orderBy?: PostLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostLike model
   */
  readonly fields: PostLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostLike model
   */
  interface PostLikeFieldRefs {
    readonly id: FieldRef<"PostLike", 'String'>
    readonly createdAt: FieldRef<"PostLike", 'DateTime'>
    readonly postId: FieldRef<"PostLike", 'String'>
    readonly memberId: FieldRef<"PostLike", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostLike findUnique
   */
  export type PostLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike findUniqueOrThrow
   */
  export type PostLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike findFirst
   */
  export type PostLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike findFirstOrThrow
   */
  export type PostLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike findMany
   */
  export type PostLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike create
   */
  export type PostLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a PostLike.
     */
    data: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
  }

  /**
   * PostLike createMany
   */
  export type PostLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostLikes.
     */
    data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostLike createManyAndReturn
   */
  export type PostLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * The data used to create many PostLikes.
     */
    data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostLike update
   */
  export type PostLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a PostLike.
     */
    data: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
    /**
     * Choose, which PostLike to update.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike updateMany
   */
  export type PostLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostLikes.
     */
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyInput>
    /**
     * Filter which PostLikes to update
     */
    where?: PostLikeWhereInput
    /**
     * Limit how many PostLikes to update.
     */
    limit?: number
  }

  /**
   * PostLike updateManyAndReturn
   */
  export type PostLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * The data used to update PostLikes.
     */
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyInput>
    /**
     * Filter which PostLikes to update
     */
    where?: PostLikeWhereInput
    /**
     * Limit how many PostLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostLike upsert
   */
  export type PostLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the PostLike to update in case it exists.
     */
    where: PostLikeWhereUniqueInput
    /**
     * In case the PostLike found by the `where` argument doesn't exist, create a new PostLike with this data.
     */
    create: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
    /**
     * In case the PostLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
  }

  /**
   * PostLike delete
   */
  export type PostLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter which PostLike to delete.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike deleteMany
   */
  export type PostLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostLikes to delete
     */
    where?: PostLikeWhereInput
    /**
     * Limit how many PostLikes to delete.
     */
    limit?: number
  }

  /**
   * PostLike without action
   */
  export type PostLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostLike
     */
    omit?: PostLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
  }


  /**
   * Model CommentLike
   */

  export type AggregateCommentLike = {
    _count: CommentLikeCountAggregateOutputType | null
    _min: CommentLikeMinAggregateOutputType | null
    _max: CommentLikeMaxAggregateOutputType | null
  }

  export type CommentLikeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    commentId: string | null
    memberId: string | null
  }

  export type CommentLikeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    commentId: string | null
    memberId: string | null
  }

  export type CommentLikeCountAggregateOutputType = {
    id: number
    createdAt: number
    commentId: number
    memberId: number
    _all: number
  }


  export type CommentLikeMinAggregateInputType = {
    id?: true
    createdAt?: true
    commentId?: true
    memberId?: true
  }

  export type CommentLikeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    commentId?: true
    memberId?: true
  }

  export type CommentLikeCountAggregateInputType = {
    id?: true
    createdAt?: true
    commentId?: true
    memberId?: true
    _all?: true
  }

  export type CommentLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentLike to aggregate.
     */
    where?: CommentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentLikes to fetch.
     */
    orderBy?: CommentLikeOrderByWithRelationInput | CommentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentLikes
    **/
    _count?: true | CommentLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentLikeMaxAggregateInputType
  }

  export type GetCommentLikeAggregateType<T extends CommentLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentLike[P]>
      : GetScalarType<T[P], AggregateCommentLike[P]>
  }




  export type CommentLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentLikeWhereInput
    orderBy?: CommentLikeOrderByWithAggregationInput | CommentLikeOrderByWithAggregationInput[]
    by: CommentLikeScalarFieldEnum[] | CommentLikeScalarFieldEnum
    having?: CommentLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentLikeCountAggregateInputType | true
    _min?: CommentLikeMinAggregateInputType
    _max?: CommentLikeMaxAggregateInputType
  }

  export type CommentLikeGroupByOutputType = {
    id: string
    createdAt: Date
    commentId: string
    memberId: string
    _count: CommentLikeCountAggregateOutputType | null
    _min: CommentLikeMinAggregateOutputType | null
    _max: CommentLikeMaxAggregateOutputType | null
  }

  type GetCommentLikeGroupByPayload<T extends CommentLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentLikeGroupByOutputType[P]>
            : GetScalarType<T[P], CommentLikeGroupByOutputType[P]>
        }
      >
    >


  export type CommentLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    commentId?: boolean
    memberId?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentLike"]>

  export type CommentLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    commentId?: boolean
    memberId?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentLike"]>

  export type CommentLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    commentId?: boolean
    memberId?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentLike"]>

  export type CommentLikeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    commentId?: boolean
    memberId?: boolean
  }

  export type CommentLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "commentId" | "memberId", ExtArgs["result"]["commentLike"]>
  export type CommentLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type CommentLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type CommentLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $CommentLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentLike"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      commentId: string
      memberId: string
    }, ExtArgs["result"]["commentLike"]>
    composites: {}
  }

  type CommentLikeGetPayload<S extends boolean | null | undefined | CommentLikeDefaultArgs> = $Result.GetResult<Prisma.$CommentLikePayload, S>

  type CommentLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentLikeCountAggregateInputType | true
    }

  export interface CommentLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentLike'], meta: { name: 'CommentLike' } }
    /**
     * Find zero or one CommentLike that matches the filter.
     * @param {CommentLikeFindUniqueArgs} args - Arguments to find a CommentLike
     * @example
     * // Get one CommentLike
     * const commentLike = await prisma.commentLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentLikeFindUniqueArgs>(args: SelectSubset<T, CommentLikeFindUniqueArgs<ExtArgs>>): Prisma__CommentLikeClient<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentLikeFindUniqueOrThrowArgs} args - Arguments to find a CommentLike
     * @example
     * // Get one CommentLike
     * const commentLike = await prisma.commentLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentLikeClient<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikeFindFirstArgs} args - Arguments to find a CommentLike
     * @example
     * // Get one CommentLike
     * const commentLike = await prisma.commentLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentLikeFindFirstArgs>(args?: SelectSubset<T, CommentLikeFindFirstArgs<ExtArgs>>): Prisma__CommentLikeClient<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikeFindFirstOrThrowArgs} args - Arguments to find a CommentLike
     * @example
     * // Get one CommentLike
     * const commentLike = await prisma.commentLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentLikeClient<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentLikes
     * const commentLikes = await prisma.commentLike.findMany()
     * 
     * // Get first 10 CommentLikes
     * const commentLikes = await prisma.commentLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentLikeWithIdOnly = await prisma.commentLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentLikeFindManyArgs>(args?: SelectSubset<T, CommentLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentLike.
     * @param {CommentLikeCreateArgs} args - Arguments to create a CommentLike.
     * @example
     * // Create one CommentLike
     * const CommentLike = await prisma.commentLike.create({
     *   data: {
     *     // ... data to create a CommentLike
     *   }
     * })
     * 
     */
    create<T extends CommentLikeCreateArgs>(args: SelectSubset<T, CommentLikeCreateArgs<ExtArgs>>): Prisma__CommentLikeClient<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentLikes.
     * @param {CommentLikeCreateManyArgs} args - Arguments to create many CommentLikes.
     * @example
     * // Create many CommentLikes
     * const commentLike = await prisma.commentLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentLikeCreateManyArgs>(args?: SelectSubset<T, CommentLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentLikes and returns the data saved in the database.
     * @param {CommentLikeCreateManyAndReturnArgs} args - Arguments to create many CommentLikes.
     * @example
     * // Create many CommentLikes
     * const commentLike = await prisma.commentLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentLikes and only return the `id`
     * const commentLikeWithIdOnly = await prisma.commentLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentLike.
     * @param {CommentLikeDeleteArgs} args - Arguments to delete one CommentLike.
     * @example
     * // Delete one CommentLike
     * const CommentLike = await prisma.commentLike.delete({
     *   where: {
     *     // ... filter to delete one CommentLike
     *   }
     * })
     * 
     */
    delete<T extends CommentLikeDeleteArgs>(args: SelectSubset<T, CommentLikeDeleteArgs<ExtArgs>>): Prisma__CommentLikeClient<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentLike.
     * @param {CommentLikeUpdateArgs} args - Arguments to update one CommentLike.
     * @example
     * // Update one CommentLike
     * const commentLike = await prisma.commentLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentLikeUpdateArgs>(args: SelectSubset<T, CommentLikeUpdateArgs<ExtArgs>>): Prisma__CommentLikeClient<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentLikes.
     * @param {CommentLikeDeleteManyArgs} args - Arguments to filter CommentLikes to delete.
     * @example
     * // Delete a few CommentLikes
     * const { count } = await prisma.commentLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentLikeDeleteManyArgs>(args?: SelectSubset<T, CommentLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentLikes
     * const commentLike = await prisma.commentLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentLikeUpdateManyArgs>(args: SelectSubset<T, CommentLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentLikes and returns the data updated in the database.
     * @param {CommentLikeUpdateManyAndReturnArgs} args - Arguments to update many CommentLikes.
     * @example
     * // Update many CommentLikes
     * const commentLike = await prisma.commentLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentLikes and only return the `id`
     * const commentLikeWithIdOnly = await prisma.commentLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentLike.
     * @param {CommentLikeUpsertArgs} args - Arguments to update or create a CommentLike.
     * @example
     * // Update or create a CommentLike
     * const commentLike = await prisma.commentLike.upsert({
     *   create: {
     *     // ... data to create a CommentLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentLike we want to update
     *   }
     * })
     */
    upsert<T extends CommentLikeUpsertArgs>(args: SelectSubset<T, CommentLikeUpsertArgs<ExtArgs>>): Prisma__CommentLikeClient<$Result.GetResult<Prisma.$CommentLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikeCountArgs} args - Arguments to filter CommentLikes to count.
     * @example
     * // Count the number of CommentLikes
     * const count = await prisma.commentLike.count({
     *   where: {
     *     // ... the filter for the CommentLikes we want to count
     *   }
     * })
    **/
    count<T extends CommentLikeCountArgs>(
      args?: Subset<T, CommentLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentLikeAggregateArgs>(args: Subset<T, CommentLikeAggregateArgs>): Prisma.PrismaPromise<GetCommentLikeAggregateType<T>>

    /**
     * Group by CommentLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentLikeGroupByArgs['orderBy'] }
        : { orderBy?: CommentLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentLike model
   */
  readonly fields: CommentLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentLike model
   */
  interface CommentLikeFieldRefs {
    readonly id: FieldRef<"CommentLike", 'String'>
    readonly createdAt: FieldRef<"CommentLike", 'DateTime'>
    readonly commentId: FieldRef<"CommentLike", 'String'>
    readonly memberId: FieldRef<"CommentLike", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CommentLike findUnique
   */
  export type CommentLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which CommentLike to fetch.
     */
    where: CommentLikeWhereUniqueInput
  }

  /**
   * CommentLike findUniqueOrThrow
   */
  export type CommentLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which CommentLike to fetch.
     */
    where: CommentLikeWhereUniqueInput
  }

  /**
   * CommentLike findFirst
   */
  export type CommentLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which CommentLike to fetch.
     */
    where?: CommentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentLikes to fetch.
     */
    orderBy?: CommentLikeOrderByWithRelationInput | CommentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentLikes.
     */
    cursor?: CommentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentLikes.
     */
    distinct?: CommentLikeScalarFieldEnum | CommentLikeScalarFieldEnum[]
  }

  /**
   * CommentLike findFirstOrThrow
   */
  export type CommentLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which CommentLike to fetch.
     */
    where?: CommentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentLikes to fetch.
     */
    orderBy?: CommentLikeOrderByWithRelationInput | CommentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentLikes.
     */
    cursor?: CommentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentLikes.
     */
    distinct?: CommentLikeScalarFieldEnum | CommentLikeScalarFieldEnum[]
  }

  /**
   * CommentLike findMany
   */
  export type CommentLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * Filter, which CommentLikes to fetch.
     */
    where?: CommentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentLikes to fetch.
     */
    orderBy?: CommentLikeOrderByWithRelationInput | CommentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentLikes.
     */
    cursor?: CommentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentLikes.
     */
    skip?: number
    distinct?: CommentLikeScalarFieldEnum | CommentLikeScalarFieldEnum[]
  }

  /**
   * CommentLike create
   */
  export type CommentLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentLike.
     */
    data: XOR<CommentLikeCreateInput, CommentLikeUncheckedCreateInput>
  }

  /**
   * CommentLike createMany
   */
  export type CommentLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentLikes.
     */
    data: CommentLikeCreateManyInput | CommentLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentLike createManyAndReturn
   */
  export type CommentLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * The data used to create many CommentLikes.
     */
    data: CommentLikeCreateManyInput | CommentLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentLike update
   */
  export type CommentLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentLike.
     */
    data: XOR<CommentLikeUpdateInput, CommentLikeUncheckedUpdateInput>
    /**
     * Choose, which CommentLike to update.
     */
    where: CommentLikeWhereUniqueInput
  }

  /**
   * CommentLike updateMany
   */
  export type CommentLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentLikes.
     */
    data: XOR<CommentLikeUpdateManyMutationInput, CommentLikeUncheckedUpdateManyInput>
    /**
     * Filter which CommentLikes to update
     */
    where?: CommentLikeWhereInput
    /**
     * Limit how many CommentLikes to update.
     */
    limit?: number
  }

  /**
   * CommentLike updateManyAndReturn
   */
  export type CommentLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * The data used to update CommentLikes.
     */
    data: XOR<CommentLikeUpdateManyMutationInput, CommentLikeUncheckedUpdateManyInput>
    /**
     * Filter which CommentLikes to update
     */
    where?: CommentLikeWhereInput
    /**
     * Limit how many CommentLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentLike upsert
   */
  export type CommentLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentLike to update in case it exists.
     */
    where: CommentLikeWhereUniqueInput
    /**
     * In case the CommentLike found by the `where` argument doesn't exist, create a new CommentLike with this data.
     */
    create: XOR<CommentLikeCreateInput, CommentLikeUncheckedCreateInput>
    /**
     * In case the CommentLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentLikeUpdateInput, CommentLikeUncheckedUpdateInput>
  }

  /**
   * CommentLike delete
   */
  export type CommentLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
    /**
     * Filter which CommentLike to delete.
     */
    where: CommentLikeWhereUniqueInput
  }

  /**
   * CommentLike deleteMany
   */
  export type CommentLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentLikes to delete
     */
    where?: CommentLikeWhereInput
    /**
     * Limit how many CommentLikes to delete.
     */
    limit?: number
  }

  /**
   * CommentLike without action
   */
  export type CommentLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentLike
     */
    select?: CommentLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentLike
     */
    omit?: CommentLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentLikeInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    memberId: string | null
    relatedPostId: string | null
    relatedCommentId: string | null
    relatedMemberId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    memberId: string | null
    relatedPostId: string | null
    relatedCommentId: string | null
    relatedMemberId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    message: number
    isRead: number
    createdAt: number
    memberId: number
    relatedPostId: number
    relatedCommentId: number
    relatedMemberId: number
    metadata: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    memberId?: true
    relatedPostId?: true
    relatedCommentId?: true
    relatedMemberId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    memberId?: true
    relatedPostId?: true
    relatedCommentId?: true
    relatedMemberId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    memberId?: true
    relatedPostId?: true
    relatedCommentId?: true
    relatedMemberId?: true
    metadata?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    message: string
    isRead: boolean
    createdAt: Date
    memberId: string
    relatedPostId: string | null
    relatedCommentId: string | null
    relatedMemberId: string | null
    metadata: JsonValue | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    memberId?: boolean
    relatedPostId?: boolean
    relatedCommentId?: boolean
    relatedMemberId?: boolean
    metadata?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    relatedMember?: boolean | Notification$relatedMemberArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    memberId?: boolean
    relatedPostId?: boolean
    relatedCommentId?: boolean
    relatedMemberId?: boolean
    metadata?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    relatedMember?: boolean | Notification$relatedMemberArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    memberId?: boolean
    relatedPostId?: boolean
    relatedCommentId?: boolean
    relatedMemberId?: boolean
    metadata?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    relatedMember?: boolean | Notification$relatedMemberArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    memberId?: boolean
    relatedPostId?: boolean
    relatedCommentId?: boolean
    relatedMemberId?: boolean
    metadata?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "message" | "isRead" | "createdAt" | "memberId" | "relatedPostId" | "relatedCommentId" | "relatedMemberId" | "metadata", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    relatedMember?: boolean | Notification$relatedMemberArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    relatedMember?: boolean | Notification$relatedMemberArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    relatedMember?: boolean | Notification$relatedMemberArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      relatedMember: Prisma.$MemberPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      message: string
      isRead: boolean
      createdAt: Date
      memberId: string
      relatedPostId: string | null
      relatedCommentId: string | null
      relatedMemberId: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    relatedMember<T extends Notification$relatedMemberArgs<ExtArgs> = {}>(args?: Subset<T, Notification$relatedMemberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly memberId: FieldRef<"Notification", 'String'>
    readonly relatedPostId: FieldRef<"Notification", 'String'>
    readonly relatedCommentId: FieldRef<"Notification", 'String'>
    readonly relatedMemberId: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.relatedMember
   */
  export type Notification$relatedMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model FamilyMemberPermission
   */

  export type AggregateFamilyMemberPermission = {
    _count: FamilyMemberPermissionCountAggregateOutputType | null
    _min: FamilyMemberPermissionMinAggregateOutputType | null
    _max: FamilyMemberPermissionMaxAggregateOutputType | null
  }

  export type FamilyMemberPermissionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    familyMemberId: string | null
    permission: string | null
    grantedBy: string | null
    grantedAt: Date | null
  }

  export type FamilyMemberPermissionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    familyMemberId: string | null
    permission: string | null
    grantedBy: string | null
    grantedAt: Date | null
  }

  export type FamilyMemberPermissionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    familyMemberId: number
    permission: number
    grantedBy: number
    grantedAt: number
    _all: number
  }


  export type FamilyMemberPermissionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    familyMemberId?: true
    permission?: true
    grantedBy?: true
    grantedAt?: true
  }

  export type FamilyMemberPermissionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    familyMemberId?: true
    permission?: true
    grantedBy?: true
    grantedAt?: true
  }

  export type FamilyMemberPermissionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    familyMemberId?: true
    permission?: true
    grantedBy?: true
    grantedAt?: true
    _all?: true
  }

  export type FamilyMemberPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMemberPermission to aggregate.
     */
    where?: FamilyMemberPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMemberPermissions to fetch.
     */
    orderBy?: FamilyMemberPermissionOrderByWithRelationInput | FamilyMemberPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyMemberPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMemberPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMemberPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyMemberPermissions
    **/
    _count?: true | FamilyMemberPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyMemberPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyMemberPermissionMaxAggregateInputType
  }

  export type GetFamilyMemberPermissionAggregateType<T extends FamilyMemberPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyMemberPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyMemberPermission[P]>
      : GetScalarType<T[P], AggregateFamilyMemberPermission[P]>
  }




  export type FamilyMemberPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberPermissionWhereInput
    orderBy?: FamilyMemberPermissionOrderByWithAggregationInput | FamilyMemberPermissionOrderByWithAggregationInput[]
    by: FamilyMemberPermissionScalarFieldEnum[] | FamilyMemberPermissionScalarFieldEnum
    having?: FamilyMemberPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyMemberPermissionCountAggregateInputType | true
    _min?: FamilyMemberPermissionMinAggregateInputType
    _max?: FamilyMemberPermissionMaxAggregateInputType
  }

  export type FamilyMemberPermissionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    familyMemberId: string
    permission: string
    grantedBy: string
    grantedAt: Date
    _count: FamilyMemberPermissionCountAggregateOutputType | null
    _min: FamilyMemberPermissionMinAggregateOutputType | null
    _max: FamilyMemberPermissionMaxAggregateOutputType | null
  }

  type GetFamilyMemberPermissionGroupByPayload<T extends FamilyMemberPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyMemberPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyMemberPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyMemberPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyMemberPermissionGroupByOutputType[P]>
        }
      >
    >


  export type FamilyMemberPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    familyMemberId?: boolean
    permission?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    familyMember?: boolean | FamilyMembershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMemberPermission"]>

  export type FamilyMemberPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    familyMemberId?: boolean
    permission?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    familyMember?: boolean | FamilyMembershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMemberPermission"]>

  export type FamilyMemberPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    familyMemberId?: boolean
    permission?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
    familyMember?: boolean | FamilyMembershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMemberPermission"]>

  export type FamilyMemberPermissionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    familyMemberId?: boolean
    permission?: boolean
    grantedBy?: boolean
    grantedAt?: boolean
  }

  export type FamilyMemberPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "familyMemberId" | "permission" | "grantedBy" | "grantedAt", ExtArgs["result"]["familyMemberPermission"]>
  export type FamilyMemberPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember?: boolean | FamilyMembershipDefaultArgs<ExtArgs>
  }
  export type FamilyMemberPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember?: boolean | FamilyMembershipDefaultArgs<ExtArgs>
  }
  export type FamilyMemberPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember?: boolean | FamilyMembershipDefaultArgs<ExtArgs>
  }

  export type $FamilyMemberPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyMemberPermission"
    objects: {
      familyMember: Prisma.$FamilyMembershipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      familyMemberId: string
      permission: string
      grantedBy: string
      grantedAt: Date
    }, ExtArgs["result"]["familyMemberPermission"]>
    composites: {}
  }

  type FamilyMemberPermissionGetPayload<S extends boolean | null | undefined | FamilyMemberPermissionDefaultArgs> = $Result.GetResult<Prisma.$FamilyMemberPermissionPayload, S>

  type FamilyMemberPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyMemberPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyMemberPermissionCountAggregateInputType | true
    }

  export interface FamilyMemberPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyMemberPermission'], meta: { name: 'FamilyMemberPermission' } }
    /**
     * Find zero or one FamilyMemberPermission that matches the filter.
     * @param {FamilyMemberPermissionFindUniqueArgs} args - Arguments to find a FamilyMemberPermission
     * @example
     * // Get one FamilyMemberPermission
     * const familyMemberPermission = await prisma.familyMemberPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyMemberPermissionFindUniqueArgs>(args: SelectSubset<T, FamilyMemberPermissionFindUniqueArgs<ExtArgs>>): Prisma__FamilyMemberPermissionClient<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyMemberPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyMemberPermissionFindUniqueOrThrowArgs} args - Arguments to find a FamilyMemberPermission
     * @example
     * // Get one FamilyMemberPermission
     * const familyMemberPermission = await prisma.familyMemberPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyMemberPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyMemberPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberPermissionClient<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMemberPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberPermissionFindFirstArgs} args - Arguments to find a FamilyMemberPermission
     * @example
     * // Get one FamilyMemberPermission
     * const familyMemberPermission = await prisma.familyMemberPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyMemberPermissionFindFirstArgs>(args?: SelectSubset<T, FamilyMemberPermissionFindFirstArgs<ExtArgs>>): Prisma__FamilyMemberPermissionClient<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMemberPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberPermissionFindFirstOrThrowArgs} args - Arguments to find a FamilyMemberPermission
     * @example
     * // Get one FamilyMemberPermission
     * const familyMemberPermission = await prisma.familyMemberPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyMemberPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyMemberPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberPermissionClient<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyMemberPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyMemberPermissions
     * const familyMemberPermissions = await prisma.familyMemberPermission.findMany()
     * 
     * // Get first 10 FamilyMemberPermissions
     * const familyMemberPermissions = await prisma.familyMemberPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyMemberPermissionWithIdOnly = await prisma.familyMemberPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyMemberPermissionFindManyArgs>(args?: SelectSubset<T, FamilyMemberPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyMemberPermission.
     * @param {FamilyMemberPermissionCreateArgs} args - Arguments to create a FamilyMemberPermission.
     * @example
     * // Create one FamilyMemberPermission
     * const FamilyMemberPermission = await prisma.familyMemberPermission.create({
     *   data: {
     *     // ... data to create a FamilyMemberPermission
     *   }
     * })
     * 
     */
    create<T extends FamilyMemberPermissionCreateArgs>(args: SelectSubset<T, FamilyMemberPermissionCreateArgs<ExtArgs>>): Prisma__FamilyMemberPermissionClient<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyMemberPermissions.
     * @param {FamilyMemberPermissionCreateManyArgs} args - Arguments to create many FamilyMemberPermissions.
     * @example
     * // Create many FamilyMemberPermissions
     * const familyMemberPermission = await prisma.familyMemberPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyMemberPermissionCreateManyArgs>(args?: SelectSubset<T, FamilyMemberPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FamilyMemberPermissions and returns the data saved in the database.
     * @param {FamilyMemberPermissionCreateManyAndReturnArgs} args - Arguments to create many FamilyMemberPermissions.
     * @example
     * // Create many FamilyMemberPermissions
     * const familyMemberPermission = await prisma.familyMemberPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FamilyMemberPermissions and only return the `id`
     * const familyMemberPermissionWithIdOnly = await prisma.familyMemberPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FamilyMemberPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, FamilyMemberPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FamilyMemberPermission.
     * @param {FamilyMemberPermissionDeleteArgs} args - Arguments to delete one FamilyMemberPermission.
     * @example
     * // Delete one FamilyMemberPermission
     * const FamilyMemberPermission = await prisma.familyMemberPermission.delete({
     *   where: {
     *     // ... filter to delete one FamilyMemberPermission
     *   }
     * })
     * 
     */
    delete<T extends FamilyMemberPermissionDeleteArgs>(args: SelectSubset<T, FamilyMemberPermissionDeleteArgs<ExtArgs>>): Prisma__FamilyMemberPermissionClient<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyMemberPermission.
     * @param {FamilyMemberPermissionUpdateArgs} args - Arguments to update one FamilyMemberPermission.
     * @example
     * // Update one FamilyMemberPermission
     * const familyMemberPermission = await prisma.familyMemberPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyMemberPermissionUpdateArgs>(args: SelectSubset<T, FamilyMemberPermissionUpdateArgs<ExtArgs>>): Prisma__FamilyMemberPermissionClient<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyMemberPermissions.
     * @param {FamilyMemberPermissionDeleteManyArgs} args - Arguments to filter FamilyMemberPermissions to delete.
     * @example
     * // Delete a few FamilyMemberPermissions
     * const { count } = await prisma.familyMemberPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyMemberPermissionDeleteManyArgs>(args?: SelectSubset<T, FamilyMemberPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMemberPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyMemberPermissions
     * const familyMemberPermission = await prisma.familyMemberPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyMemberPermissionUpdateManyArgs>(args: SelectSubset<T, FamilyMemberPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMemberPermissions and returns the data updated in the database.
     * @param {FamilyMemberPermissionUpdateManyAndReturnArgs} args - Arguments to update many FamilyMemberPermissions.
     * @example
     * // Update many FamilyMemberPermissions
     * const familyMemberPermission = await prisma.familyMemberPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FamilyMemberPermissions and only return the `id`
     * const familyMemberPermissionWithIdOnly = await prisma.familyMemberPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FamilyMemberPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, FamilyMemberPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FamilyMemberPermission.
     * @param {FamilyMemberPermissionUpsertArgs} args - Arguments to update or create a FamilyMemberPermission.
     * @example
     * // Update or create a FamilyMemberPermission
     * const familyMemberPermission = await prisma.familyMemberPermission.upsert({
     *   create: {
     *     // ... data to create a FamilyMemberPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyMemberPermission we want to update
     *   }
     * })
     */
    upsert<T extends FamilyMemberPermissionUpsertArgs>(args: SelectSubset<T, FamilyMemberPermissionUpsertArgs<ExtArgs>>): Prisma__FamilyMemberPermissionClient<$Result.GetResult<Prisma.$FamilyMemberPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyMemberPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberPermissionCountArgs} args - Arguments to filter FamilyMemberPermissions to count.
     * @example
     * // Count the number of FamilyMemberPermissions
     * const count = await prisma.familyMemberPermission.count({
     *   where: {
     *     // ... the filter for the FamilyMemberPermissions we want to count
     *   }
     * })
    **/
    count<T extends FamilyMemberPermissionCountArgs>(
      args?: Subset<T, FamilyMemberPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyMemberPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyMemberPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyMemberPermissionAggregateArgs>(args: Subset<T, FamilyMemberPermissionAggregateArgs>): Prisma.PrismaPromise<GetFamilyMemberPermissionAggregateType<T>>

    /**
     * Group by FamilyMemberPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyMemberPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyMemberPermissionGroupByArgs['orderBy'] }
        : { orderBy?: FamilyMemberPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyMemberPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyMemberPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyMemberPermission model
   */
  readonly fields: FamilyMemberPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyMemberPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyMemberPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyMember<T extends FamilyMembershipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMembershipDefaultArgs<ExtArgs>>): Prisma__FamilyMembershipClient<$Result.GetResult<Prisma.$FamilyMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyMemberPermission model
   */
  interface FamilyMemberPermissionFieldRefs {
    readonly id: FieldRef<"FamilyMemberPermission", 'String'>
    readonly createdAt: FieldRef<"FamilyMemberPermission", 'DateTime'>
    readonly updatedAt: FieldRef<"FamilyMemberPermission", 'DateTime'>
    readonly familyMemberId: FieldRef<"FamilyMemberPermission", 'String'>
    readonly permission: FieldRef<"FamilyMemberPermission", 'String'>
    readonly grantedBy: FieldRef<"FamilyMemberPermission", 'String'>
    readonly grantedAt: FieldRef<"FamilyMemberPermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyMemberPermission findUnique
   */
  export type FamilyMemberPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMemberPermission to fetch.
     */
    where: FamilyMemberPermissionWhereUniqueInput
  }

  /**
   * FamilyMemberPermission findUniqueOrThrow
   */
  export type FamilyMemberPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMemberPermission to fetch.
     */
    where: FamilyMemberPermissionWhereUniqueInput
  }

  /**
   * FamilyMemberPermission findFirst
   */
  export type FamilyMemberPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMemberPermission to fetch.
     */
    where?: FamilyMemberPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMemberPermissions to fetch.
     */
    orderBy?: FamilyMemberPermissionOrderByWithRelationInput | FamilyMemberPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMemberPermissions.
     */
    cursor?: FamilyMemberPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMemberPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMemberPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMemberPermissions.
     */
    distinct?: FamilyMemberPermissionScalarFieldEnum | FamilyMemberPermissionScalarFieldEnum[]
  }

  /**
   * FamilyMemberPermission findFirstOrThrow
   */
  export type FamilyMemberPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMemberPermission to fetch.
     */
    where?: FamilyMemberPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMemberPermissions to fetch.
     */
    orderBy?: FamilyMemberPermissionOrderByWithRelationInput | FamilyMemberPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMemberPermissions.
     */
    cursor?: FamilyMemberPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMemberPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMemberPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMemberPermissions.
     */
    distinct?: FamilyMemberPermissionScalarFieldEnum | FamilyMemberPermissionScalarFieldEnum[]
  }

  /**
   * FamilyMemberPermission findMany
   */
  export type FamilyMemberPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMemberPermissions to fetch.
     */
    where?: FamilyMemberPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMemberPermissions to fetch.
     */
    orderBy?: FamilyMemberPermissionOrderByWithRelationInput | FamilyMemberPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyMemberPermissions.
     */
    cursor?: FamilyMemberPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMemberPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMemberPermissions.
     */
    skip?: number
    distinct?: FamilyMemberPermissionScalarFieldEnum | FamilyMemberPermissionScalarFieldEnum[]
  }

  /**
   * FamilyMemberPermission create
   */
  export type FamilyMemberPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyMemberPermission.
     */
    data: XOR<FamilyMemberPermissionCreateInput, FamilyMemberPermissionUncheckedCreateInput>
  }

  /**
   * FamilyMemberPermission createMany
   */
  export type FamilyMemberPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyMemberPermissions.
     */
    data: FamilyMemberPermissionCreateManyInput | FamilyMemberPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyMemberPermission createManyAndReturn
   */
  export type FamilyMemberPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many FamilyMemberPermissions.
     */
    data: FamilyMemberPermissionCreateManyInput | FamilyMemberPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FamilyMemberPermission update
   */
  export type FamilyMemberPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyMemberPermission.
     */
    data: XOR<FamilyMemberPermissionUpdateInput, FamilyMemberPermissionUncheckedUpdateInput>
    /**
     * Choose, which FamilyMemberPermission to update.
     */
    where: FamilyMemberPermissionWhereUniqueInput
  }

  /**
   * FamilyMemberPermission updateMany
   */
  export type FamilyMemberPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyMemberPermissions.
     */
    data: XOR<FamilyMemberPermissionUpdateManyMutationInput, FamilyMemberPermissionUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMemberPermissions to update
     */
    where?: FamilyMemberPermissionWhereInput
    /**
     * Limit how many FamilyMemberPermissions to update.
     */
    limit?: number
  }

  /**
   * FamilyMemberPermission updateManyAndReturn
   */
  export type FamilyMemberPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * The data used to update FamilyMemberPermissions.
     */
    data: XOR<FamilyMemberPermissionUpdateManyMutationInput, FamilyMemberPermissionUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMemberPermissions to update
     */
    where?: FamilyMemberPermissionWhereInput
    /**
     * Limit how many FamilyMemberPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FamilyMemberPermission upsert
   */
  export type FamilyMemberPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyMemberPermission to update in case it exists.
     */
    where: FamilyMemberPermissionWhereUniqueInput
    /**
     * In case the FamilyMemberPermission found by the `where` argument doesn't exist, create a new FamilyMemberPermission with this data.
     */
    create: XOR<FamilyMemberPermissionCreateInput, FamilyMemberPermissionUncheckedCreateInput>
    /**
     * In case the FamilyMemberPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyMemberPermissionUpdateInput, FamilyMemberPermissionUncheckedUpdateInput>
  }

  /**
   * FamilyMemberPermission delete
   */
  export type FamilyMemberPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
    /**
     * Filter which FamilyMemberPermission to delete.
     */
    where: FamilyMemberPermissionWhereUniqueInput
  }

  /**
   * FamilyMemberPermission deleteMany
   */
  export type FamilyMemberPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMemberPermissions to delete
     */
    where?: FamilyMemberPermissionWhereInput
    /**
     * Limit how many FamilyMemberPermissions to delete.
     */
    limit?: number
  }

  /**
   * FamilyMemberPermission without action
   */
  export type FamilyMemberPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberPermission
     */
    select?: FamilyMemberPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMemberPermission
     */
    omit?: FamilyMemberPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberPermissionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    password: 'password',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    memberId: 'memberId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    gender: 'gender',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    personalInfo: 'personalInfo',
    color: 'color',
    parentColors: 'parentColors'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const FamilyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isSubFamily: 'isSubFamily',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId',
    headOfFamilyId: 'headOfFamilyId',
    parentFamilyId: 'parentFamilyId'
  };

  export type FamilyScalarFieldEnum = (typeof FamilyScalarFieldEnum)[keyof typeof FamilyScalarFieldEnum]


  export const FamilyMembershipScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    memberId: 'memberId',
    familyId: 'familyId',
    role: 'role',
    type: 'type',
    autoEnrolled: 'autoEnrolled',
    manuallyEdited: 'manuallyEdited',
    isActive: 'isActive',
    joinDate: 'joinDate'
  };

  export type FamilyMembershipScalarFieldEnum = (typeof FamilyMembershipScalarFieldEnum)[keyof typeof FamilyMembershipScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    status: 'status',
    usedAt: 'usedAt',
    acceptedBy: 'acceptedBy',
    familyId: 'familyId',
    inviterUserId: 'inviterUserId',
    inviterMemberId: 'inviterMemberId',
    memberStub: 'memberStub'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uploadedBy: 'uploadedBy'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const PostFileAttachmentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    fileId: 'fileId',
    order: 'order'
  };

  export type PostFileAttachmentScalarFieldEnum = (typeof PostFileAttachmentScalarFieldEnum)[keyof typeof PostFileAttachmentScalarFieldEnum]


  export const CommentFileAttachmentScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    fileId: 'fileId'
  };

  export type CommentFileAttachmentScalarFieldEnum = (typeof CommentFileAttachmentScalarFieldEnum)[keyof typeof CommentFileAttachmentScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    content: 'content',
    imageUrls: 'imageUrls',
    videoUrl: 'videoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    visibility: 'visibility',
    authorId: 'authorId',
    familyId: 'familyId',
    likesCount: 'likesCount',
    editHistory: 'editHistory'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postId: 'postId',
    authorId: 'authorId',
    parentCommentId: 'parentCommentId',
    likesCount: 'likesCount'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PostLikeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    postId: 'postId',
    memberId: 'memberId'
  };

  export type PostLikeScalarFieldEnum = (typeof PostLikeScalarFieldEnum)[keyof typeof PostLikeScalarFieldEnum]


  export const CommentLikeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    commentId: 'commentId',
    memberId: 'memberId'
  };

  export type CommentLikeScalarFieldEnum = (typeof CommentLikeScalarFieldEnum)[keyof typeof CommentLikeScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    memberId: 'memberId',
    relatedPostId: 'relatedPostId',
    relatedCommentId: 'relatedCommentId',
    relatedMemberId: 'relatedMemberId',
    metadata: 'metadata'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const FamilyMemberPermissionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    familyMemberId: 'familyMemberId',
    permission: 'permission',
    grantedBy: 'grantedBy',
    grantedAt: 'grantedAt'
  };

  export type FamilyMemberPermissionScalarFieldEnum = (typeof FamilyMemberPermissionScalarFieldEnum)[keyof typeof FamilyMemberPermissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'MemberStatus'
   */
  export type EnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus'>
    


  /**
   * Reference to a field of type 'MemberStatus[]'
   */
  export type ListEnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'FamilyRole'
   */
  export type EnumFamilyRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FamilyRole'>
    


  /**
   * Reference to a field of type 'FamilyRole[]'
   */
  export type ListEnumFamilyRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FamilyRole[]'>
    


  /**
   * Reference to a field of type 'MembershipType'
   */
  export type EnumMembershipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembershipType'>
    


  /**
   * Reference to a field of type 'MembershipType[]'
   */
  export type ListEnumMembershipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembershipType[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'PostVisibility'
   */
  export type EnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility'>
    


  /**
   * Reference to a field of type 'PostVisibility[]'
   */
  export type ListEnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    memberId?: StringNullableFilter<"User"> | string | null
    member?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    sentInvitations?: InvitationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
    sentInvitations?: InvitationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    memberId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    member?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    sentInvitations?: InvitationListRelationFilter
  }, "id" | "email" | "phone" | "memberId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    memberId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    gender?: EnumGenderNullableFilter<"Member"> | $Enums.Gender | null
    status?: EnumMemberStatusFilter<"Member"> | $Enums.MemberStatus
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    personalInfo?: JsonNullableFilter<"Member">
    color?: StringNullableFilter<"Member"> | string | null
    parentColors?: StringNullableListFilter<"Member">
    parents?: MemberListRelationFilter
    children?: MemberListRelationFilter
    spouses?: MemberListRelationFilter
    spousesReverse?: MemberListRelationFilter
    familyMemberships?: FamilyMembershipListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sentInvitations?: InvitationListRelationFilter
    createdFamilies?: FamilyListRelationFilter
    headedFamilies?: FamilyListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    postLikes?: PostLikeListRelationFilter
    commentLikes?: CommentLikeListRelationFilter
    notifications?: NotificationListRelationFilter
    triggeredNotifications?: NotificationListRelationFilter
    uploadedFiles?: FileListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalInfo?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentColors?: SortOrder
    parents?: MemberOrderByRelationAggregateInput
    children?: MemberOrderByRelationAggregateInput
    spouses?: MemberOrderByRelationAggregateInput
    spousesReverse?: MemberOrderByRelationAggregateInput
    familyMemberships?: FamilyMembershipOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    sentInvitations?: InvitationOrderByRelationAggregateInput
    createdFamilies?: FamilyOrderByRelationAggregateInput
    headedFamilies?: FamilyOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    postLikes?: PostLikeOrderByRelationAggregateInput
    commentLikes?: CommentLikeOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    triggeredNotifications?: NotificationOrderByRelationAggregateInput
    uploadedFiles?: FileOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    name?: StringFilter<"Member"> | string
    gender?: EnumGenderNullableFilter<"Member"> | $Enums.Gender | null
    status?: EnumMemberStatusFilter<"Member"> | $Enums.MemberStatus
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    personalInfo?: JsonNullableFilter<"Member">
    color?: StringNullableFilter<"Member"> | string | null
    parentColors?: StringNullableListFilter<"Member">
    parents?: MemberListRelationFilter
    children?: MemberListRelationFilter
    spouses?: MemberListRelationFilter
    spousesReverse?: MemberListRelationFilter
    familyMemberships?: FamilyMembershipListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sentInvitations?: InvitationListRelationFilter
    createdFamilies?: FamilyListRelationFilter
    headedFamilies?: FamilyListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    postLikes?: PostLikeListRelationFilter
    commentLikes?: CommentLikeListRelationFilter
    notifications?: NotificationListRelationFilter
    triggeredNotifications?: NotificationListRelationFilter
    uploadedFiles?: FileListRelationFilter
  }, "id">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalInfo?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentColors?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    name?: StringWithAggregatesFilter<"Member"> | string
    gender?: EnumGenderNullableWithAggregatesFilter<"Member"> | $Enums.Gender | null
    status?: EnumMemberStatusWithAggregatesFilter<"Member"> | $Enums.MemberStatus
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    personalInfo?: JsonNullableWithAggregatesFilter<"Member">
    color?: StringNullableWithAggregatesFilter<"Member"> | string | null
    parentColors?: StringNullableListFilter<"Member">
  }

  export type FamilyWhereInput = {
    AND?: FamilyWhereInput | FamilyWhereInput[]
    OR?: FamilyWhereInput[]
    NOT?: FamilyWhereInput | FamilyWhereInput[]
    id?: StringFilter<"Family"> | string
    name?: StringFilter<"Family"> | string
    description?: StringNullableFilter<"Family"> | string | null
    isSubFamily?: BoolFilter<"Family"> | boolean
    deletedAt?: DateTimeNullableFilter<"Family"> | Date | string | null
    createdAt?: DateTimeFilter<"Family"> | Date | string
    updatedAt?: DateTimeFilter<"Family"> | Date | string
    creatorId?: StringFilter<"Family"> | string
    headOfFamilyId?: StringNullableFilter<"Family"> | string | null
    parentFamilyId?: StringNullableFilter<"Family"> | string | null
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    headOfFamily?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    parentFamily?: XOR<FamilyNullableScalarRelationFilter, FamilyWhereInput> | null
    subFamilies?: FamilyListRelationFilter
    memberships?: FamilyMembershipListRelationFilter
    invitations?: InvitationListRelationFilter
  }

  export type FamilyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSubFamily?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    headOfFamilyId?: SortOrderInput | SortOrder
    parentFamilyId?: SortOrderInput | SortOrder
    creator?: MemberOrderByWithRelationInput
    headOfFamily?: MemberOrderByWithRelationInput
    parentFamily?: FamilyOrderByWithRelationInput
    subFamilies?: FamilyOrderByRelationAggregateInput
    memberships?: FamilyMembershipOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
  }

  export type FamilyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FamilyWhereInput | FamilyWhereInput[]
    OR?: FamilyWhereInput[]
    NOT?: FamilyWhereInput | FamilyWhereInput[]
    name?: StringFilter<"Family"> | string
    description?: StringNullableFilter<"Family"> | string | null
    isSubFamily?: BoolFilter<"Family"> | boolean
    deletedAt?: DateTimeNullableFilter<"Family"> | Date | string | null
    createdAt?: DateTimeFilter<"Family"> | Date | string
    updatedAt?: DateTimeFilter<"Family"> | Date | string
    creatorId?: StringFilter<"Family"> | string
    headOfFamilyId?: StringNullableFilter<"Family"> | string | null
    parentFamilyId?: StringNullableFilter<"Family"> | string | null
    creator?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    headOfFamily?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    parentFamily?: XOR<FamilyNullableScalarRelationFilter, FamilyWhereInput> | null
    subFamilies?: FamilyListRelationFilter
    memberships?: FamilyMembershipListRelationFilter
    invitations?: InvitationListRelationFilter
  }, "id">

  export type FamilyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSubFamily?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    headOfFamilyId?: SortOrderInput | SortOrder
    parentFamilyId?: SortOrderInput | SortOrder
    _count?: FamilyCountOrderByAggregateInput
    _max?: FamilyMaxOrderByAggregateInput
    _min?: FamilyMinOrderByAggregateInput
  }

  export type FamilyScalarWhereWithAggregatesInput = {
    AND?: FamilyScalarWhereWithAggregatesInput | FamilyScalarWhereWithAggregatesInput[]
    OR?: FamilyScalarWhereWithAggregatesInput[]
    NOT?: FamilyScalarWhereWithAggregatesInput | FamilyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Family"> | string
    name?: StringWithAggregatesFilter<"Family"> | string
    description?: StringNullableWithAggregatesFilter<"Family"> | string | null
    isSubFamily?: BoolWithAggregatesFilter<"Family"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Family"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Family"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Family"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Family"> | string
    headOfFamilyId?: StringNullableWithAggregatesFilter<"Family"> | string | null
    parentFamilyId?: StringNullableWithAggregatesFilter<"Family"> | string | null
  }

  export type FamilyMembershipWhereInput = {
    AND?: FamilyMembershipWhereInput | FamilyMembershipWhereInput[]
    OR?: FamilyMembershipWhereInput[]
    NOT?: FamilyMembershipWhereInput | FamilyMembershipWhereInput[]
    id?: StringFilter<"FamilyMembership"> | string
    createdAt?: DateTimeFilter<"FamilyMembership"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMembership"> | Date | string
    memberId?: StringFilter<"FamilyMembership"> | string
    familyId?: StringFilter<"FamilyMembership"> | string
    role?: EnumFamilyRoleFilter<"FamilyMembership"> | $Enums.FamilyRole
    type?: EnumMembershipTypeFilter<"FamilyMembership"> | $Enums.MembershipType
    autoEnrolled?: BoolFilter<"FamilyMembership"> | boolean
    manuallyEdited?: BoolFilter<"FamilyMembership"> | boolean
    isActive?: BoolFilter<"FamilyMembership"> | boolean
    joinDate?: DateTimeFilter<"FamilyMembership"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    family?: XOR<FamilyScalarRelationFilter, FamilyWhereInput>
    familyMemberPermissions?: FamilyMemberPermissionListRelationFilter
  }

  export type FamilyMembershipOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrder
    familyId?: SortOrder
    role?: SortOrder
    type?: SortOrder
    autoEnrolled?: SortOrder
    manuallyEdited?: SortOrder
    isActive?: SortOrder
    joinDate?: SortOrder
    member?: MemberOrderByWithRelationInput
    family?: FamilyOrderByWithRelationInput
    familyMemberPermissions?: FamilyMemberPermissionOrderByRelationAggregateInput
  }

  export type FamilyMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId_familyId?: FamilyMembershipMemberIdFamilyIdCompoundUniqueInput
    AND?: FamilyMembershipWhereInput | FamilyMembershipWhereInput[]
    OR?: FamilyMembershipWhereInput[]
    NOT?: FamilyMembershipWhereInput | FamilyMembershipWhereInput[]
    createdAt?: DateTimeFilter<"FamilyMembership"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMembership"> | Date | string
    memberId?: StringFilter<"FamilyMembership"> | string
    familyId?: StringFilter<"FamilyMembership"> | string
    role?: EnumFamilyRoleFilter<"FamilyMembership"> | $Enums.FamilyRole
    type?: EnumMembershipTypeFilter<"FamilyMembership"> | $Enums.MembershipType
    autoEnrolled?: BoolFilter<"FamilyMembership"> | boolean
    manuallyEdited?: BoolFilter<"FamilyMembership"> | boolean
    isActive?: BoolFilter<"FamilyMembership"> | boolean
    joinDate?: DateTimeFilter<"FamilyMembership"> | Date | string
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    family?: XOR<FamilyScalarRelationFilter, FamilyWhereInput>
    familyMemberPermissions?: FamilyMemberPermissionListRelationFilter
  }, "id" | "memberId_familyId">

  export type FamilyMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrder
    familyId?: SortOrder
    role?: SortOrder
    type?: SortOrder
    autoEnrolled?: SortOrder
    manuallyEdited?: SortOrder
    isActive?: SortOrder
    joinDate?: SortOrder
    _count?: FamilyMembershipCountOrderByAggregateInput
    _max?: FamilyMembershipMaxOrderByAggregateInput
    _min?: FamilyMembershipMinOrderByAggregateInput
  }

  export type FamilyMembershipScalarWhereWithAggregatesInput = {
    AND?: FamilyMembershipScalarWhereWithAggregatesInput | FamilyMembershipScalarWhereWithAggregatesInput[]
    OR?: FamilyMembershipScalarWhereWithAggregatesInput[]
    NOT?: FamilyMembershipScalarWhereWithAggregatesInput | FamilyMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyMembership"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FamilyMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FamilyMembership"> | Date | string
    memberId?: StringWithAggregatesFilter<"FamilyMembership"> | string
    familyId?: StringWithAggregatesFilter<"FamilyMembership"> | string
    role?: EnumFamilyRoleWithAggregatesFilter<"FamilyMembership"> | $Enums.FamilyRole
    type?: EnumMembershipTypeWithAggregatesFilter<"FamilyMembership"> | $Enums.MembershipType
    autoEnrolled?: BoolWithAggregatesFilter<"FamilyMembership"> | boolean
    manuallyEdited?: BoolWithAggregatesFilter<"FamilyMembership"> | boolean
    isActive?: BoolWithAggregatesFilter<"FamilyMembership"> | boolean
    joinDate?: DateTimeWithAggregatesFilter<"FamilyMembership"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    code?: StringFilter<"Invitation"> | string
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    usedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    acceptedBy?: StringNullableFilter<"Invitation"> | string | null
    familyId?: StringFilter<"Invitation"> | string
    inviterUserId?: StringNullableFilter<"Invitation"> | string | null
    inviterMemberId?: StringNullableFilter<"Invitation"> | string | null
    memberStub?: JsonNullableFilter<"Invitation">
    family?: XOR<FamilyScalarRelationFilter, FamilyWhereInput>
    inviterUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    inviterMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    acceptedBy?: SortOrderInput | SortOrder
    familyId?: SortOrder
    inviterUserId?: SortOrderInput | SortOrder
    inviterMemberId?: SortOrderInput | SortOrder
    memberStub?: SortOrderInput | SortOrder
    family?: FamilyOrderByWithRelationInput
    inviterUser?: UserOrderByWithRelationInput
    inviterMember?: MemberOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    usedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    acceptedBy?: StringNullableFilter<"Invitation"> | string | null
    familyId?: StringFilter<"Invitation"> | string
    inviterUserId?: StringNullableFilter<"Invitation"> | string | null
    inviterMemberId?: StringNullableFilter<"Invitation"> | string | null
    memberStub?: JsonNullableFilter<"Invitation">
    family?: XOR<FamilyScalarRelationFilter, FamilyWhereInput>
    inviterUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    inviterMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }, "id" | "code">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    acceptedBy?: SortOrderInput | SortOrder
    familyId?: SortOrder
    inviterUserId?: SortOrderInput | SortOrder
    inviterMemberId?: SortOrderInput | SortOrder
    memberStub?: SortOrderInput | SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    code?: StringWithAggregatesFilter<"Invitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    status?: EnumInvitationStatusWithAggregatesFilter<"Invitation"> | $Enums.InvitationStatus
    usedAt?: DateTimeNullableWithAggregatesFilter<"Invitation"> | Date | string | null
    acceptedBy?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    familyId?: StringWithAggregatesFilter<"Invitation"> | string
    inviterUserId?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    inviterMemberId?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    memberStub?: JsonNullableWithAggregatesFilter<"Invitation">
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    url?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    uploadedBy?: StringFilter<"File"> | string
    uploader?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    postAttachments?: PostFileAttachmentListRelationFilter
    commentAttachments?: CommentFileAttachmentListRelationFilter
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedBy?: SortOrder
    uploader?: MemberOrderByWithRelationInput
    postAttachments?: PostFileAttachmentOrderByRelationAggregateInput
    commentAttachments?: CommentFileAttachmentOrderByRelationAggregateInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    url?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    uploadedBy?: StringFilter<"File"> | string
    uploader?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    postAttachments?: PostFileAttachmentListRelationFilter
    commentAttachments?: CommentFileAttachmentListRelationFilter
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedBy?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    filename?: StringWithAggregatesFilter<"File"> | string
    originalName?: StringWithAggregatesFilter<"File"> | string
    mimeType?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    url?: StringWithAggregatesFilter<"File"> | string
    type?: EnumFileTypeWithAggregatesFilter<"File"> | $Enums.FileType
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    uploadedBy?: StringWithAggregatesFilter<"File"> | string
  }

  export type PostFileAttachmentWhereInput = {
    AND?: PostFileAttachmentWhereInput | PostFileAttachmentWhereInput[]
    OR?: PostFileAttachmentWhereInput[]
    NOT?: PostFileAttachmentWhereInput | PostFileAttachmentWhereInput[]
    id?: StringFilter<"PostFileAttachment"> | string
    postId?: StringFilter<"PostFileAttachment"> | string
    fileId?: StringFilter<"PostFileAttachment"> | string
    order?: IntFilter<"PostFileAttachment"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
  }

  export type PostFileAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    fileId?: SortOrder
    order?: SortOrder
    post?: PostOrderByWithRelationInput
    file?: FileOrderByWithRelationInput
  }

  export type PostFileAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_fileId?: PostFileAttachmentPostIdFileIdCompoundUniqueInput
    AND?: PostFileAttachmentWhereInput | PostFileAttachmentWhereInput[]
    OR?: PostFileAttachmentWhereInput[]
    NOT?: PostFileAttachmentWhereInput | PostFileAttachmentWhereInput[]
    postId?: StringFilter<"PostFileAttachment"> | string
    fileId?: StringFilter<"PostFileAttachment"> | string
    order?: IntFilter<"PostFileAttachment"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
  }, "id" | "postId_fileId">

  export type PostFileAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    fileId?: SortOrder
    order?: SortOrder
    _count?: PostFileAttachmentCountOrderByAggregateInput
    _avg?: PostFileAttachmentAvgOrderByAggregateInput
    _max?: PostFileAttachmentMaxOrderByAggregateInput
    _min?: PostFileAttachmentMinOrderByAggregateInput
    _sum?: PostFileAttachmentSumOrderByAggregateInput
  }

  export type PostFileAttachmentScalarWhereWithAggregatesInput = {
    AND?: PostFileAttachmentScalarWhereWithAggregatesInput | PostFileAttachmentScalarWhereWithAggregatesInput[]
    OR?: PostFileAttachmentScalarWhereWithAggregatesInput[]
    NOT?: PostFileAttachmentScalarWhereWithAggregatesInput | PostFileAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostFileAttachment"> | string
    postId?: StringWithAggregatesFilter<"PostFileAttachment"> | string
    fileId?: StringWithAggregatesFilter<"PostFileAttachment"> | string
    order?: IntWithAggregatesFilter<"PostFileAttachment"> | number
  }

  export type CommentFileAttachmentWhereInput = {
    AND?: CommentFileAttachmentWhereInput | CommentFileAttachmentWhereInput[]
    OR?: CommentFileAttachmentWhereInput[]
    NOT?: CommentFileAttachmentWhereInput | CommentFileAttachmentWhereInput[]
    id?: StringFilter<"CommentFileAttachment"> | string
    commentId?: StringFilter<"CommentFileAttachment"> | string
    fileId?: StringFilter<"CommentFileAttachment"> | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
  }

  export type CommentFileAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    fileId?: SortOrder
    comment?: CommentOrderByWithRelationInput
    file?: FileOrderByWithRelationInput
  }

  export type CommentFileAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    commentId_fileId?: CommentFileAttachmentCommentIdFileIdCompoundUniqueInput
    AND?: CommentFileAttachmentWhereInput | CommentFileAttachmentWhereInput[]
    OR?: CommentFileAttachmentWhereInput[]
    NOT?: CommentFileAttachmentWhereInput | CommentFileAttachmentWhereInput[]
    commentId?: StringFilter<"CommentFileAttachment"> | string
    fileId?: StringFilter<"CommentFileAttachment"> | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    file?: XOR<FileScalarRelationFilter, FileWhereInput>
  }, "id" | "commentId_fileId">

  export type CommentFileAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    fileId?: SortOrder
    _count?: CommentFileAttachmentCountOrderByAggregateInput
    _max?: CommentFileAttachmentMaxOrderByAggregateInput
    _min?: CommentFileAttachmentMinOrderByAggregateInput
  }

  export type CommentFileAttachmentScalarWhereWithAggregatesInput = {
    AND?: CommentFileAttachmentScalarWhereWithAggregatesInput | CommentFileAttachmentScalarWhereWithAggregatesInput[]
    OR?: CommentFileAttachmentScalarWhereWithAggregatesInput[]
    NOT?: CommentFileAttachmentScalarWhereWithAggregatesInput | CommentFileAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentFileAttachment"> | string
    commentId?: StringWithAggregatesFilter<"CommentFileAttachment"> | string
    fileId?: StringWithAggregatesFilter<"CommentFileAttachment"> | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    imageUrls?: StringNullableListFilter<"Post">
    videoUrl?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    authorId?: StringFilter<"Post"> | string
    familyId?: StringNullableFilter<"Post"> | string | null
    likesCount?: IntFilter<"Post"> | number
    editHistory?: JsonNullableFilter<"Post">
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    comments?: CommentListRelationFilter
    likes?: PostLikeListRelationFilter
    fileAttachments?: PostFileAttachmentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrls?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    familyId?: SortOrderInput | SortOrder
    likesCount?: SortOrder
    editHistory?: SortOrderInput | SortOrder
    author?: MemberOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: PostLikeOrderByRelationAggregateInput
    fileAttachments?: PostFileAttachmentOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    content?: StringFilter<"Post"> | string
    imageUrls?: StringNullableListFilter<"Post">
    videoUrl?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    authorId?: StringFilter<"Post"> | string
    familyId?: StringNullableFilter<"Post"> | string | null
    likesCount?: IntFilter<"Post"> | number
    editHistory?: JsonNullableFilter<"Post">
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    comments?: CommentListRelationFilter
    likes?: PostLikeListRelationFilter
    fileAttachments?: PostFileAttachmentListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrls?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    familyId?: SortOrderInput | SortOrder
    likesCount?: SortOrder
    editHistory?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    imageUrls?: StringNullableListFilter<"Post">
    videoUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    visibility?: EnumPostVisibilityWithAggregatesFilter<"Post"> | $Enums.PostVisibility
    authorId?: StringWithAggregatesFilter<"Post"> | string
    familyId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    likesCount?: IntWithAggregatesFilter<"Post"> | number
    editHistory?: JsonNullableWithAggregatesFilter<"Post">
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    imageUrl?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
    likesCount?: IntFilter<"Comment"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    parentComment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    likes?: CommentLikeListRelationFilter
    fileAttachments?: CommentFileAttachmentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    likesCount?: SortOrder
    post?: PostOrderByWithRelationInput
    author?: MemberOrderByWithRelationInput
    parentComment?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
    likes?: CommentLikeOrderByRelationAggregateInput
    fileAttachments?: CommentFileAttachmentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    imageUrl?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
    likesCount?: IntFilter<"Comment"> | number
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    parentComment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    likes?: CommentLikeListRelationFilter
    fileAttachments?: CommentFileAttachmentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    likesCount?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    parentCommentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    likesCount?: IntWithAggregatesFilter<"Comment"> | number
  }

  export type PostLikeWhereInput = {
    AND?: PostLikeWhereInput | PostLikeWhereInput[]
    OR?: PostLikeWhereInput[]
    NOT?: PostLikeWhereInput | PostLikeWhereInput[]
    id?: StringFilter<"PostLike"> | string
    createdAt?: DateTimeFilter<"PostLike"> | Date | string
    postId?: StringFilter<"PostLike"> | string
    memberId?: StringFilter<"PostLike"> | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type PostLikeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    postId?: SortOrder
    memberId?: SortOrder
    post?: PostOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type PostLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_memberId?: PostLikePostIdMemberIdCompoundUniqueInput
    AND?: PostLikeWhereInput | PostLikeWhereInput[]
    OR?: PostLikeWhereInput[]
    NOT?: PostLikeWhereInput | PostLikeWhereInput[]
    createdAt?: DateTimeFilter<"PostLike"> | Date | string
    postId?: StringFilter<"PostLike"> | string
    memberId?: StringFilter<"PostLike"> | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "postId_memberId">

  export type PostLikeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    postId?: SortOrder
    memberId?: SortOrder
    _count?: PostLikeCountOrderByAggregateInput
    _max?: PostLikeMaxOrderByAggregateInput
    _min?: PostLikeMinOrderByAggregateInput
  }

  export type PostLikeScalarWhereWithAggregatesInput = {
    AND?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
    OR?: PostLikeScalarWhereWithAggregatesInput[]
    NOT?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostLike"> | Date | string
    postId?: StringWithAggregatesFilter<"PostLike"> | string
    memberId?: StringWithAggregatesFilter<"PostLike"> | string
  }

  export type CommentLikeWhereInput = {
    AND?: CommentLikeWhereInput | CommentLikeWhereInput[]
    OR?: CommentLikeWhereInput[]
    NOT?: CommentLikeWhereInput | CommentLikeWhereInput[]
    id?: StringFilter<"CommentLike"> | string
    createdAt?: DateTimeFilter<"CommentLike"> | Date | string
    commentId?: StringFilter<"CommentLike"> | string
    memberId?: StringFilter<"CommentLike"> | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type CommentLikeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    memberId?: SortOrder
    comment?: CommentOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
  }

  export type CommentLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    commentId_memberId?: CommentLikeCommentIdMemberIdCompoundUniqueInput
    AND?: CommentLikeWhereInput | CommentLikeWhereInput[]
    OR?: CommentLikeWhereInput[]
    NOT?: CommentLikeWhereInput | CommentLikeWhereInput[]
    createdAt?: DateTimeFilter<"CommentLike"> | Date | string
    commentId?: StringFilter<"CommentLike"> | string
    memberId?: StringFilter<"CommentLike"> | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "commentId_memberId">

  export type CommentLikeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    memberId?: SortOrder
    _count?: CommentLikeCountOrderByAggregateInput
    _max?: CommentLikeMaxOrderByAggregateInput
    _min?: CommentLikeMinOrderByAggregateInput
  }

  export type CommentLikeScalarWhereWithAggregatesInput = {
    AND?: CommentLikeScalarWhereWithAggregatesInput | CommentLikeScalarWhereWithAggregatesInput[]
    OR?: CommentLikeScalarWhereWithAggregatesInput[]
    NOT?: CommentLikeScalarWhereWithAggregatesInput | CommentLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommentLike"> | Date | string
    commentId?: StringWithAggregatesFilter<"CommentLike"> | string
    memberId?: StringWithAggregatesFilter<"CommentLike"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    memberId?: StringFilter<"Notification"> | string
    relatedPostId?: StringNullableFilter<"Notification"> | string | null
    relatedCommentId?: StringNullableFilter<"Notification"> | string | null
    relatedMemberId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    relatedMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    memberId?: SortOrder
    relatedPostId?: SortOrderInput | SortOrder
    relatedCommentId?: SortOrderInput | SortOrder
    relatedMemberId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
    relatedMember?: MemberOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    memberId?: StringFilter<"Notification"> | string
    relatedPostId?: StringNullableFilter<"Notification"> | string | null
    relatedCommentId?: StringNullableFilter<"Notification"> | string | null
    relatedMemberId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    member?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    relatedMember?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    memberId?: SortOrder
    relatedPostId?: SortOrderInput | SortOrder
    relatedCommentId?: SortOrderInput | SortOrder
    relatedMemberId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    memberId?: StringWithAggregatesFilter<"Notification"> | string
    relatedPostId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedCommentId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedMemberId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
  }

  export type FamilyMemberPermissionWhereInput = {
    AND?: FamilyMemberPermissionWhereInput | FamilyMemberPermissionWhereInput[]
    OR?: FamilyMemberPermissionWhereInput[]
    NOT?: FamilyMemberPermissionWhereInput | FamilyMemberPermissionWhereInput[]
    id?: StringFilter<"FamilyMemberPermission"> | string
    createdAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
    familyMemberId?: StringFilter<"FamilyMemberPermission"> | string
    permission?: StringFilter<"FamilyMemberPermission"> | string
    grantedBy?: StringFilter<"FamilyMemberPermission"> | string
    grantedAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
    familyMember?: XOR<FamilyMembershipScalarRelationFilter, FamilyMembershipWhereInput>
  }

  export type FamilyMemberPermissionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    familyMemberId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    familyMember?: FamilyMembershipOrderByWithRelationInput
  }

  export type FamilyMemberPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    familyMemberId_permission?: FamilyMemberPermissionFamilyMemberIdPermissionCompoundUniqueInput
    AND?: FamilyMemberPermissionWhereInput | FamilyMemberPermissionWhereInput[]
    OR?: FamilyMemberPermissionWhereInput[]
    NOT?: FamilyMemberPermissionWhereInput | FamilyMemberPermissionWhereInput[]
    createdAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
    familyMemberId?: StringFilter<"FamilyMemberPermission"> | string
    permission?: StringFilter<"FamilyMemberPermission"> | string
    grantedBy?: StringFilter<"FamilyMemberPermission"> | string
    grantedAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
    familyMember?: XOR<FamilyMembershipScalarRelationFilter, FamilyMembershipWhereInput>
  }, "id" | "familyMemberId_permission">

  export type FamilyMemberPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    familyMemberId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
    _count?: FamilyMemberPermissionCountOrderByAggregateInput
    _max?: FamilyMemberPermissionMaxOrderByAggregateInput
    _min?: FamilyMemberPermissionMinOrderByAggregateInput
  }

  export type FamilyMemberPermissionScalarWhereWithAggregatesInput = {
    AND?: FamilyMemberPermissionScalarWhereWithAggregatesInput | FamilyMemberPermissionScalarWhereWithAggregatesInput[]
    OR?: FamilyMemberPermissionScalarWhereWithAggregatesInput[]
    NOT?: FamilyMemberPermissionScalarWhereWithAggregatesInput | FamilyMemberPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyMemberPermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FamilyMemberPermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FamilyMemberPermission"> | Date | string
    familyMemberId?: StringWithAggregatesFilter<"FamilyMemberPermission"> | string
    permission?: StringWithAggregatesFilter<"FamilyMemberPermission"> | string
    grantedBy?: StringWithAggregatesFilter<"FamilyMemberPermission"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"FamilyMemberPermission"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password: string
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    member?: MemberCreateNestedOneWithoutUserInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password: string
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId?: string | null
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneWithoutUserNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password: string
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberCreateManyInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
  }

  export type FamilyCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutCreatedFamiliesInput
    headOfFamily?: MemberCreateNestedOneWithoutHeadedFamiliesInput
    parentFamily?: FamilyCreateNestedOneWithoutSubFamiliesInput
    subFamilies?: FamilyCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipCreateNestedManyWithoutFamilyInput
    invitations?: InvitationCreateNestedManyWithoutFamilyInput
  }

  export type FamilyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    headOfFamilyId?: string | null
    parentFamilyId?: string | null
    subFamilies?: FamilyUncheckedCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipUncheckedCreateNestedManyWithoutFamilyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutFamilyInput
  }

  export type FamilyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutCreatedFamiliesNestedInput
    headOfFamily?: MemberUpdateOneWithoutHeadedFamiliesNestedInput
    parentFamily?: FamilyUpdateOneWithoutSubFamiliesNestedInput
    subFamilies?: FamilyUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    subFamilies?: FamilyUncheckedUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUncheckedUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    headOfFamilyId?: string | null
    parentFamilyId?: string | null
  }

  export type FamilyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FamilyMembershipCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
    member: MemberCreateNestedOneWithoutFamilyMembershipsInput
    family: FamilyCreateNestedOneWithoutMembershipsInput
    familyMemberPermissions?: FamilyMemberPermissionCreateNestedManyWithoutFamilyMemberInput
  }

  export type FamilyMembershipUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    familyId: string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
    familyMemberPermissions?: FamilyMemberPermissionUncheckedCreateNestedManyWithoutFamilyMemberInput
  }

  export type FamilyMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutFamilyMembershipsNestedInput
    family?: FamilyUpdateOneRequiredWithoutMembershipsNestedInput
    familyMemberPermissions?: FamilyMemberPermissionUpdateManyWithoutFamilyMemberNestedInput
  }

  export type FamilyMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberPermissions?: FamilyMemberPermissionUncheckedUpdateManyWithoutFamilyMemberNestedInput
  }

  export type FamilyMembershipCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    familyId: string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
  }

  export type FamilyMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
    family: FamilyCreateNestedOneWithoutInvitationsInput
    inviterUser?: UserCreateNestedOneWithoutSentInvitationsInput
    inviterMember?: MemberCreateNestedOneWithoutSentInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    familyId: string
    inviterUserId?: string | null
    inviterMemberId?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
    family?: FamilyUpdateOneRequiredWithoutInvitationsNestedInput
    inviterUser?: UserUpdateOneWithoutSentInvitationsNestedInput
    inviterMember?: MemberUpdateOneWithoutSentInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    familyId?: StringFieldUpdateOperationsInput | string
    inviterUserId?: NullableStringFieldUpdateOperationsInput | string | null
    inviterMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationCreateManyInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    familyId: string
    inviterUserId?: string | null
    inviterMemberId?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    familyId?: StringFieldUpdateOperationsInput | string
    inviterUserId?: NullableStringFieldUpdateOperationsInput | string | null
    inviterMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FileCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: MemberCreateNestedOneWithoutUploadedFilesInput
    postAttachments?: PostFileAttachmentCreateNestedManyWithoutFileInput
    commentAttachments?: CommentFileAttachmentCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: string
    postAttachments?: PostFileAttachmentUncheckedCreateNestedManyWithoutFileInput
    commentAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: MemberUpdateOneRequiredWithoutUploadedFilesNestedInput
    postAttachments?: PostFileAttachmentUpdateManyWithoutFileNestedInput
    commentAttachments?: CommentFileAttachmentUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    postAttachments?: PostFileAttachmentUncheckedUpdateManyWithoutFileNestedInput
    commentAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PostFileAttachmentCreateInput = {
    id?: string
    order?: number
    post: PostCreateNestedOneWithoutFileAttachmentsInput
    file: FileCreateNestedOneWithoutPostAttachmentsInput
  }

  export type PostFileAttachmentUncheckedCreateInput = {
    id?: string
    postId: string
    fileId: string
    order?: number
  }

  export type PostFileAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutFileAttachmentsNestedInput
    file?: FileUpdateOneRequiredWithoutPostAttachmentsNestedInput
  }

  export type PostFileAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PostFileAttachmentCreateManyInput = {
    id?: string
    postId: string
    fileId: string
    order?: number
  }

  export type PostFileAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PostFileAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CommentFileAttachmentCreateInput = {
    id?: string
    comment: CommentCreateNestedOneWithoutFileAttachmentsInput
    file: FileCreateNestedOneWithoutCommentAttachmentsInput
  }

  export type CommentFileAttachmentUncheckedCreateInput = {
    id?: string
    commentId: string
    fileId: string
  }

  export type CommentFileAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: CommentUpdateOneRequiredWithoutFileAttachmentsNestedInput
    file?: FileUpdateOneRequiredWithoutCommentAttachmentsNestedInput
  }

  export type CommentFileAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentFileAttachmentCreateManyInput = {
    id?: string
    commentId: string
    fileId: string
  }

  export type CommentFileAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CommentFileAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    author: MemberCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    fileAttachments?: PostFileAttachmentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    authorId: string
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    fileAttachments?: PostFileAttachmentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    fileAttachments?: PostFileAttachmentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    authorId?: StringFieldUpdateOperationsInput | string
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    fileAttachments?: PostFileAttachmentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    authorId: string
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    authorId?: StringFieldUpdateOperationsInput | string
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likesCount?: number
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    authorId: string
    parentCommentId?: string | null
    likesCount?: number
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeUncheckedCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUncheckedUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    authorId: string
    parentCommentId?: string | null
    likesCount?: number
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
  }

  export type PostLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutLikesInput
    member: MemberCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    postId: string
    memberId: string
  }

  export type PostLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
    member?: MemberUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    postId: string
    memberId: string
  }

  export type PostLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutLikesInput
    member: MemberCreateNestedOneWithoutCommentLikesInput
  }

  export type CommentLikeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    commentId: string
    memberId: string
  }

  export type CommentLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutLikesNestedInput
    member?: MemberUpdateOneRequiredWithoutCommentLikesNestedInput
  }

  export type CommentLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    commentId: string
    memberId: string
  }

  export type CommentLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    member: MemberCreateNestedOneWithoutNotificationsInput
    relatedMember?: MemberCreateNestedOneWithoutTriggeredNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    memberId: string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    relatedMemberId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    member?: MemberUpdateOneRequiredWithoutNotificationsNestedInput
    relatedMember?: MemberUpdateOneWithoutTriggeredNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    memberId: string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    relatedMemberId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FamilyMemberPermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: string
    grantedBy: string
    grantedAt?: Date | string
    familyMember: FamilyMembershipCreateNestedOneWithoutFamilyMemberPermissionsInput
  }

  export type FamilyMemberPermissionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    familyMemberId: string
    permission: string
    grantedBy: string
    grantedAt?: Date | string
  }

  export type FamilyMemberPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMember?: FamilyMembershipUpdateOneRequiredWithoutFamilyMemberPermissionsNestedInput
  }

  export type FamilyMemberPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberPermissionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    familyMemberId: string
    permission: string
    grantedBy: string
    grantedAt?: Date | string
  }

  export type FamilyMemberPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: StringFieldUpdateOperationsInput | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MemberNullableScalarRelationFilter = {
    is?: MemberWhereInput | null
    isNot?: MemberWhereInput | null
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type FamilyMembershipListRelationFilter = {
    every?: FamilyMembershipWhereInput
    some?: FamilyMembershipWhereInput
    none?: FamilyMembershipWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type FamilyListRelationFilter = {
    every?: FamilyWhereInput
    some?: FamilyWhereInput
    none?: FamilyWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type PostLikeListRelationFilter = {
    every?: PostLikeWhereInput
    some?: PostLikeWhereInput
    none?: PostLikeWhereInput
  }

  export type CommentLikeListRelationFilter = {
    every?: CommentLikeWhereInput
    some?: CommentLikeWhereInput
    none?: CommentLikeWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalInfo?: SortOrder
    color?: SortOrder
    parentColors?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    color?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    color?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MemberScalarRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type FamilyNullableScalarRelationFilter = {
    is?: FamilyWhereInput | null
    isNot?: FamilyWhereInput | null
  }

  export type FamilyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSubFamily?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    headOfFamilyId?: SortOrder
    parentFamilyId?: SortOrder
  }

  export type FamilyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSubFamily?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    headOfFamilyId?: SortOrder
    parentFamilyId?: SortOrder
  }

  export type FamilyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSubFamily?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    headOfFamilyId?: SortOrder
    parentFamilyId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumFamilyRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.FamilyRole | EnumFamilyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.FamilyRole[] | ListEnumFamilyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.FamilyRole[] | ListEnumFamilyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumFamilyRoleFilter<$PrismaModel> | $Enums.FamilyRole
  }

  export type EnumMembershipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipType | EnumMembershipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipType[] | ListEnumMembershipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipType[] | ListEnumMembershipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipTypeFilter<$PrismaModel> | $Enums.MembershipType
  }

  export type FamilyScalarRelationFilter = {
    is?: FamilyWhereInput
    isNot?: FamilyWhereInput
  }

  export type FamilyMemberPermissionListRelationFilter = {
    every?: FamilyMemberPermissionWhereInput
    some?: FamilyMemberPermissionWhereInput
    none?: FamilyMemberPermissionWhereInput
  }

  export type FamilyMemberPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyMembershipMemberIdFamilyIdCompoundUniqueInput = {
    memberId: string
    familyId: string
  }

  export type FamilyMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrder
    familyId?: SortOrder
    role?: SortOrder
    type?: SortOrder
    autoEnrolled?: SortOrder
    manuallyEdited?: SortOrder
    isActive?: SortOrder
    joinDate?: SortOrder
  }

  export type FamilyMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrder
    familyId?: SortOrder
    role?: SortOrder
    type?: SortOrder
    autoEnrolled?: SortOrder
    manuallyEdited?: SortOrder
    isActive?: SortOrder
    joinDate?: SortOrder
  }

  export type FamilyMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberId?: SortOrder
    familyId?: SortOrder
    role?: SortOrder
    type?: SortOrder
    autoEnrolled?: SortOrder
    manuallyEdited?: SortOrder
    isActive?: SortOrder
    joinDate?: SortOrder
  }

  export type EnumFamilyRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FamilyRole | EnumFamilyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.FamilyRole[] | ListEnumFamilyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.FamilyRole[] | ListEnumFamilyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumFamilyRoleWithAggregatesFilter<$PrismaModel> | $Enums.FamilyRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFamilyRoleFilter<$PrismaModel>
    _max?: NestedEnumFamilyRoleFilter<$PrismaModel>
  }

  export type EnumMembershipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipType | EnumMembershipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipType[] | ListEnumMembershipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipType[] | ListEnumMembershipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipTypeWithAggregatesFilter<$PrismaModel> | $Enums.MembershipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembershipTypeFilter<$PrismaModel>
    _max?: NestedEnumMembershipTypeFilter<$PrismaModel>
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    usedAt?: SortOrder
    acceptedBy?: SortOrder
    familyId?: SortOrder
    inviterUserId?: SortOrder
    inviterMemberId?: SortOrder
    memberStub?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    usedAt?: SortOrder
    acceptedBy?: SortOrder
    familyId?: SortOrder
    inviterUserId?: SortOrder
    inviterMemberId?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    usedAt?: SortOrder
    acceptedBy?: SortOrder
    familyId?: SortOrder
    inviterUserId?: SortOrder
    inviterMemberId?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type PostFileAttachmentListRelationFilter = {
    every?: PostFileAttachmentWhereInput
    some?: PostFileAttachmentWhereInput
    none?: PostFileAttachmentWhereInput
  }

  export type CommentFileAttachmentListRelationFilter = {
    every?: CommentFileAttachmentWhereInput
    some?: CommentFileAttachmentWhereInput
    none?: CommentFileAttachmentWhereInput
  }

  export type PostFileAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentFileAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type FileScalarRelationFilter = {
    is?: FileWhereInput
    isNot?: FileWhereInput
  }

  export type PostFileAttachmentPostIdFileIdCompoundUniqueInput = {
    postId: string
    fileId: string
  }

  export type PostFileAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    fileId?: SortOrder
    order?: SortOrder
  }

  export type PostFileAttachmentAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PostFileAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    fileId?: SortOrder
    order?: SortOrder
  }

  export type PostFileAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    fileId?: SortOrder
    order?: SortOrder
  }

  export type PostFileAttachmentSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentFileAttachmentCommentIdFileIdCompoundUniqueInput = {
    commentId: string
    fileId: string
  }

  export type CommentFileAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    fileId?: SortOrder
  }

  export type CommentFileAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    fileId?: SortOrder
  }

  export type CommentFileAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    fileId?: SortOrder
  }

  export type EnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrls?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    familyId?: SortOrder
    likesCount?: SortOrder
    editHistory?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    likesCount?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    familyId?: SortOrder
    likesCount?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visibility?: SortOrder
    authorId?: SortOrder
    familyId?: SortOrder
    likesCount?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    likesCount?: SortOrder
  }

  export type EnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentCommentId?: SortOrder
    likesCount?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    likesCount?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentCommentId?: SortOrder
    likesCount?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentCommentId?: SortOrder
    likesCount?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    likesCount?: SortOrder
  }

  export type PostLikePostIdMemberIdCompoundUniqueInput = {
    postId: string
    memberId: string
  }

  export type PostLikeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    postId?: SortOrder
    memberId?: SortOrder
  }

  export type PostLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    postId?: SortOrder
    memberId?: SortOrder
  }

  export type PostLikeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    postId?: SortOrder
    memberId?: SortOrder
  }

  export type CommentLikeCommentIdMemberIdCompoundUniqueInput = {
    commentId: string
    memberId: string
  }

  export type CommentLikeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    memberId?: SortOrder
  }

  export type CommentLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    memberId?: SortOrder
  }

  export type CommentLikeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    commentId?: SortOrder
    memberId?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    memberId?: SortOrder
    relatedPostId?: SortOrder
    relatedCommentId?: SortOrder
    relatedMemberId?: SortOrder
    metadata?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    memberId?: SortOrder
    relatedPostId?: SortOrder
    relatedCommentId?: SortOrder
    relatedMemberId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    memberId?: SortOrder
    relatedPostId?: SortOrder
    relatedCommentId?: SortOrder
    relatedMemberId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type FamilyMembershipScalarRelationFilter = {
    is?: FamilyMembershipWhereInput
    isNot?: FamilyMembershipWhereInput
  }

  export type FamilyMemberPermissionFamilyMemberIdPermissionCompoundUniqueInput = {
    familyMemberId: string
    permission: string
  }

  export type FamilyMemberPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    familyMemberId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
  }

  export type FamilyMemberPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    familyMemberId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
  }

  export type FamilyMemberPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    familyMemberId?: SortOrder
    permission?: SortOrder
    grantedBy?: SortOrder
    grantedAt?: SortOrder
  }

  export type MemberCreateNestedOneWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput
    connect?: MemberWhereUniqueInput
  }

  export type InvitationCreateNestedManyWithoutInviterUserInput = {
    create?: XOR<InvitationCreateWithoutInviterUserInput, InvitationUncheckedCreateWithoutInviterUserInput> | InvitationCreateWithoutInviterUserInput[] | InvitationUncheckedCreateWithoutInviterUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInviterUserInput | InvitationCreateOrConnectWithoutInviterUserInput[]
    createMany?: InvitationCreateManyInviterUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutInviterUserInput = {
    create?: XOR<InvitationCreateWithoutInviterUserInput, InvitationUncheckedCreateWithoutInviterUserInput> | InvitationCreateWithoutInviterUserInput[] | InvitationUncheckedCreateWithoutInviterUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInviterUserInput | InvitationCreateOrConnectWithoutInviterUserInput[]
    createMany?: InvitationCreateManyInviterUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MemberUpdateOneWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput
    upsert?: MemberUpsertWithoutUserInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutUserInput, MemberUpdateWithoutUserInput>, MemberUncheckedUpdateWithoutUserInput>
  }

  export type InvitationUpdateManyWithoutInviterUserNestedInput = {
    create?: XOR<InvitationCreateWithoutInviterUserInput, InvitationUncheckedCreateWithoutInviterUserInput> | InvitationCreateWithoutInviterUserInput[] | InvitationUncheckedCreateWithoutInviterUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInviterUserInput | InvitationCreateOrConnectWithoutInviterUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutInviterUserInput | InvitationUpsertWithWhereUniqueWithoutInviterUserInput[]
    createMany?: InvitationCreateManyInviterUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutInviterUserInput | InvitationUpdateWithWhereUniqueWithoutInviterUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutInviterUserInput | InvitationUpdateManyWithWhereWithoutInviterUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutInviterUserNestedInput = {
    create?: XOR<InvitationCreateWithoutInviterUserInput, InvitationUncheckedCreateWithoutInviterUserInput> | InvitationCreateWithoutInviterUserInput[] | InvitationUncheckedCreateWithoutInviterUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInviterUserInput | InvitationCreateOrConnectWithoutInviterUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutInviterUserInput | InvitationUpsertWithWhereUniqueWithoutInviterUserInput[]
    createMany?: InvitationCreateManyInviterUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutInviterUserInput | InvitationUpdateWithWhereUniqueWithoutInviterUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutInviterUserInput | InvitationUpdateManyWithWhereWithoutInviterUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberCreateparentColorsInput = {
    set: string[]
  }

  export type MemberCreateNestedManyWithoutChildrenInput = {
    create?: XOR<MemberCreateWithoutChildrenInput, MemberUncheckedCreateWithoutChildrenInput> | MemberCreateWithoutChildrenInput[] | MemberUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutChildrenInput | MemberCreateOrConnectWithoutChildrenInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutParentsInput = {
    create?: XOR<MemberCreateWithoutParentsInput, MemberUncheckedCreateWithoutParentsInput> | MemberCreateWithoutParentsInput[] | MemberUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutParentsInput | MemberCreateOrConnectWithoutParentsInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutSpousesReverseInput = {
    create?: XOR<MemberCreateWithoutSpousesReverseInput, MemberUncheckedCreateWithoutSpousesReverseInput> | MemberCreateWithoutSpousesReverseInput[] | MemberUncheckedCreateWithoutSpousesReverseInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutSpousesReverseInput | MemberCreateOrConnectWithoutSpousesReverseInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutSpousesInput = {
    create?: XOR<MemberCreateWithoutSpousesInput, MemberUncheckedCreateWithoutSpousesInput> | MemberCreateWithoutSpousesInput[] | MemberUncheckedCreateWithoutSpousesInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutSpousesInput | MemberCreateOrConnectWithoutSpousesInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type FamilyMembershipCreateNestedManyWithoutMemberInput = {
    create?: XOR<FamilyMembershipCreateWithoutMemberInput, FamilyMembershipUncheckedCreateWithoutMemberInput> | FamilyMembershipCreateWithoutMemberInput[] | FamilyMembershipUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutMemberInput | FamilyMembershipCreateOrConnectWithoutMemberInput[]
    createMany?: FamilyMembershipCreateManyMemberInputEnvelope
    connect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutMemberInput = {
    create?: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInput
    connect?: UserWhereUniqueInput
  }

  export type InvitationCreateNestedManyWithoutInviterMemberInput = {
    create?: XOR<InvitationCreateWithoutInviterMemberInput, InvitationUncheckedCreateWithoutInviterMemberInput> | InvitationCreateWithoutInviterMemberInput[] | InvitationUncheckedCreateWithoutInviterMemberInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInviterMemberInput | InvitationCreateOrConnectWithoutInviterMemberInput[]
    createMany?: InvitationCreateManyInviterMemberInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type FamilyCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FamilyCreateWithoutCreatorInput, FamilyUncheckedCreateWithoutCreatorInput> | FamilyCreateWithoutCreatorInput[] | FamilyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutCreatorInput | FamilyCreateOrConnectWithoutCreatorInput[]
    createMany?: FamilyCreateManyCreatorInputEnvelope
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
  }

  export type FamilyCreateNestedManyWithoutHeadOfFamilyInput = {
    create?: XOR<FamilyCreateWithoutHeadOfFamilyInput, FamilyUncheckedCreateWithoutHeadOfFamilyInput> | FamilyCreateWithoutHeadOfFamilyInput[] | FamilyUncheckedCreateWithoutHeadOfFamilyInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutHeadOfFamilyInput | FamilyCreateOrConnectWithoutHeadOfFamilyInput[]
    createMany?: FamilyCreateManyHeadOfFamilyInputEnvelope
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostLikeCreateNestedManyWithoutMemberInput = {
    create?: XOR<PostLikeCreateWithoutMemberInput, PostLikeUncheckedCreateWithoutMemberInput> | PostLikeCreateWithoutMemberInput[] | PostLikeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutMemberInput | PostLikeCreateOrConnectWithoutMemberInput[]
    createMany?: PostLikeCreateManyMemberInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type CommentLikeCreateNestedManyWithoutMemberInput = {
    create?: XOR<CommentLikeCreateWithoutMemberInput, CommentLikeUncheckedCreateWithoutMemberInput> | CommentLikeCreateWithoutMemberInput[] | CommentLikeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CommentLikeCreateOrConnectWithoutMemberInput | CommentLikeCreateOrConnectWithoutMemberInput[]
    createMany?: CommentLikeCreateManyMemberInputEnvelope
    connect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutMemberInput = {
    create?: XOR<NotificationCreateWithoutMemberInput, NotificationUncheckedCreateWithoutMemberInput> | NotificationCreateWithoutMemberInput[] | NotificationUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMemberInput | NotificationCreateOrConnectWithoutMemberInput[]
    createMany?: NotificationCreateManyMemberInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRelatedMemberInput = {
    create?: XOR<NotificationCreateWithoutRelatedMemberInput, NotificationUncheckedCreateWithoutRelatedMemberInput> | NotificationCreateWithoutRelatedMemberInput[] | NotificationUncheckedCreateWithoutRelatedMemberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedMemberInput | NotificationCreateOrConnectWithoutRelatedMemberInput[]
    createMany?: NotificationCreateManyRelatedMemberInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutUploaderInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[]
    createMany?: FileCreateManyUploaderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutChildrenInput = {
    create?: XOR<MemberCreateWithoutChildrenInput, MemberUncheckedCreateWithoutChildrenInput> | MemberCreateWithoutChildrenInput[] | MemberUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutChildrenInput | MemberCreateOrConnectWithoutChildrenInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutParentsInput = {
    create?: XOR<MemberCreateWithoutParentsInput, MemberUncheckedCreateWithoutParentsInput> | MemberCreateWithoutParentsInput[] | MemberUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutParentsInput | MemberCreateOrConnectWithoutParentsInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutSpousesReverseInput = {
    create?: XOR<MemberCreateWithoutSpousesReverseInput, MemberUncheckedCreateWithoutSpousesReverseInput> | MemberCreateWithoutSpousesReverseInput[] | MemberUncheckedCreateWithoutSpousesReverseInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutSpousesReverseInput | MemberCreateOrConnectWithoutSpousesReverseInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutSpousesInput = {
    create?: XOR<MemberCreateWithoutSpousesInput, MemberUncheckedCreateWithoutSpousesInput> | MemberCreateWithoutSpousesInput[] | MemberUncheckedCreateWithoutSpousesInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutSpousesInput | MemberCreateOrConnectWithoutSpousesInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<FamilyMembershipCreateWithoutMemberInput, FamilyMembershipUncheckedCreateWithoutMemberInput> | FamilyMembershipCreateWithoutMemberInput[] | FamilyMembershipUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutMemberInput | FamilyMembershipCreateOrConnectWithoutMemberInput[]
    createMany?: FamilyMembershipCreateManyMemberInputEnvelope
    connect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInput
    connect?: UserWhereUniqueInput
  }

  export type InvitationUncheckedCreateNestedManyWithoutInviterMemberInput = {
    create?: XOR<InvitationCreateWithoutInviterMemberInput, InvitationUncheckedCreateWithoutInviterMemberInput> | InvitationCreateWithoutInviterMemberInput[] | InvitationUncheckedCreateWithoutInviterMemberInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInviterMemberInput | InvitationCreateOrConnectWithoutInviterMemberInput[]
    createMany?: InvitationCreateManyInviterMemberInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type FamilyUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FamilyCreateWithoutCreatorInput, FamilyUncheckedCreateWithoutCreatorInput> | FamilyCreateWithoutCreatorInput[] | FamilyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutCreatorInput | FamilyCreateOrConnectWithoutCreatorInput[]
    createMany?: FamilyCreateManyCreatorInputEnvelope
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
  }

  export type FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput = {
    create?: XOR<FamilyCreateWithoutHeadOfFamilyInput, FamilyUncheckedCreateWithoutHeadOfFamilyInput> | FamilyCreateWithoutHeadOfFamilyInput[] | FamilyUncheckedCreateWithoutHeadOfFamilyInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutHeadOfFamilyInput | FamilyCreateOrConnectWithoutHeadOfFamilyInput[]
    createMany?: FamilyCreateManyHeadOfFamilyInputEnvelope
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostLikeUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<PostLikeCreateWithoutMemberInput, PostLikeUncheckedCreateWithoutMemberInput> | PostLikeCreateWithoutMemberInput[] | PostLikeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutMemberInput | PostLikeCreateOrConnectWithoutMemberInput[]
    createMany?: PostLikeCreateManyMemberInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type CommentLikeUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<CommentLikeCreateWithoutMemberInput, CommentLikeUncheckedCreateWithoutMemberInput> | CommentLikeCreateWithoutMemberInput[] | CommentLikeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CommentLikeCreateOrConnectWithoutMemberInput | CommentLikeCreateOrConnectWithoutMemberInput[]
    createMany?: CommentLikeCreateManyMemberInputEnvelope
    connect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<NotificationCreateWithoutMemberInput, NotificationUncheckedCreateWithoutMemberInput> | NotificationCreateWithoutMemberInput[] | NotificationUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMemberInput | NotificationCreateOrConnectWithoutMemberInput[]
    createMany?: NotificationCreateManyMemberInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput = {
    create?: XOR<NotificationCreateWithoutRelatedMemberInput, NotificationUncheckedCreateWithoutRelatedMemberInput> | NotificationCreateWithoutRelatedMemberInput[] | NotificationUncheckedCreateWithoutRelatedMemberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedMemberInput | NotificationCreateOrConnectWithoutRelatedMemberInput[]
    createMany?: NotificationCreateManyRelatedMemberInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[]
    createMany?: FileCreateManyUploaderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type EnumMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.MemberStatus
  }

  export type MemberUpdateparentColorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MemberUpdateManyWithoutChildrenNestedInput = {
    create?: XOR<MemberCreateWithoutChildrenInput, MemberUncheckedCreateWithoutChildrenInput> | MemberCreateWithoutChildrenInput[] | MemberUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutChildrenInput | MemberCreateOrConnectWithoutChildrenInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutChildrenInput | MemberUpsertWithWhereUniqueWithoutChildrenInput[]
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutChildrenInput | MemberUpdateWithWhereUniqueWithoutChildrenInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutChildrenInput | MemberUpdateManyWithWhereWithoutChildrenInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutParentsNestedInput = {
    create?: XOR<MemberCreateWithoutParentsInput, MemberUncheckedCreateWithoutParentsInput> | MemberCreateWithoutParentsInput[] | MemberUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutParentsInput | MemberCreateOrConnectWithoutParentsInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutParentsInput | MemberUpsertWithWhereUniqueWithoutParentsInput[]
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutParentsInput | MemberUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutParentsInput | MemberUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutSpousesReverseNestedInput = {
    create?: XOR<MemberCreateWithoutSpousesReverseInput, MemberUncheckedCreateWithoutSpousesReverseInput> | MemberCreateWithoutSpousesReverseInput[] | MemberUncheckedCreateWithoutSpousesReverseInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutSpousesReverseInput | MemberCreateOrConnectWithoutSpousesReverseInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutSpousesReverseInput | MemberUpsertWithWhereUniqueWithoutSpousesReverseInput[]
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutSpousesReverseInput | MemberUpdateWithWhereUniqueWithoutSpousesReverseInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutSpousesReverseInput | MemberUpdateManyWithWhereWithoutSpousesReverseInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutSpousesNestedInput = {
    create?: XOR<MemberCreateWithoutSpousesInput, MemberUncheckedCreateWithoutSpousesInput> | MemberCreateWithoutSpousesInput[] | MemberUncheckedCreateWithoutSpousesInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutSpousesInput | MemberCreateOrConnectWithoutSpousesInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutSpousesInput | MemberUpsertWithWhereUniqueWithoutSpousesInput[]
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutSpousesInput | MemberUpdateWithWhereUniqueWithoutSpousesInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutSpousesInput | MemberUpdateManyWithWhereWithoutSpousesInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type FamilyMembershipUpdateManyWithoutMemberNestedInput = {
    create?: XOR<FamilyMembershipCreateWithoutMemberInput, FamilyMembershipUncheckedCreateWithoutMemberInput> | FamilyMembershipCreateWithoutMemberInput[] | FamilyMembershipUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutMemberInput | FamilyMembershipCreateOrConnectWithoutMemberInput[]
    upsert?: FamilyMembershipUpsertWithWhereUniqueWithoutMemberInput | FamilyMembershipUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: FamilyMembershipCreateManyMemberInputEnvelope
    set?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    disconnect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    delete?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    connect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    update?: FamilyMembershipUpdateWithWhereUniqueWithoutMemberInput | FamilyMembershipUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: FamilyMembershipUpdateManyWithWhereWithoutMemberInput | FamilyMembershipUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: FamilyMembershipScalarWhereInput | FamilyMembershipScalarWhereInput[]
  }

  export type UserUpdateOneWithoutMemberNestedInput = {
    create?: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInput
    upsert?: UserUpsertWithoutMemberInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemberInput, UserUpdateWithoutMemberInput>, UserUncheckedUpdateWithoutMemberInput>
  }

  export type InvitationUpdateManyWithoutInviterMemberNestedInput = {
    create?: XOR<InvitationCreateWithoutInviterMemberInput, InvitationUncheckedCreateWithoutInviterMemberInput> | InvitationCreateWithoutInviterMemberInput[] | InvitationUncheckedCreateWithoutInviterMemberInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInviterMemberInput | InvitationCreateOrConnectWithoutInviterMemberInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutInviterMemberInput | InvitationUpsertWithWhereUniqueWithoutInviterMemberInput[]
    createMany?: InvitationCreateManyInviterMemberInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutInviterMemberInput | InvitationUpdateWithWhereUniqueWithoutInviterMemberInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutInviterMemberInput | InvitationUpdateManyWithWhereWithoutInviterMemberInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type FamilyUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FamilyCreateWithoutCreatorInput, FamilyUncheckedCreateWithoutCreatorInput> | FamilyCreateWithoutCreatorInput[] | FamilyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutCreatorInput | FamilyCreateOrConnectWithoutCreatorInput[]
    upsert?: FamilyUpsertWithWhereUniqueWithoutCreatorInput | FamilyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FamilyCreateManyCreatorInputEnvelope
    set?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    disconnect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    delete?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    update?: FamilyUpdateWithWhereUniqueWithoutCreatorInput | FamilyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FamilyUpdateManyWithWhereWithoutCreatorInput | FamilyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FamilyScalarWhereInput | FamilyScalarWhereInput[]
  }

  export type FamilyUpdateManyWithoutHeadOfFamilyNestedInput = {
    create?: XOR<FamilyCreateWithoutHeadOfFamilyInput, FamilyUncheckedCreateWithoutHeadOfFamilyInput> | FamilyCreateWithoutHeadOfFamilyInput[] | FamilyUncheckedCreateWithoutHeadOfFamilyInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutHeadOfFamilyInput | FamilyCreateOrConnectWithoutHeadOfFamilyInput[]
    upsert?: FamilyUpsertWithWhereUniqueWithoutHeadOfFamilyInput | FamilyUpsertWithWhereUniqueWithoutHeadOfFamilyInput[]
    createMany?: FamilyCreateManyHeadOfFamilyInputEnvelope
    set?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    disconnect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    delete?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    update?: FamilyUpdateWithWhereUniqueWithoutHeadOfFamilyInput | FamilyUpdateWithWhereUniqueWithoutHeadOfFamilyInput[]
    updateMany?: FamilyUpdateManyWithWhereWithoutHeadOfFamilyInput | FamilyUpdateManyWithWhereWithoutHeadOfFamilyInput[]
    deleteMany?: FamilyScalarWhereInput | FamilyScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostLikeUpdateManyWithoutMemberNestedInput = {
    create?: XOR<PostLikeCreateWithoutMemberInput, PostLikeUncheckedCreateWithoutMemberInput> | PostLikeCreateWithoutMemberInput[] | PostLikeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutMemberInput | PostLikeCreateOrConnectWithoutMemberInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutMemberInput | PostLikeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: PostLikeCreateManyMemberInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutMemberInput | PostLikeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutMemberInput | PostLikeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type CommentLikeUpdateManyWithoutMemberNestedInput = {
    create?: XOR<CommentLikeCreateWithoutMemberInput, CommentLikeUncheckedCreateWithoutMemberInput> | CommentLikeCreateWithoutMemberInput[] | CommentLikeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CommentLikeCreateOrConnectWithoutMemberInput | CommentLikeCreateOrConnectWithoutMemberInput[]
    upsert?: CommentLikeUpsertWithWhereUniqueWithoutMemberInput | CommentLikeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: CommentLikeCreateManyMemberInputEnvelope
    set?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    disconnect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    delete?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    connect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    update?: CommentLikeUpdateWithWhereUniqueWithoutMemberInput | CommentLikeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: CommentLikeUpdateManyWithWhereWithoutMemberInput | CommentLikeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: CommentLikeScalarWhereInput | CommentLikeScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutMemberNestedInput = {
    create?: XOR<NotificationCreateWithoutMemberInput, NotificationUncheckedCreateWithoutMemberInput> | NotificationCreateWithoutMemberInput[] | NotificationUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMemberInput | NotificationCreateOrConnectWithoutMemberInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMemberInput | NotificationUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: NotificationCreateManyMemberInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMemberInput | NotificationUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMemberInput | NotificationUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRelatedMemberNestedInput = {
    create?: XOR<NotificationCreateWithoutRelatedMemberInput, NotificationUncheckedCreateWithoutRelatedMemberInput> | NotificationCreateWithoutRelatedMemberInput[] | NotificationUncheckedCreateWithoutRelatedMemberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedMemberInput | NotificationCreateOrConnectWithoutRelatedMemberInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRelatedMemberInput | NotificationUpsertWithWhereUniqueWithoutRelatedMemberInput[]
    createMany?: NotificationCreateManyRelatedMemberInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRelatedMemberInput | NotificationUpdateWithWhereUniqueWithoutRelatedMemberInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRelatedMemberInput | NotificationUpdateManyWithWhereWithoutRelatedMemberInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FileUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUploaderInput | FileUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: FileCreateManyUploaderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUploaderInput | FileUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUploaderInput | FileUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutChildrenNestedInput = {
    create?: XOR<MemberCreateWithoutChildrenInput, MemberUncheckedCreateWithoutChildrenInput> | MemberCreateWithoutChildrenInput[] | MemberUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutChildrenInput | MemberCreateOrConnectWithoutChildrenInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutChildrenInput | MemberUpsertWithWhereUniqueWithoutChildrenInput[]
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutChildrenInput | MemberUpdateWithWhereUniqueWithoutChildrenInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutChildrenInput | MemberUpdateManyWithWhereWithoutChildrenInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutParentsNestedInput = {
    create?: XOR<MemberCreateWithoutParentsInput, MemberUncheckedCreateWithoutParentsInput> | MemberCreateWithoutParentsInput[] | MemberUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutParentsInput | MemberCreateOrConnectWithoutParentsInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutParentsInput | MemberUpsertWithWhereUniqueWithoutParentsInput[]
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutParentsInput | MemberUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutParentsInput | MemberUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput = {
    create?: XOR<MemberCreateWithoutSpousesReverseInput, MemberUncheckedCreateWithoutSpousesReverseInput> | MemberCreateWithoutSpousesReverseInput[] | MemberUncheckedCreateWithoutSpousesReverseInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutSpousesReverseInput | MemberCreateOrConnectWithoutSpousesReverseInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutSpousesReverseInput | MemberUpsertWithWhereUniqueWithoutSpousesReverseInput[]
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutSpousesReverseInput | MemberUpdateWithWhereUniqueWithoutSpousesReverseInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutSpousesReverseInput | MemberUpdateManyWithWhereWithoutSpousesReverseInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutSpousesNestedInput = {
    create?: XOR<MemberCreateWithoutSpousesInput, MemberUncheckedCreateWithoutSpousesInput> | MemberCreateWithoutSpousesInput[] | MemberUncheckedCreateWithoutSpousesInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutSpousesInput | MemberCreateOrConnectWithoutSpousesInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutSpousesInput | MemberUpsertWithWhereUniqueWithoutSpousesInput[]
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutSpousesInput | MemberUpdateWithWhereUniqueWithoutSpousesInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutSpousesInput | MemberUpdateManyWithWhereWithoutSpousesInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<FamilyMembershipCreateWithoutMemberInput, FamilyMembershipUncheckedCreateWithoutMemberInput> | FamilyMembershipCreateWithoutMemberInput[] | FamilyMembershipUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutMemberInput | FamilyMembershipCreateOrConnectWithoutMemberInput[]
    upsert?: FamilyMembershipUpsertWithWhereUniqueWithoutMemberInput | FamilyMembershipUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: FamilyMembershipCreateManyMemberInputEnvelope
    set?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    disconnect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    delete?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    connect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    update?: FamilyMembershipUpdateWithWhereUniqueWithoutMemberInput | FamilyMembershipUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: FamilyMembershipUpdateManyWithWhereWithoutMemberInput | FamilyMembershipUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: FamilyMembershipScalarWhereInput | FamilyMembershipScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutMemberNestedInput = {
    create?: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInput
    upsert?: UserUpsertWithoutMemberInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemberInput, UserUpdateWithoutMemberInput>, UserUncheckedUpdateWithoutMemberInput>
  }

  export type InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput = {
    create?: XOR<InvitationCreateWithoutInviterMemberInput, InvitationUncheckedCreateWithoutInviterMemberInput> | InvitationCreateWithoutInviterMemberInput[] | InvitationUncheckedCreateWithoutInviterMemberInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutInviterMemberInput | InvitationCreateOrConnectWithoutInviterMemberInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutInviterMemberInput | InvitationUpsertWithWhereUniqueWithoutInviterMemberInput[]
    createMany?: InvitationCreateManyInviterMemberInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutInviterMemberInput | InvitationUpdateWithWhereUniqueWithoutInviterMemberInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutInviterMemberInput | InvitationUpdateManyWithWhereWithoutInviterMemberInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type FamilyUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FamilyCreateWithoutCreatorInput, FamilyUncheckedCreateWithoutCreatorInput> | FamilyCreateWithoutCreatorInput[] | FamilyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutCreatorInput | FamilyCreateOrConnectWithoutCreatorInput[]
    upsert?: FamilyUpsertWithWhereUniqueWithoutCreatorInput | FamilyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FamilyCreateManyCreatorInputEnvelope
    set?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    disconnect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    delete?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    update?: FamilyUpdateWithWhereUniqueWithoutCreatorInput | FamilyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FamilyUpdateManyWithWhereWithoutCreatorInput | FamilyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FamilyScalarWhereInput | FamilyScalarWhereInput[]
  }

  export type FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput = {
    create?: XOR<FamilyCreateWithoutHeadOfFamilyInput, FamilyUncheckedCreateWithoutHeadOfFamilyInput> | FamilyCreateWithoutHeadOfFamilyInput[] | FamilyUncheckedCreateWithoutHeadOfFamilyInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutHeadOfFamilyInput | FamilyCreateOrConnectWithoutHeadOfFamilyInput[]
    upsert?: FamilyUpsertWithWhereUniqueWithoutHeadOfFamilyInput | FamilyUpsertWithWhereUniqueWithoutHeadOfFamilyInput[]
    createMany?: FamilyCreateManyHeadOfFamilyInputEnvelope
    set?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    disconnect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    delete?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    update?: FamilyUpdateWithWhereUniqueWithoutHeadOfFamilyInput | FamilyUpdateWithWhereUniqueWithoutHeadOfFamilyInput[]
    updateMany?: FamilyUpdateManyWithWhereWithoutHeadOfFamilyInput | FamilyUpdateManyWithWhereWithoutHeadOfFamilyInput[]
    deleteMany?: FamilyScalarWhereInput | FamilyScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostLikeUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<PostLikeCreateWithoutMemberInput, PostLikeUncheckedCreateWithoutMemberInput> | PostLikeCreateWithoutMemberInput[] | PostLikeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutMemberInput | PostLikeCreateOrConnectWithoutMemberInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutMemberInput | PostLikeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: PostLikeCreateManyMemberInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutMemberInput | PostLikeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutMemberInput | PostLikeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type CommentLikeUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<CommentLikeCreateWithoutMemberInput, CommentLikeUncheckedCreateWithoutMemberInput> | CommentLikeCreateWithoutMemberInput[] | CommentLikeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: CommentLikeCreateOrConnectWithoutMemberInput | CommentLikeCreateOrConnectWithoutMemberInput[]
    upsert?: CommentLikeUpsertWithWhereUniqueWithoutMemberInput | CommentLikeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: CommentLikeCreateManyMemberInputEnvelope
    set?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    disconnect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    delete?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    connect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    update?: CommentLikeUpdateWithWhereUniqueWithoutMemberInput | CommentLikeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: CommentLikeUpdateManyWithWhereWithoutMemberInput | CommentLikeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: CommentLikeScalarWhereInput | CommentLikeScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<NotificationCreateWithoutMemberInput, NotificationUncheckedCreateWithoutMemberInput> | NotificationCreateWithoutMemberInput[] | NotificationUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMemberInput | NotificationCreateOrConnectWithoutMemberInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMemberInput | NotificationUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: NotificationCreateManyMemberInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMemberInput | NotificationUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMemberInput | NotificationUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput = {
    create?: XOR<NotificationCreateWithoutRelatedMemberInput, NotificationUncheckedCreateWithoutRelatedMemberInput> | NotificationCreateWithoutRelatedMemberInput[] | NotificationUncheckedCreateWithoutRelatedMemberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedMemberInput | NotificationCreateOrConnectWithoutRelatedMemberInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRelatedMemberInput | NotificationUpsertWithWhereUniqueWithoutRelatedMemberInput[]
    createMany?: NotificationCreateManyRelatedMemberInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRelatedMemberInput | NotificationUpdateWithWhereUniqueWithoutRelatedMemberInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRelatedMemberInput | NotificationUpdateManyWithWhereWithoutRelatedMemberInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput> | FileCreateWithoutUploaderInput[] | FileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUploaderInput | FileCreateOrConnectWithoutUploaderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUploaderInput | FileUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: FileCreateManyUploaderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUploaderInput | FileUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUploaderInput | FileUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutCreatedFamiliesInput = {
    create?: XOR<MemberCreateWithoutCreatedFamiliesInput, MemberUncheckedCreateWithoutCreatedFamiliesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCreatedFamiliesInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutHeadedFamiliesInput = {
    create?: XOR<MemberCreateWithoutHeadedFamiliesInput, MemberUncheckedCreateWithoutHeadedFamiliesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutHeadedFamiliesInput
    connect?: MemberWhereUniqueInput
  }

  export type FamilyCreateNestedOneWithoutSubFamiliesInput = {
    create?: XOR<FamilyCreateWithoutSubFamiliesInput, FamilyUncheckedCreateWithoutSubFamiliesInput>
    connectOrCreate?: FamilyCreateOrConnectWithoutSubFamiliesInput
    connect?: FamilyWhereUniqueInput
  }

  export type FamilyCreateNestedManyWithoutParentFamilyInput = {
    create?: XOR<FamilyCreateWithoutParentFamilyInput, FamilyUncheckedCreateWithoutParentFamilyInput> | FamilyCreateWithoutParentFamilyInput[] | FamilyUncheckedCreateWithoutParentFamilyInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutParentFamilyInput | FamilyCreateOrConnectWithoutParentFamilyInput[]
    createMany?: FamilyCreateManyParentFamilyInputEnvelope
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
  }

  export type FamilyMembershipCreateNestedManyWithoutFamilyInput = {
    create?: XOR<FamilyMembershipCreateWithoutFamilyInput, FamilyMembershipUncheckedCreateWithoutFamilyInput> | FamilyMembershipCreateWithoutFamilyInput[] | FamilyMembershipUncheckedCreateWithoutFamilyInput[]
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutFamilyInput | FamilyMembershipCreateOrConnectWithoutFamilyInput[]
    createMany?: FamilyMembershipCreateManyFamilyInputEnvelope
    connect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutFamilyInput = {
    create?: XOR<InvitationCreateWithoutFamilyInput, InvitationUncheckedCreateWithoutFamilyInput> | InvitationCreateWithoutFamilyInput[] | InvitationUncheckedCreateWithoutFamilyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutFamilyInput | InvitationCreateOrConnectWithoutFamilyInput[]
    createMany?: InvitationCreateManyFamilyInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type FamilyUncheckedCreateNestedManyWithoutParentFamilyInput = {
    create?: XOR<FamilyCreateWithoutParentFamilyInput, FamilyUncheckedCreateWithoutParentFamilyInput> | FamilyCreateWithoutParentFamilyInput[] | FamilyUncheckedCreateWithoutParentFamilyInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutParentFamilyInput | FamilyCreateOrConnectWithoutParentFamilyInput[]
    createMany?: FamilyCreateManyParentFamilyInputEnvelope
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
  }

  export type FamilyMembershipUncheckedCreateNestedManyWithoutFamilyInput = {
    create?: XOR<FamilyMembershipCreateWithoutFamilyInput, FamilyMembershipUncheckedCreateWithoutFamilyInput> | FamilyMembershipCreateWithoutFamilyInput[] | FamilyMembershipUncheckedCreateWithoutFamilyInput[]
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutFamilyInput | FamilyMembershipCreateOrConnectWithoutFamilyInput[]
    createMany?: FamilyMembershipCreateManyFamilyInputEnvelope
    connect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutFamilyInput = {
    create?: XOR<InvitationCreateWithoutFamilyInput, InvitationUncheckedCreateWithoutFamilyInput> | InvitationCreateWithoutFamilyInput[] | InvitationUncheckedCreateWithoutFamilyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutFamilyInput | InvitationCreateOrConnectWithoutFamilyInput[]
    createMany?: InvitationCreateManyFamilyInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MemberUpdateOneRequiredWithoutCreatedFamiliesNestedInput = {
    create?: XOR<MemberCreateWithoutCreatedFamiliesInput, MemberUncheckedCreateWithoutCreatedFamiliesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCreatedFamiliesInput
    upsert?: MemberUpsertWithoutCreatedFamiliesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCreatedFamiliesInput, MemberUpdateWithoutCreatedFamiliesInput>, MemberUncheckedUpdateWithoutCreatedFamiliesInput>
  }

  export type MemberUpdateOneWithoutHeadedFamiliesNestedInput = {
    create?: XOR<MemberCreateWithoutHeadedFamiliesInput, MemberUncheckedCreateWithoutHeadedFamiliesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutHeadedFamiliesInput
    upsert?: MemberUpsertWithoutHeadedFamiliesInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutHeadedFamiliesInput, MemberUpdateWithoutHeadedFamiliesInput>, MemberUncheckedUpdateWithoutHeadedFamiliesInput>
  }

  export type FamilyUpdateOneWithoutSubFamiliesNestedInput = {
    create?: XOR<FamilyCreateWithoutSubFamiliesInput, FamilyUncheckedCreateWithoutSubFamiliesInput>
    connectOrCreate?: FamilyCreateOrConnectWithoutSubFamiliesInput
    upsert?: FamilyUpsertWithoutSubFamiliesInput
    disconnect?: FamilyWhereInput | boolean
    delete?: FamilyWhereInput | boolean
    connect?: FamilyWhereUniqueInput
    update?: XOR<XOR<FamilyUpdateToOneWithWhereWithoutSubFamiliesInput, FamilyUpdateWithoutSubFamiliesInput>, FamilyUncheckedUpdateWithoutSubFamiliesInput>
  }

  export type FamilyUpdateManyWithoutParentFamilyNestedInput = {
    create?: XOR<FamilyCreateWithoutParentFamilyInput, FamilyUncheckedCreateWithoutParentFamilyInput> | FamilyCreateWithoutParentFamilyInput[] | FamilyUncheckedCreateWithoutParentFamilyInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutParentFamilyInput | FamilyCreateOrConnectWithoutParentFamilyInput[]
    upsert?: FamilyUpsertWithWhereUniqueWithoutParentFamilyInput | FamilyUpsertWithWhereUniqueWithoutParentFamilyInput[]
    createMany?: FamilyCreateManyParentFamilyInputEnvelope
    set?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    disconnect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    delete?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    update?: FamilyUpdateWithWhereUniqueWithoutParentFamilyInput | FamilyUpdateWithWhereUniqueWithoutParentFamilyInput[]
    updateMany?: FamilyUpdateManyWithWhereWithoutParentFamilyInput | FamilyUpdateManyWithWhereWithoutParentFamilyInput[]
    deleteMany?: FamilyScalarWhereInput | FamilyScalarWhereInput[]
  }

  export type FamilyMembershipUpdateManyWithoutFamilyNestedInput = {
    create?: XOR<FamilyMembershipCreateWithoutFamilyInput, FamilyMembershipUncheckedCreateWithoutFamilyInput> | FamilyMembershipCreateWithoutFamilyInput[] | FamilyMembershipUncheckedCreateWithoutFamilyInput[]
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutFamilyInput | FamilyMembershipCreateOrConnectWithoutFamilyInput[]
    upsert?: FamilyMembershipUpsertWithWhereUniqueWithoutFamilyInput | FamilyMembershipUpsertWithWhereUniqueWithoutFamilyInput[]
    createMany?: FamilyMembershipCreateManyFamilyInputEnvelope
    set?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    disconnect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    delete?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    connect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    update?: FamilyMembershipUpdateWithWhereUniqueWithoutFamilyInput | FamilyMembershipUpdateWithWhereUniqueWithoutFamilyInput[]
    updateMany?: FamilyMembershipUpdateManyWithWhereWithoutFamilyInput | FamilyMembershipUpdateManyWithWhereWithoutFamilyInput[]
    deleteMany?: FamilyMembershipScalarWhereInput | FamilyMembershipScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutFamilyNestedInput = {
    create?: XOR<InvitationCreateWithoutFamilyInput, InvitationUncheckedCreateWithoutFamilyInput> | InvitationCreateWithoutFamilyInput[] | InvitationUncheckedCreateWithoutFamilyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutFamilyInput | InvitationCreateOrConnectWithoutFamilyInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutFamilyInput | InvitationUpsertWithWhereUniqueWithoutFamilyInput[]
    createMany?: InvitationCreateManyFamilyInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutFamilyInput | InvitationUpdateWithWhereUniqueWithoutFamilyInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutFamilyInput | InvitationUpdateManyWithWhereWithoutFamilyInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type FamilyUncheckedUpdateManyWithoutParentFamilyNestedInput = {
    create?: XOR<FamilyCreateWithoutParentFamilyInput, FamilyUncheckedCreateWithoutParentFamilyInput> | FamilyCreateWithoutParentFamilyInput[] | FamilyUncheckedCreateWithoutParentFamilyInput[]
    connectOrCreate?: FamilyCreateOrConnectWithoutParentFamilyInput | FamilyCreateOrConnectWithoutParentFamilyInput[]
    upsert?: FamilyUpsertWithWhereUniqueWithoutParentFamilyInput | FamilyUpsertWithWhereUniqueWithoutParentFamilyInput[]
    createMany?: FamilyCreateManyParentFamilyInputEnvelope
    set?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    disconnect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    delete?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    connect?: FamilyWhereUniqueInput | FamilyWhereUniqueInput[]
    update?: FamilyUpdateWithWhereUniqueWithoutParentFamilyInput | FamilyUpdateWithWhereUniqueWithoutParentFamilyInput[]
    updateMany?: FamilyUpdateManyWithWhereWithoutParentFamilyInput | FamilyUpdateManyWithWhereWithoutParentFamilyInput[]
    deleteMany?: FamilyScalarWhereInput | FamilyScalarWhereInput[]
  }

  export type FamilyMembershipUncheckedUpdateManyWithoutFamilyNestedInput = {
    create?: XOR<FamilyMembershipCreateWithoutFamilyInput, FamilyMembershipUncheckedCreateWithoutFamilyInput> | FamilyMembershipCreateWithoutFamilyInput[] | FamilyMembershipUncheckedCreateWithoutFamilyInput[]
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutFamilyInput | FamilyMembershipCreateOrConnectWithoutFamilyInput[]
    upsert?: FamilyMembershipUpsertWithWhereUniqueWithoutFamilyInput | FamilyMembershipUpsertWithWhereUniqueWithoutFamilyInput[]
    createMany?: FamilyMembershipCreateManyFamilyInputEnvelope
    set?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    disconnect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    delete?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    connect?: FamilyMembershipWhereUniqueInput | FamilyMembershipWhereUniqueInput[]
    update?: FamilyMembershipUpdateWithWhereUniqueWithoutFamilyInput | FamilyMembershipUpdateWithWhereUniqueWithoutFamilyInput[]
    updateMany?: FamilyMembershipUpdateManyWithWhereWithoutFamilyInput | FamilyMembershipUpdateManyWithWhereWithoutFamilyInput[]
    deleteMany?: FamilyMembershipScalarWhereInput | FamilyMembershipScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutFamilyNestedInput = {
    create?: XOR<InvitationCreateWithoutFamilyInput, InvitationUncheckedCreateWithoutFamilyInput> | InvitationCreateWithoutFamilyInput[] | InvitationUncheckedCreateWithoutFamilyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutFamilyInput | InvitationCreateOrConnectWithoutFamilyInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutFamilyInput | InvitationUpsertWithWhereUniqueWithoutFamilyInput[]
    createMany?: InvitationCreateManyFamilyInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutFamilyInput | InvitationUpdateWithWhereUniqueWithoutFamilyInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutFamilyInput | InvitationUpdateManyWithWhereWithoutFamilyInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutFamilyMembershipsInput = {
    create?: XOR<MemberCreateWithoutFamilyMembershipsInput, MemberUncheckedCreateWithoutFamilyMembershipsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutFamilyMembershipsInput
    connect?: MemberWhereUniqueInput
  }

  export type FamilyCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<FamilyCreateWithoutMembershipsInput, FamilyUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: FamilyCreateOrConnectWithoutMembershipsInput
    connect?: FamilyWhereUniqueInput
  }

  export type FamilyMemberPermissionCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<FamilyMemberPermissionCreateWithoutFamilyMemberInput, FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput> | FamilyMemberPermissionCreateWithoutFamilyMemberInput[] | FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput | FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: FamilyMemberPermissionCreateManyFamilyMemberInputEnvelope
    connect?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
  }

  export type FamilyMemberPermissionUncheckedCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<FamilyMemberPermissionCreateWithoutFamilyMemberInput, FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput> | FamilyMemberPermissionCreateWithoutFamilyMemberInput[] | FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput | FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: FamilyMemberPermissionCreateManyFamilyMemberInputEnvelope
    connect?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
  }

  export type EnumFamilyRoleFieldUpdateOperationsInput = {
    set?: $Enums.FamilyRole
  }

  export type EnumMembershipTypeFieldUpdateOperationsInput = {
    set?: $Enums.MembershipType
  }

  export type MemberUpdateOneRequiredWithoutFamilyMembershipsNestedInput = {
    create?: XOR<MemberCreateWithoutFamilyMembershipsInput, MemberUncheckedCreateWithoutFamilyMembershipsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutFamilyMembershipsInput
    upsert?: MemberUpsertWithoutFamilyMembershipsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutFamilyMembershipsInput, MemberUpdateWithoutFamilyMembershipsInput>, MemberUncheckedUpdateWithoutFamilyMembershipsInput>
  }

  export type FamilyUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<FamilyCreateWithoutMembershipsInput, FamilyUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: FamilyCreateOrConnectWithoutMembershipsInput
    upsert?: FamilyUpsertWithoutMembershipsInput
    connect?: FamilyWhereUniqueInput
    update?: XOR<XOR<FamilyUpdateToOneWithWhereWithoutMembershipsInput, FamilyUpdateWithoutMembershipsInput>, FamilyUncheckedUpdateWithoutMembershipsInput>
  }

  export type FamilyMemberPermissionUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<FamilyMemberPermissionCreateWithoutFamilyMemberInput, FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput> | FamilyMemberPermissionCreateWithoutFamilyMemberInput[] | FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput | FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: FamilyMemberPermissionUpsertWithWhereUniqueWithoutFamilyMemberInput | FamilyMemberPermissionUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: FamilyMemberPermissionCreateManyFamilyMemberInputEnvelope
    set?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
    disconnect?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
    delete?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
    connect?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
    update?: FamilyMemberPermissionUpdateWithWhereUniqueWithoutFamilyMemberInput | FamilyMemberPermissionUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: FamilyMemberPermissionUpdateManyWithWhereWithoutFamilyMemberInput | FamilyMemberPermissionUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: FamilyMemberPermissionScalarWhereInput | FamilyMemberPermissionScalarWhereInput[]
  }

  export type FamilyMemberPermissionUncheckedUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<FamilyMemberPermissionCreateWithoutFamilyMemberInput, FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput> | FamilyMemberPermissionCreateWithoutFamilyMemberInput[] | FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput | FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: FamilyMemberPermissionUpsertWithWhereUniqueWithoutFamilyMemberInput | FamilyMemberPermissionUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: FamilyMemberPermissionCreateManyFamilyMemberInputEnvelope
    set?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
    disconnect?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
    delete?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
    connect?: FamilyMemberPermissionWhereUniqueInput | FamilyMemberPermissionWhereUniqueInput[]
    update?: FamilyMemberPermissionUpdateWithWhereUniqueWithoutFamilyMemberInput | FamilyMemberPermissionUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: FamilyMemberPermissionUpdateManyWithWhereWithoutFamilyMemberInput | FamilyMemberPermissionUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: FamilyMemberPermissionScalarWhereInput | FamilyMemberPermissionScalarWhereInput[]
  }

  export type FamilyCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<FamilyCreateWithoutInvitationsInput, FamilyUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: FamilyCreateOrConnectWithoutInvitationsInput
    connect?: FamilyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentInvitationsInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutSentInvitationsInput = {
    create?: XOR<MemberCreateWithoutSentInvitationsInput, MemberUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSentInvitationsInput
    connect?: MemberWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type FamilyUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<FamilyCreateWithoutInvitationsInput, FamilyUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: FamilyCreateOrConnectWithoutInvitationsInput
    upsert?: FamilyUpsertWithoutInvitationsInput
    connect?: FamilyWhereUniqueInput
    update?: XOR<XOR<FamilyUpdateToOneWithWhereWithoutInvitationsInput, FamilyUpdateWithoutInvitationsInput>, FamilyUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneWithoutSentInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    upsert?: UserUpsertWithoutSentInvitationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitationsInput, UserUpdateWithoutSentInvitationsInput>, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type MemberUpdateOneWithoutSentInvitationsNestedInput = {
    create?: XOR<MemberCreateWithoutSentInvitationsInput, MemberUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSentInvitationsInput
    upsert?: MemberUpsertWithoutSentInvitationsInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutSentInvitationsInput, MemberUpdateWithoutSentInvitationsInput>, MemberUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type MemberCreateNestedOneWithoutUploadedFilesInput = {
    create?: XOR<MemberCreateWithoutUploadedFilesInput, MemberUncheckedCreateWithoutUploadedFilesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutUploadedFilesInput
    connect?: MemberWhereUniqueInput
  }

  export type PostFileAttachmentCreateNestedManyWithoutFileInput = {
    create?: XOR<PostFileAttachmentCreateWithoutFileInput, PostFileAttachmentUncheckedCreateWithoutFileInput> | PostFileAttachmentCreateWithoutFileInput[] | PostFileAttachmentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: PostFileAttachmentCreateOrConnectWithoutFileInput | PostFileAttachmentCreateOrConnectWithoutFileInput[]
    createMany?: PostFileAttachmentCreateManyFileInputEnvelope
    connect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
  }

  export type CommentFileAttachmentCreateNestedManyWithoutFileInput = {
    create?: XOR<CommentFileAttachmentCreateWithoutFileInput, CommentFileAttachmentUncheckedCreateWithoutFileInput> | CommentFileAttachmentCreateWithoutFileInput[] | CommentFileAttachmentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: CommentFileAttachmentCreateOrConnectWithoutFileInput | CommentFileAttachmentCreateOrConnectWithoutFileInput[]
    createMany?: CommentFileAttachmentCreateManyFileInputEnvelope
    connect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
  }

  export type PostFileAttachmentUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<PostFileAttachmentCreateWithoutFileInput, PostFileAttachmentUncheckedCreateWithoutFileInput> | PostFileAttachmentCreateWithoutFileInput[] | PostFileAttachmentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: PostFileAttachmentCreateOrConnectWithoutFileInput | PostFileAttachmentCreateOrConnectWithoutFileInput[]
    createMany?: PostFileAttachmentCreateManyFileInputEnvelope
    connect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
  }

  export type CommentFileAttachmentUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<CommentFileAttachmentCreateWithoutFileInput, CommentFileAttachmentUncheckedCreateWithoutFileInput> | CommentFileAttachmentCreateWithoutFileInput[] | CommentFileAttachmentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: CommentFileAttachmentCreateOrConnectWithoutFileInput | CommentFileAttachmentCreateOrConnectWithoutFileInput[]
    createMany?: CommentFileAttachmentCreateManyFileInputEnvelope
    connect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type MemberUpdateOneRequiredWithoutUploadedFilesNestedInput = {
    create?: XOR<MemberCreateWithoutUploadedFilesInput, MemberUncheckedCreateWithoutUploadedFilesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutUploadedFilesInput
    upsert?: MemberUpsertWithoutUploadedFilesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutUploadedFilesInput, MemberUpdateWithoutUploadedFilesInput>, MemberUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type PostFileAttachmentUpdateManyWithoutFileNestedInput = {
    create?: XOR<PostFileAttachmentCreateWithoutFileInput, PostFileAttachmentUncheckedCreateWithoutFileInput> | PostFileAttachmentCreateWithoutFileInput[] | PostFileAttachmentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: PostFileAttachmentCreateOrConnectWithoutFileInput | PostFileAttachmentCreateOrConnectWithoutFileInput[]
    upsert?: PostFileAttachmentUpsertWithWhereUniqueWithoutFileInput | PostFileAttachmentUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: PostFileAttachmentCreateManyFileInputEnvelope
    set?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    disconnect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    delete?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    connect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    update?: PostFileAttachmentUpdateWithWhereUniqueWithoutFileInput | PostFileAttachmentUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: PostFileAttachmentUpdateManyWithWhereWithoutFileInput | PostFileAttachmentUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: PostFileAttachmentScalarWhereInput | PostFileAttachmentScalarWhereInput[]
  }

  export type CommentFileAttachmentUpdateManyWithoutFileNestedInput = {
    create?: XOR<CommentFileAttachmentCreateWithoutFileInput, CommentFileAttachmentUncheckedCreateWithoutFileInput> | CommentFileAttachmentCreateWithoutFileInput[] | CommentFileAttachmentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: CommentFileAttachmentCreateOrConnectWithoutFileInput | CommentFileAttachmentCreateOrConnectWithoutFileInput[]
    upsert?: CommentFileAttachmentUpsertWithWhereUniqueWithoutFileInput | CommentFileAttachmentUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: CommentFileAttachmentCreateManyFileInputEnvelope
    set?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    disconnect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    delete?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    connect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    update?: CommentFileAttachmentUpdateWithWhereUniqueWithoutFileInput | CommentFileAttachmentUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: CommentFileAttachmentUpdateManyWithWhereWithoutFileInput | CommentFileAttachmentUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: CommentFileAttachmentScalarWhereInput | CommentFileAttachmentScalarWhereInput[]
  }

  export type PostFileAttachmentUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<PostFileAttachmentCreateWithoutFileInput, PostFileAttachmentUncheckedCreateWithoutFileInput> | PostFileAttachmentCreateWithoutFileInput[] | PostFileAttachmentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: PostFileAttachmentCreateOrConnectWithoutFileInput | PostFileAttachmentCreateOrConnectWithoutFileInput[]
    upsert?: PostFileAttachmentUpsertWithWhereUniqueWithoutFileInput | PostFileAttachmentUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: PostFileAttachmentCreateManyFileInputEnvelope
    set?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    disconnect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    delete?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    connect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    update?: PostFileAttachmentUpdateWithWhereUniqueWithoutFileInput | PostFileAttachmentUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: PostFileAttachmentUpdateManyWithWhereWithoutFileInput | PostFileAttachmentUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: PostFileAttachmentScalarWhereInput | PostFileAttachmentScalarWhereInput[]
  }

  export type CommentFileAttachmentUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<CommentFileAttachmentCreateWithoutFileInput, CommentFileAttachmentUncheckedCreateWithoutFileInput> | CommentFileAttachmentCreateWithoutFileInput[] | CommentFileAttachmentUncheckedCreateWithoutFileInput[]
    connectOrCreate?: CommentFileAttachmentCreateOrConnectWithoutFileInput | CommentFileAttachmentCreateOrConnectWithoutFileInput[]
    upsert?: CommentFileAttachmentUpsertWithWhereUniqueWithoutFileInput | CommentFileAttachmentUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: CommentFileAttachmentCreateManyFileInputEnvelope
    set?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    disconnect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    delete?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    connect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    update?: CommentFileAttachmentUpdateWithWhereUniqueWithoutFileInput | CommentFileAttachmentUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: CommentFileAttachmentUpdateManyWithWhereWithoutFileInput | CommentFileAttachmentUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: CommentFileAttachmentScalarWhereInput | CommentFileAttachmentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutFileAttachmentsInput = {
    create?: XOR<PostCreateWithoutFileAttachmentsInput, PostUncheckedCreateWithoutFileAttachmentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutFileAttachmentsInput
    connect?: PostWhereUniqueInput
  }

  export type FileCreateNestedOneWithoutPostAttachmentsInput = {
    create?: XOR<FileCreateWithoutPostAttachmentsInput, FileUncheckedCreateWithoutPostAttachmentsInput>
    connectOrCreate?: FileCreateOrConnectWithoutPostAttachmentsInput
    connect?: FileWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutFileAttachmentsNestedInput = {
    create?: XOR<PostCreateWithoutFileAttachmentsInput, PostUncheckedCreateWithoutFileAttachmentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutFileAttachmentsInput
    upsert?: PostUpsertWithoutFileAttachmentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutFileAttachmentsInput, PostUpdateWithoutFileAttachmentsInput>, PostUncheckedUpdateWithoutFileAttachmentsInput>
  }

  export type FileUpdateOneRequiredWithoutPostAttachmentsNestedInput = {
    create?: XOR<FileCreateWithoutPostAttachmentsInput, FileUncheckedCreateWithoutPostAttachmentsInput>
    connectOrCreate?: FileCreateOrConnectWithoutPostAttachmentsInput
    upsert?: FileUpsertWithoutPostAttachmentsInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutPostAttachmentsInput, FileUpdateWithoutPostAttachmentsInput>, FileUncheckedUpdateWithoutPostAttachmentsInput>
  }

  export type CommentCreateNestedOneWithoutFileAttachmentsInput = {
    create?: XOR<CommentCreateWithoutFileAttachmentsInput, CommentUncheckedCreateWithoutFileAttachmentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutFileAttachmentsInput
    connect?: CommentWhereUniqueInput
  }

  export type FileCreateNestedOneWithoutCommentAttachmentsInput = {
    create?: XOR<FileCreateWithoutCommentAttachmentsInput, FileUncheckedCreateWithoutCommentAttachmentsInput>
    connectOrCreate?: FileCreateOrConnectWithoutCommentAttachmentsInput
    connect?: FileWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutFileAttachmentsNestedInput = {
    create?: XOR<CommentCreateWithoutFileAttachmentsInput, CommentUncheckedCreateWithoutFileAttachmentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutFileAttachmentsInput
    upsert?: CommentUpsertWithoutFileAttachmentsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutFileAttachmentsInput, CommentUpdateWithoutFileAttachmentsInput>, CommentUncheckedUpdateWithoutFileAttachmentsInput>
  }

  export type FileUpdateOneRequiredWithoutCommentAttachmentsNestedInput = {
    create?: XOR<FileCreateWithoutCommentAttachmentsInput, FileUncheckedCreateWithoutCommentAttachmentsInput>
    connectOrCreate?: FileCreateOrConnectWithoutCommentAttachmentsInput
    upsert?: FileUpsertWithoutCommentAttachmentsInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutCommentAttachmentsInput, FileUpdateWithoutCommentAttachmentsInput>, FileUncheckedUpdateWithoutCommentAttachmentsInput>
  }

  export type PostCreateimageUrlsInput = {
    set: string[]
  }

  export type MemberCreateNestedOneWithoutPostsInput = {
    create?: XOR<MemberCreateWithoutPostsInput, MemberUncheckedCreateWithoutPostsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPostsInput
    connect?: MemberWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostLikeCreateNestedManyWithoutPostInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type PostFileAttachmentCreateNestedManyWithoutPostInput = {
    create?: XOR<PostFileAttachmentCreateWithoutPostInput, PostFileAttachmentUncheckedCreateWithoutPostInput> | PostFileAttachmentCreateWithoutPostInput[] | PostFileAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostFileAttachmentCreateOrConnectWithoutPostInput | PostFileAttachmentCreateOrConnectWithoutPostInput[]
    createMany?: PostFileAttachmentCreateManyPostInputEnvelope
    connect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostLikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type PostFileAttachmentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostFileAttachmentCreateWithoutPostInput, PostFileAttachmentUncheckedCreateWithoutPostInput> | PostFileAttachmentCreateWithoutPostInput[] | PostFileAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostFileAttachmentCreateOrConnectWithoutPostInput | PostFileAttachmentCreateOrConnectWithoutPostInput[]
    createMany?: PostFileAttachmentCreateManyPostInputEnvelope
    connect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
  }

  export type PostUpdateimageUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumPostVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.PostVisibility
  }

  export type MemberUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<MemberCreateWithoutPostsInput, MemberUncheckedCreateWithoutPostsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPostsInput
    upsert?: MemberUpsertWithoutPostsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutPostsInput, MemberUpdateWithoutPostsInput>, MemberUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostLikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type PostFileAttachmentUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostFileAttachmentCreateWithoutPostInput, PostFileAttachmentUncheckedCreateWithoutPostInput> | PostFileAttachmentCreateWithoutPostInput[] | PostFileAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostFileAttachmentCreateOrConnectWithoutPostInput | PostFileAttachmentCreateOrConnectWithoutPostInput[]
    upsert?: PostFileAttachmentUpsertWithWhereUniqueWithoutPostInput | PostFileAttachmentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostFileAttachmentCreateManyPostInputEnvelope
    set?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    disconnect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    delete?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    connect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    update?: PostFileAttachmentUpdateWithWhereUniqueWithoutPostInput | PostFileAttachmentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostFileAttachmentUpdateManyWithWhereWithoutPostInput | PostFileAttachmentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostFileAttachmentScalarWhereInput | PostFileAttachmentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostLikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type PostFileAttachmentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostFileAttachmentCreateWithoutPostInput, PostFileAttachmentUncheckedCreateWithoutPostInput> | PostFileAttachmentCreateWithoutPostInput[] | PostFileAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostFileAttachmentCreateOrConnectWithoutPostInput | PostFileAttachmentCreateOrConnectWithoutPostInput[]
    upsert?: PostFileAttachmentUpsertWithWhereUniqueWithoutPostInput | PostFileAttachmentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostFileAttachmentCreateManyPostInputEnvelope
    set?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    disconnect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    delete?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    connect?: PostFileAttachmentWhereUniqueInput | PostFileAttachmentWhereUniqueInput[]
    update?: PostFileAttachmentUpdateWithWhereUniqueWithoutPostInput | PostFileAttachmentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostFileAttachmentUpdateManyWithWhereWithoutPostInput | PostFileAttachmentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostFileAttachmentScalarWhereInput | PostFileAttachmentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutCommentsInput = {
    create?: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentsInput
    connect?: MemberWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentLikeCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentLikeCreateWithoutCommentInput, CommentLikeUncheckedCreateWithoutCommentInput> | CommentLikeCreateWithoutCommentInput[] | CommentLikeUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentLikeCreateOrConnectWithoutCommentInput | CommentLikeCreateOrConnectWithoutCommentInput[]
    createMany?: CommentLikeCreateManyCommentInputEnvelope
    connect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
  }

  export type CommentFileAttachmentCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentFileAttachmentCreateWithoutCommentInput, CommentFileAttachmentUncheckedCreateWithoutCommentInput> | CommentFileAttachmentCreateWithoutCommentInput[] | CommentFileAttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentFileAttachmentCreateOrConnectWithoutCommentInput | CommentFileAttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: CommentFileAttachmentCreateManyCommentInputEnvelope
    connect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentLikeUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentLikeCreateWithoutCommentInput, CommentLikeUncheckedCreateWithoutCommentInput> | CommentLikeCreateWithoutCommentInput[] | CommentLikeUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentLikeCreateOrConnectWithoutCommentInput | CommentLikeCreateOrConnectWithoutCommentInput[]
    createMany?: CommentLikeCreateManyCommentInputEnvelope
    connect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
  }

  export type CommentFileAttachmentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentFileAttachmentCreateWithoutCommentInput, CommentFileAttachmentUncheckedCreateWithoutCommentInput> | CommentFileAttachmentCreateWithoutCommentInput[] | CommentFileAttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentFileAttachmentCreateOrConnectWithoutCommentInput | CommentFileAttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: CommentFileAttachmentCreateManyCommentInputEnvelope
    connect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type MemberUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentsInput
    upsert?: MemberUpsertWithoutCommentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCommentsInput, MemberUpdateWithoutCommentsInput>, MemberUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentCommentInput | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentCommentInput | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentCommentInput | CommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentLikeUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentLikeCreateWithoutCommentInput, CommentLikeUncheckedCreateWithoutCommentInput> | CommentLikeCreateWithoutCommentInput[] | CommentLikeUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentLikeCreateOrConnectWithoutCommentInput | CommentLikeCreateOrConnectWithoutCommentInput[]
    upsert?: CommentLikeUpsertWithWhereUniqueWithoutCommentInput | CommentLikeUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentLikeCreateManyCommentInputEnvelope
    set?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    disconnect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    delete?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    connect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    update?: CommentLikeUpdateWithWhereUniqueWithoutCommentInput | CommentLikeUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentLikeUpdateManyWithWhereWithoutCommentInput | CommentLikeUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentLikeScalarWhereInput | CommentLikeScalarWhereInput[]
  }

  export type CommentFileAttachmentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentFileAttachmentCreateWithoutCommentInput, CommentFileAttachmentUncheckedCreateWithoutCommentInput> | CommentFileAttachmentCreateWithoutCommentInput[] | CommentFileAttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentFileAttachmentCreateOrConnectWithoutCommentInput | CommentFileAttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: CommentFileAttachmentUpsertWithWhereUniqueWithoutCommentInput | CommentFileAttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentFileAttachmentCreateManyCommentInputEnvelope
    set?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    disconnect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    delete?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    connect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    update?: CommentFileAttachmentUpdateWithWhereUniqueWithoutCommentInput | CommentFileAttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentFileAttachmentUpdateManyWithWhereWithoutCommentInput | CommentFileAttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentFileAttachmentScalarWhereInput | CommentFileAttachmentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentCommentInput | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentCommentInput | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentCommentInput | CommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentLikeUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentLikeCreateWithoutCommentInput, CommentLikeUncheckedCreateWithoutCommentInput> | CommentLikeCreateWithoutCommentInput[] | CommentLikeUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentLikeCreateOrConnectWithoutCommentInput | CommentLikeCreateOrConnectWithoutCommentInput[]
    upsert?: CommentLikeUpsertWithWhereUniqueWithoutCommentInput | CommentLikeUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentLikeCreateManyCommentInputEnvelope
    set?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    disconnect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    delete?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    connect?: CommentLikeWhereUniqueInput | CommentLikeWhereUniqueInput[]
    update?: CommentLikeUpdateWithWhereUniqueWithoutCommentInput | CommentLikeUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentLikeUpdateManyWithWhereWithoutCommentInput | CommentLikeUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentLikeScalarWhereInput | CommentLikeScalarWhereInput[]
  }

  export type CommentFileAttachmentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentFileAttachmentCreateWithoutCommentInput, CommentFileAttachmentUncheckedCreateWithoutCommentInput> | CommentFileAttachmentCreateWithoutCommentInput[] | CommentFileAttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentFileAttachmentCreateOrConnectWithoutCommentInput | CommentFileAttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: CommentFileAttachmentUpsertWithWhereUniqueWithoutCommentInput | CommentFileAttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentFileAttachmentCreateManyCommentInputEnvelope
    set?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    disconnect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    delete?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    connect?: CommentFileAttachmentWhereUniqueInput | CommentFileAttachmentWhereUniqueInput[]
    update?: CommentFileAttachmentUpdateWithWhereUniqueWithoutCommentInput | CommentFileAttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentFileAttachmentUpdateManyWithWhereWithoutCommentInput | CommentFileAttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentFileAttachmentScalarWhereInput | CommentFileAttachmentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    connect?: PostWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutPostLikesInput = {
    create?: XOR<MemberCreateWithoutPostLikesInput, MemberUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPostLikesInput
    connect?: MemberWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    upsert?: PostUpsertWithoutLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutLikesInput, PostUpdateWithoutLikesInput>, PostUncheckedUpdateWithoutLikesInput>
  }

  export type MemberUpdateOneRequiredWithoutPostLikesNestedInput = {
    create?: XOR<MemberCreateWithoutPostLikesInput, MemberUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPostLikesInput
    upsert?: MemberUpsertWithoutPostLikesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutPostLikesInput, MemberUpdateWithoutPostLikesInput>, MemberUncheckedUpdateWithoutPostLikesInput>
  }

  export type CommentCreateNestedOneWithoutLikesInput = {
    create?: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutLikesInput
    connect?: CommentWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutCommentLikesInput = {
    create?: XOR<MemberCreateWithoutCommentLikesInput, MemberUncheckedCreateWithoutCommentLikesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentLikesInput
    connect?: MemberWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutLikesInput
    upsert?: CommentUpsertWithoutLikesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutLikesInput, CommentUpdateWithoutLikesInput>, CommentUncheckedUpdateWithoutLikesInput>
  }

  export type MemberUpdateOneRequiredWithoutCommentLikesNestedInput = {
    create?: XOR<MemberCreateWithoutCommentLikesInput, MemberUncheckedCreateWithoutCommentLikesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentLikesInput
    upsert?: MemberUpsertWithoutCommentLikesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCommentLikesInput, MemberUpdateWithoutCommentLikesInput>, MemberUncheckedUpdateWithoutCommentLikesInput>
  }

  export type MemberCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<MemberCreateWithoutNotificationsInput, MemberUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutNotificationsInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutTriggeredNotificationsInput = {
    create?: XOR<MemberCreateWithoutTriggeredNotificationsInput, MemberUncheckedCreateWithoutTriggeredNotificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutTriggeredNotificationsInput
    connect?: MemberWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type MemberUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<MemberCreateWithoutNotificationsInput, MemberUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutNotificationsInput
    upsert?: MemberUpsertWithoutNotificationsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutNotificationsInput, MemberUpdateWithoutNotificationsInput>, MemberUncheckedUpdateWithoutNotificationsInput>
  }

  export type MemberUpdateOneWithoutTriggeredNotificationsNestedInput = {
    create?: XOR<MemberCreateWithoutTriggeredNotificationsInput, MemberUncheckedCreateWithoutTriggeredNotificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutTriggeredNotificationsInput
    upsert?: MemberUpsertWithoutTriggeredNotificationsInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutTriggeredNotificationsInput, MemberUpdateWithoutTriggeredNotificationsInput>, MemberUncheckedUpdateWithoutTriggeredNotificationsInput>
  }

  export type FamilyMembershipCreateNestedOneWithoutFamilyMemberPermissionsInput = {
    create?: XOR<FamilyMembershipCreateWithoutFamilyMemberPermissionsInput, FamilyMembershipUncheckedCreateWithoutFamilyMemberPermissionsInput>
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutFamilyMemberPermissionsInput
    connect?: FamilyMembershipWhereUniqueInput
  }

  export type FamilyMembershipUpdateOneRequiredWithoutFamilyMemberPermissionsNestedInput = {
    create?: XOR<FamilyMembershipCreateWithoutFamilyMemberPermissionsInput, FamilyMembershipUncheckedCreateWithoutFamilyMemberPermissionsInput>
    connectOrCreate?: FamilyMembershipCreateOrConnectWithoutFamilyMemberPermissionsInput
    upsert?: FamilyMembershipUpsertWithoutFamilyMemberPermissionsInput
    connect?: FamilyMembershipWhereUniqueInput
    update?: XOR<XOR<FamilyMembershipUpdateToOneWithWhereWithoutFamilyMemberPermissionsInput, FamilyMembershipUpdateWithoutFamilyMemberPermissionsInput>, FamilyMembershipUncheckedUpdateWithoutFamilyMemberPermissionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumFamilyRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.FamilyRole | EnumFamilyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.FamilyRole[] | ListEnumFamilyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.FamilyRole[] | ListEnumFamilyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumFamilyRoleFilter<$PrismaModel> | $Enums.FamilyRole
  }

  export type NestedEnumMembershipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipType | EnumMembershipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipType[] | ListEnumMembershipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipType[] | ListEnumMembershipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipTypeFilter<$PrismaModel> | $Enums.MembershipType
  }

  export type NestedEnumFamilyRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FamilyRole | EnumFamilyRoleFieldRefInput<$PrismaModel>
    in?: $Enums.FamilyRole[] | ListEnumFamilyRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.FamilyRole[] | ListEnumFamilyRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumFamilyRoleWithAggregatesFilter<$PrismaModel> | $Enums.FamilyRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFamilyRoleFilter<$PrismaModel>
    _max?: NestedEnumFamilyRoleFilter<$PrismaModel>
  }

  export type NestedEnumMembershipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipType | EnumMembershipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipType[] | ListEnumMembershipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipType[] | ListEnumMembershipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipTypeWithAggregatesFilter<$PrismaModel> | $Enums.MembershipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembershipTypeFilter<$PrismaModel>
    _max?: NestedEnumMembershipTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type MemberCreateWithoutUserInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type InvitationCreateWithoutInviterUserInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
    family: FamilyCreateNestedOneWithoutInvitationsInput
    inviterMember?: MemberCreateNestedOneWithoutSentInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutInviterUserInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    familyId: string
    inviterMemberId?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationCreateOrConnectWithoutInviterUserInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutInviterUserInput, InvitationUncheckedCreateWithoutInviterUserInput>
  }

  export type InvitationCreateManyInviterUserInputEnvelope = {
    data: InvitationCreateManyInviterUserInput | InvitationCreateManyInviterUserInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutUserInput = {
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutUserInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type InvitationUpsertWithWhereUniqueWithoutInviterUserInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutInviterUserInput, InvitationUncheckedUpdateWithoutInviterUserInput>
    create: XOR<InvitationCreateWithoutInviterUserInput, InvitationUncheckedCreateWithoutInviterUserInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutInviterUserInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutInviterUserInput, InvitationUncheckedUpdateWithoutInviterUserInput>
  }

  export type InvitationUpdateManyWithWhereWithoutInviterUserInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutInviterUserInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    code?: StringFilter<"Invitation"> | string
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    usedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    acceptedBy?: StringNullableFilter<"Invitation"> | string | null
    familyId?: StringFilter<"Invitation"> | string
    inviterUserId?: StringNullableFilter<"Invitation"> | string | null
    inviterMemberId?: StringNullableFilter<"Invitation"> | string | null
    memberStub?: JsonNullableFilter<"Invitation">
  }

  export type MemberCreateWithoutChildrenInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutChildrenInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutChildrenInput, MemberUncheckedCreateWithoutChildrenInput>
  }

  export type MemberCreateWithoutParentsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutParentsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutParentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutParentsInput, MemberUncheckedCreateWithoutParentsInput>
  }

  export type MemberCreateWithoutSpousesReverseInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutSpousesReverseInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutSpousesReverseInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSpousesReverseInput, MemberUncheckedCreateWithoutSpousesReverseInput>
  }

  export type MemberCreateWithoutSpousesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutSpousesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutSpousesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSpousesInput, MemberUncheckedCreateWithoutSpousesInput>
  }

  export type FamilyMembershipCreateWithoutMemberInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
    family: FamilyCreateNestedOneWithoutMembershipsInput
    familyMemberPermissions?: FamilyMemberPermissionCreateNestedManyWithoutFamilyMemberInput
  }

  export type FamilyMembershipUncheckedCreateWithoutMemberInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    familyId: string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
    familyMemberPermissions?: FamilyMemberPermissionUncheckedCreateNestedManyWithoutFamilyMemberInput
  }

  export type FamilyMembershipCreateOrConnectWithoutMemberInput = {
    where: FamilyMembershipWhereUniqueInput
    create: XOR<FamilyMembershipCreateWithoutMemberInput, FamilyMembershipUncheckedCreateWithoutMemberInput>
  }

  export type FamilyMembershipCreateManyMemberInputEnvelope = {
    data: FamilyMembershipCreateManyMemberInput | FamilyMembershipCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutMemberInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password: string
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sentInvitations?: InvitationCreateNestedManyWithoutInviterUserInput
  }

  export type UserUncheckedCreateWithoutMemberInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password: string
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterUserInput
  }

  export type UserCreateOrConnectWithoutMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
  }

  export type InvitationCreateWithoutInviterMemberInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
    family: FamilyCreateNestedOneWithoutInvitationsInput
    inviterUser?: UserCreateNestedOneWithoutSentInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutInviterMemberInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    familyId: string
    inviterUserId?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationCreateOrConnectWithoutInviterMemberInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutInviterMemberInput, InvitationUncheckedCreateWithoutInviterMemberInput>
  }

  export type InvitationCreateManyInviterMemberInputEnvelope = {
    data: InvitationCreateManyInviterMemberInput | InvitationCreateManyInviterMemberInput[]
    skipDuplicates?: boolean
  }

  export type FamilyCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    headOfFamily?: MemberCreateNestedOneWithoutHeadedFamiliesInput
    parentFamily?: FamilyCreateNestedOneWithoutSubFamiliesInput
    subFamilies?: FamilyCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipCreateNestedManyWithoutFamilyInput
    invitations?: InvitationCreateNestedManyWithoutFamilyInput
  }

  export type FamilyUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    headOfFamilyId?: string | null
    parentFamilyId?: string | null
    subFamilies?: FamilyUncheckedCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipUncheckedCreateNestedManyWithoutFamilyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutFamilyInput
  }

  export type FamilyCreateOrConnectWithoutCreatorInput = {
    where: FamilyWhereUniqueInput
    create: XOR<FamilyCreateWithoutCreatorInput, FamilyUncheckedCreateWithoutCreatorInput>
  }

  export type FamilyCreateManyCreatorInputEnvelope = {
    data: FamilyCreateManyCreatorInput | FamilyCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type FamilyCreateWithoutHeadOfFamilyInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutCreatedFamiliesInput
    parentFamily?: FamilyCreateNestedOneWithoutSubFamiliesInput
    subFamilies?: FamilyCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipCreateNestedManyWithoutFamilyInput
    invitations?: InvitationCreateNestedManyWithoutFamilyInput
  }

  export type FamilyUncheckedCreateWithoutHeadOfFamilyInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    parentFamilyId?: string | null
    subFamilies?: FamilyUncheckedCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipUncheckedCreateNestedManyWithoutFamilyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutFamilyInput
  }

  export type FamilyCreateOrConnectWithoutHeadOfFamilyInput = {
    where: FamilyWhereUniqueInput
    create: XOR<FamilyCreateWithoutHeadOfFamilyInput, FamilyUncheckedCreateWithoutHeadOfFamilyInput>
  }

  export type FamilyCreateManyHeadOfFamilyInputEnvelope = {
    data: FamilyCreateManyHeadOfFamilyInput | FamilyCreateManyHeadOfFamilyInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    fileAttachments?: PostFileAttachmentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    fileAttachments?: PostFileAttachmentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likesCount?: number
    post: PostCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    parentCommentId?: string | null
    likesCount?: number
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeUncheckedCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PostLikeCreateWithoutMemberInput = {
    id?: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutLikesInput
  }

  export type PostLikeUncheckedCreateWithoutMemberInput = {
    id?: string
    createdAt?: Date | string
    postId: string
  }

  export type PostLikeCreateOrConnectWithoutMemberInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutMemberInput, PostLikeUncheckedCreateWithoutMemberInput>
  }

  export type PostLikeCreateManyMemberInputEnvelope = {
    data: PostLikeCreateManyMemberInput | PostLikeCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type CommentLikeCreateWithoutMemberInput = {
    id?: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutLikesInput
  }

  export type CommentLikeUncheckedCreateWithoutMemberInput = {
    id?: string
    createdAt?: Date | string
    commentId: string
  }

  export type CommentLikeCreateOrConnectWithoutMemberInput = {
    where: CommentLikeWhereUniqueInput
    create: XOR<CommentLikeCreateWithoutMemberInput, CommentLikeUncheckedCreateWithoutMemberInput>
  }

  export type CommentLikeCreateManyMemberInputEnvelope = {
    data: CommentLikeCreateManyMemberInput | CommentLikeCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutMemberInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    relatedMember?: MemberCreateNestedOneWithoutTriggeredNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutMemberInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    relatedMemberId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateOrConnectWithoutMemberInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutMemberInput, NotificationUncheckedCreateWithoutMemberInput>
  }

  export type NotificationCreateManyMemberInputEnvelope = {
    data: NotificationCreateManyMemberInput | NotificationCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRelatedMemberInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    member: MemberCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRelatedMemberInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    memberId: string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateOrConnectWithoutRelatedMemberInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRelatedMemberInput, NotificationUncheckedCreateWithoutRelatedMemberInput>
  }

  export type NotificationCreateManyRelatedMemberInputEnvelope = {
    data: NotificationCreateManyRelatedMemberInput | NotificationCreateManyRelatedMemberInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutUploaderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    postAttachments?: PostFileAttachmentCreateNestedManyWithoutFileInput
    commentAttachments?: CommentFileAttachmentCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutUploaderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    postAttachments?: PostFileAttachmentUncheckedCreateNestedManyWithoutFileInput
    commentAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutUploaderInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput>
  }

  export type FileCreateManyUploaderInputEnvelope = {
    data: FileCreateManyUploaderInput | FileCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutChildrenInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutChildrenInput, MemberUncheckedUpdateWithoutChildrenInput>
    create: XOR<MemberCreateWithoutChildrenInput, MemberUncheckedCreateWithoutChildrenInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutChildrenInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutChildrenInput, MemberUncheckedUpdateWithoutChildrenInput>
  }

  export type MemberUpdateManyWithWhereWithoutChildrenInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutChildrenInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    gender?: EnumGenderNullableFilter<"Member"> | $Enums.Gender | null
    status?: EnumMemberStatusFilter<"Member"> | $Enums.MemberStatus
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    personalInfo?: JsonNullableFilter<"Member">
    color?: StringNullableFilter<"Member"> | string | null
    parentColors?: StringNullableListFilter<"Member">
  }

  export type MemberUpsertWithWhereUniqueWithoutParentsInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutParentsInput, MemberUncheckedUpdateWithoutParentsInput>
    create: XOR<MemberCreateWithoutParentsInput, MemberUncheckedCreateWithoutParentsInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutParentsInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutParentsInput, MemberUncheckedUpdateWithoutParentsInput>
  }

  export type MemberUpdateManyWithWhereWithoutParentsInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutParentsInput>
  }

  export type MemberUpsertWithWhereUniqueWithoutSpousesReverseInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutSpousesReverseInput, MemberUncheckedUpdateWithoutSpousesReverseInput>
    create: XOR<MemberCreateWithoutSpousesReverseInput, MemberUncheckedCreateWithoutSpousesReverseInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutSpousesReverseInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutSpousesReverseInput, MemberUncheckedUpdateWithoutSpousesReverseInput>
  }

  export type MemberUpdateManyWithWhereWithoutSpousesReverseInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutSpousesReverseInput>
  }

  export type MemberUpsertWithWhereUniqueWithoutSpousesInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutSpousesInput, MemberUncheckedUpdateWithoutSpousesInput>
    create: XOR<MemberCreateWithoutSpousesInput, MemberUncheckedCreateWithoutSpousesInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutSpousesInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutSpousesInput, MemberUncheckedUpdateWithoutSpousesInput>
  }

  export type MemberUpdateManyWithWhereWithoutSpousesInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutSpousesInput>
  }

  export type FamilyMembershipUpsertWithWhereUniqueWithoutMemberInput = {
    where: FamilyMembershipWhereUniqueInput
    update: XOR<FamilyMembershipUpdateWithoutMemberInput, FamilyMembershipUncheckedUpdateWithoutMemberInput>
    create: XOR<FamilyMembershipCreateWithoutMemberInput, FamilyMembershipUncheckedCreateWithoutMemberInput>
  }

  export type FamilyMembershipUpdateWithWhereUniqueWithoutMemberInput = {
    where: FamilyMembershipWhereUniqueInput
    data: XOR<FamilyMembershipUpdateWithoutMemberInput, FamilyMembershipUncheckedUpdateWithoutMemberInput>
  }

  export type FamilyMembershipUpdateManyWithWhereWithoutMemberInput = {
    where: FamilyMembershipScalarWhereInput
    data: XOR<FamilyMembershipUpdateManyMutationInput, FamilyMembershipUncheckedUpdateManyWithoutMemberInput>
  }

  export type FamilyMembershipScalarWhereInput = {
    AND?: FamilyMembershipScalarWhereInput | FamilyMembershipScalarWhereInput[]
    OR?: FamilyMembershipScalarWhereInput[]
    NOT?: FamilyMembershipScalarWhereInput | FamilyMembershipScalarWhereInput[]
    id?: StringFilter<"FamilyMembership"> | string
    createdAt?: DateTimeFilter<"FamilyMembership"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMembership"> | Date | string
    memberId?: StringFilter<"FamilyMembership"> | string
    familyId?: StringFilter<"FamilyMembership"> | string
    role?: EnumFamilyRoleFilter<"FamilyMembership"> | $Enums.FamilyRole
    type?: EnumMembershipTypeFilter<"FamilyMembership"> | $Enums.MembershipType
    autoEnrolled?: BoolFilter<"FamilyMembership"> | boolean
    manuallyEdited?: BoolFilter<"FamilyMembership"> | boolean
    isActive?: BoolFilter<"FamilyMembership"> | boolean
    joinDate?: DateTimeFilter<"FamilyMembership"> | Date | string
  }

  export type UserUpsertWithoutMemberInput = {
    update: XOR<UserUpdateWithoutMemberInput, UserUncheckedUpdateWithoutMemberInput>
    create: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMemberInput, UserUncheckedUpdateWithoutMemberInput>
  }

  export type UserUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentInvitations?: InvitationUpdateManyWithoutInviterUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterUserNestedInput
  }

  export type InvitationUpsertWithWhereUniqueWithoutInviterMemberInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutInviterMemberInput, InvitationUncheckedUpdateWithoutInviterMemberInput>
    create: XOR<InvitationCreateWithoutInviterMemberInput, InvitationUncheckedCreateWithoutInviterMemberInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutInviterMemberInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutInviterMemberInput, InvitationUncheckedUpdateWithoutInviterMemberInput>
  }

  export type InvitationUpdateManyWithWhereWithoutInviterMemberInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutInviterMemberInput>
  }

  export type FamilyUpsertWithWhereUniqueWithoutCreatorInput = {
    where: FamilyWhereUniqueInput
    update: XOR<FamilyUpdateWithoutCreatorInput, FamilyUncheckedUpdateWithoutCreatorInput>
    create: XOR<FamilyCreateWithoutCreatorInput, FamilyUncheckedCreateWithoutCreatorInput>
  }

  export type FamilyUpdateWithWhereUniqueWithoutCreatorInput = {
    where: FamilyWhereUniqueInput
    data: XOR<FamilyUpdateWithoutCreatorInput, FamilyUncheckedUpdateWithoutCreatorInput>
  }

  export type FamilyUpdateManyWithWhereWithoutCreatorInput = {
    where: FamilyScalarWhereInput
    data: XOR<FamilyUpdateManyMutationInput, FamilyUncheckedUpdateManyWithoutCreatorInput>
  }

  export type FamilyScalarWhereInput = {
    AND?: FamilyScalarWhereInput | FamilyScalarWhereInput[]
    OR?: FamilyScalarWhereInput[]
    NOT?: FamilyScalarWhereInput | FamilyScalarWhereInput[]
    id?: StringFilter<"Family"> | string
    name?: StringFilter<"Family"> | string
    description?: StringNullableFilter<"Family"> | string | null
    isSubFamily?: BoolFilter<"Family"> | boolean
    deletedAt?: DateTimeNullableFilter<"Family"> | Date | string | null
    createdAt?: DateTimeFilter<"Family"> | Date | string
    updatedAt?: DateTimeFilter<"Family"> | Date | string
    creatorId?: StringFilter<"Family"> | string
    headOfFamilyId?: StringNullableFilter<"Family"> | string | null
    parentFamilyId?: StringNullableFilter<"Family"> | string | null
  }

  export type FamilyUpsertWithWhereUniqueWithoutHeadOfFamilyInput = {
    where: FamilyWhereUniqueInput
    update: XOR<FamilyUpdateWithoutHeadOfFamilyInput, FamilyUncheckedUpdateWithoutHeadOfFamilyInput>
    create: XOR<FamilyCreateWithoutHeadOfFamilyInput, FamilyUncheckedCreateWithoutHeadOfFamilyInput>
  }

  export type FamilyUpdateWithWhereUniqueWithoutHeadOfFamilyInput = {
    where: FamilyWhereUniqueInput
    data: XOR<FamilyUpdateWithoutHeadOfFamilyInput, FamilyUncheckedUpdateWithoutHeadOfFamilyInput>
  }

  export type FamilyUpdateManyWithWhereWithoutHeadOfFamilyInput = {
    where: FamilyScalarWhereInput
    data: XOR<FamilyUpdateManyMutationInput, FamilyUncheckedUpdateManyWithoutHeadOfFamilyInput>
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    imageUrls?: StringNullableListFilter<"Post">
    videoUrl?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    authorId?: StringFilter<"Post"> | string
    familyId?: StringNullableFilter<"Post"> | string | null
    likesCount?: IntFilter<"Post"> | number
    editHistory?: JsonNullableFilter<"Post">
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    imageUrl?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
    likesCount?: IntFilter<"Comment"> | number
  }

  export type PostLikeUpsertWithWhereUniqueWithoutMemberInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutMemberInput, PostLikeUncheckedUpdateWithoutMemberInput>
    create: XOR<PostLikeCreateWithoutMemberInput, PostLikeUncheckedCreateWithoutMemberInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutMemberInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutMemberInput, PostLikeUncheckedUpdateWithoutMemberInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutMemberInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutMemberInput>
  }

  export type PostLikeScalarWhereInput = {
    AND?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
    OR?: PostLikeScalarWhereInput[]
    NOT?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
    id?: StringFilter<"PostLike"> | string
    createdAt?: DateTimeFilter<"PostLike"> | Date | string
    postId?: StringFilter<"PostLike"> | string
    memberId?: StringFilter<"PostLike"> | string
  }

  export type CommentLikeUpsertWithWhereUniqueWithoutMemberInput = {
    where: CommentLikeWhereUniqueInput
    update: XOR<CommentLikeUpdateWithoutMemberInput, CommentLikeUncheckedUpdateWithoutMemberInput>
    create: XOR<CommentLikeCreateWithoutMemberInput, CommentLikeUncheckedCreateWithoutMemberInput>
  }

  export type CommentLikeUpdateWithWhereUniqueWithoutMemberInput = {
    where: CommentLikeWhereUniqueInput
    data: XOR<CommentLikeUpdateWithoutMemberInput, CommentLikeUncheckedUpdateWithoutMemberInput>
  }

  export type CommentLikeUpdateManyWithWhereWithoutMemberInput = {
    where: CommentLikeScalarWhereInput
    data: XOR<CommentLikeUpdateManyMutationInput, CommentLikeUncheckedUpdateManyWithoutMemberInput>
  }

  export type CommentLikeScalarWhereInput = {
    AND?: CommentLikeScalarWhereInput | CommentLikeScalarWhereInput[]
    OR?: CommentLikeScalarWhereInput[]
    NOT?: CommentLikeScalarWhereInput | CommentLikeScalarWhereInput[]
    id?: StringFilter<"CommentLike"> | string
    createdAt?: DateTimeFilter<"CommentLike"> | Date | string
    commentId?: StringFilter<"CommentLike"> | string
    memberId?: StringFilter<"CommentLike"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutMemberInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutMemberInput, NotificationUncheckedUpdateWithoutMemberInput>
    create: XOR<NotificationCreateWithoutMemberInput, NotificationUncheckedCreateWithoutMemberInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutMemberInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutMemberInput, NotificationUncheckedUpdateWithoutMemberInput>
  }

  export type NotificationUpdateManyWithWhereWithoutMemberInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutMemberInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    memberId?: StringFilter<"Notification"> | string
    relatedPostId?: StringNullableFilter<"Notification"> | string | null
    relatedCommentId?: StringNullableFilter<"Notification"> | string | null
    relatedMemberId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
  }

  export type NotificationUpsertWithWhereUniqueWithoutRelatedMemberInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRelatedMemberInput, NotificationUncheckedUpdateWithoutRelatedMemberInput>
    create: XOR<NotificationCreateWithoutRelatedMemberInput, NotificationUncheckedCreateWithoutRelatedMemberInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRelatedMemberInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRelatedMemberInput, NotificationUncheckedUpdateWithoutRelatedMemberInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRelatedMemberInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRelatedMemberInput>
  }

  export type FileUpsertWithWhereUniqueWithoutUploaderInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUploaderInput, FileUncheckedUpdateWithoutUploaderInput>
    create: XOR<FileCreateWithoutUploaderInput, FileUncheckedCreateWithoutUploaderInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUploaderInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUploaderInput, FileUncheckedUpdateWithoutUploaderInput>
  }

  export type FileUpdateManyWithWhereWithoutUploaderInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUploaderInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    url?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    uploadedBy?: StringFilter<"File"> | string
  }

  export type MemberCreateWithoutCreatedFamiliesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutCreatedFamiliesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutCreatedFamiliesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCreatedFamiliesInput, MemberUncheckedCreateWithoutCreatedFamiliesInput>
  }

  export type MemberCreateWithoutHeadedFamiliesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutHeadedFamiliesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutHeadedFamiliesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutHeadedFamiliesInput, MemberUncheckedCreateWithoutHeadedFamiliesInput>
  }

  export type FamilyCreateWithoutSubFamiliesInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutCreatedFamiliesInput
    headOfFamily?: MemberCreateNestedOneWithoutHeadedFamiliesInput
    parentFamily?: FamilyCreateNestedOneWithoutSubFamiliesInput
    memberships?: FamilyMembershipCreateNestedManyWithoutFamilyInput
    invitations?: InvitationCreateNestedManyWithoutFamilyInput
  }

  export type FamilyUncheckedCreateWithoutSubFamiliesInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    headOfFamilyId?: string | null
    parentFamilyId?: string | null
    memberships?: FamilyMembershipUncheckedCreateNestedManyWithoutFamilyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutFamilyInput
  }

  export type FamilyCreateOrConnectWithoutSubFamiliesInput = {
    where: FamilyWhereUniqueInput
    create: XOR<FamilyCreateWithoutSubFamiliesInput, FamilyUncheckedCreateWithoutSubFamiliesInput>
  }

  export type FamilyCreateWithoutParentFamilyInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutCreatedFamiliesInput
    headOfFamily?: MemberCreateNestedOneWithoutHeadedFamiliesInput
    subFamilies?: FamilyCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipCreateNestedManyWithoutFamilyInput
    invitations?: InvitationCreateNestedManyWithoutFamilyInput
  }

  export type FamilyUncheckedCreateWithoutParentFamilyInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    headOfFamilyId?: string | null
    subFamilies?: FamilyUncheckedCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipUncheckedCreateNestedManyWithoutFamilyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutFamilyInput
  }

  export type FamilyCreateOrConnectWithoutParentFamilyInput = {
    where: FamilyWhereUniqueInput
    create: XOR<FamilyCreateWithoutParentFamilyInput, FamilyUncheckedCreateWithoutParentFamilyInput>
  }

  export type FamilyCreateManyParentFamilyInputEnvelope = {
    data: FamilyCreateManyParentFamilyInput | FamilyCreateManyParentFamilyInput[]
    skipDuplicates?: boolean
  }

  export type FamilyMembershipCreateWithoutFamilyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
    member: MemberCreateNestedOneWithoutFamilyMembershipsInput
    familyMemberPermissions?: FamilyMemberPermissionCreateNestedManyWithoutFamilyMemberInput
  }

  export type FamilyMembershipUncheckedCreateWithoutFamilyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
    familyMemberPermissions?: FamilyMemberPermissionUncheckedCreateNestedManyWithoutFamilyMemberInput
  }

  export type FamilyMembershipCreateOrConnectWithoutFamilyInput = {
    where: FamilyMembershipWhereUniqueInput
    create: XOR<FamilyMembershipCreateWithoutFamilyInput, FamilyMembershipUncheckedCreateWithoutFamilyInput>
  }

  export type FamilyMembershipCreateManyFamilyInputEnvelope = {
    data: FamilyMembershipCreateManyFamilyInput | FamilyMembershipCreateManyFamilyInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutFamilyInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
    inviterUser?: UserCreateNestedOneWithoutSentInvitationsInput
    inviterMember?: MemberCreateNestedOneWithoutSentInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutFamilyInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    inviterUserId?: string | null
    inviterMemberId?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationCreateOrConnectWithoutFamilyInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutFamilyInput, InvitationUncheckedCreateWithoutFamilyInput>
  }

  export type InvitationCreateManyFamilyInputEnvelope = {
    data: InvitationCreateManyFamilyInput | InvitationCreateManyFamilyInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutCreatedFamiliesInput = {
    update: XOR<MemberUpdateWithoutCreatedFamiliesInput, MemberUncheckedUpdateWithoutCreatedFamiliesInput>
    create: XOR<MemberCreateWithoutCreatedFamiliesInput, MemberUncheckedCreateWithoutCreatedFamiliesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCreatedFamiliesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCreatedFamiliesInput, MemberUncheckedUpdateWithoutCreatedFamiliesInput>
  }

  export type MemberUpdateWithoutCreatedFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutCreatedFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUpsertWithoutHeadedFamiliesInput = {
    update: XOR<MemberUpdateWithoutHeadedFamiliesInput, MemberUncheckedUpdateWithoutHeadedFamiliesInput>
    create: XOR<MemberCreateWithoutHeadedFamiliesInput, MemberUncheckedCreateWithoutHeadedFamiliesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutHeadedFamiliesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutHeadedFamiliesInput, MemberUncheckedUpdateWithoutHeadedFamiliesInput>
  }

  export type MemberUpdateWithoutHeadedFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutHeadedFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type FamilyUpsertWithoutSubFamiliesInput = {
    update: XOR<FamilyUpdateWithoutSubFamiliesInput, FamilyUncheckedUpdateWithoutSubFamiliesInput>
    create: XOR<FamilyCreateWithoutSubFamiliesInput, FamilyUncheckedCreateWithoutSubFamiliesInput>
    where?: FamilyWhereInput
  }

  export type FamilyUpdateToOneWithWhereWithoutSubFamiliesInput = {
    where?: FamilyWhereInput
    data: XOR<FamilyUpdateWithoutSubFamiliesInput, FamilyUncheckedUpdateWithoutSubFamiliesInput>
  }

  export type FamilyUpdateWithoutSubFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutCreatedFamiliesNestedInput
    headOfFamily?: MemberUpdateOneWithoutHeadedFamiliesNestedInput
    parentFamily?: FamilyUpdateOneWithoutSubFamiliesNestedInput
    memberships?: FamilyMembershipUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateWithoutSubFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    memberships?: FamilyMembershipUncheckedUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUpsertWithWhereUniqueWithoutParentFamilyInput = {
    where: FamilyWhereUniqueInput
    update: XOR<FamilyUpdateWithoutParentFamilyInput, FamilyUncheckedUpdateWithoutParentFamilyInput>
    create: XOR<FamilyCreateWithoutParentFamilyInput, FamilyUncheckedCreateWithoutParentFamilyInput>
  }

  export type FamilyUpdateWithWhereUniqueWithoutParentFamilyInput = {
    where: FamilyWhereUniqueInput
    data: XOR<FamilyUpdateWithoutParentFamilyInput, FamilyUncheckedUpdateWithoutParentFamilyInput>
  }

  export type FamilyUpdateManyWithWhereWithoutParentFamilyInput = {
    where: FamilyScalarWhereInput
    data: XOR<FamilyUpdateManyMutationInput, FamilyUncheckedUpdateManyWithoutParentFamilyInput>
  }

  export type FamilyMembershipUpsertWithWhereUniqueWithoutFamilyInput = {
    where: FamilyMembershipWhereUniqueInput
    update: XOR<FamilyMembershipUpdateWithoutFamilyInput, FamilyMembershipUncheckedUpdateWithoutFamilyInput>
    create: XOR<FamilyMembershipCreateWithoutFamilyInput, FamilyMembershipUncheckedCreateWithoutFamilyInput>
  }

  export type FamilyMembershipUpdateWithWhereUniqueWithoutFamilyInput = {
    where: FamilyMembershipWhereUniqueInput
    data: XOR<FamilyMembershipUpdateWithoutFamilyInput, FamilyMembershipUncheckedUpdateWithoutFamilyInput>
  }

  export type FamilyMembershipUpdateManyWithWhereWithoutFamilyInput = {
    where: FamilyMembershipScalarWhereInput
    data: XOR<FamilyMembershipUpdateManyMutationInput, FamilyMembershipUncheckedUpdateManyWithoutFamilyInput>
  }

  export type InvitationUpsertWithWhereUniqueWithoutFamilyInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutFamilyInput, InvitationUncheckedUpdateWithoutFamilyInput>
    create: XOR<InvitationCreateWithoutFamilyInput, InvitationUncheckedCreateWithoutFamilyInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutFamilyInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutFamilyInput, InvitationUncheckedUpdateWithoutFamilyInput>
  }

  export type InvitationUpdateManyWithWhereWithoutFamilyInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutFamilyInput>
  }

  export type MemberCreateWithoutFamilyMembershipsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutFamilyMembershipsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutFamilyMembershipsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutFamilyMembershipsInput, MemberUncheckedCreateWithoutFamilyMembershipsInput>
  }

  export type FamilyCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutCreatedFamiliesInput
    headOfFamily?: MemberCreateNestedOneWithoutHeadedFamiliesInput
    parentFamily?: FamilyCreateNestedOneWithoutSubFamiliesInput
    subFamilies?: FamilyCreateNestedManyWithoutParentFamilyInput
    invitations?: InvitationCreateNestedManyWithoutFamilyInput
  }

  export type FamilyUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    headOfFamilyId?: string | null
    parentFamilyId?: string | null
    subFamilies?: FamilyUncheckedCreateNestedManyWithoutParentFamilyInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutFamilyInput
  }

  export type FamilyCreateOrConnectWithoutMembershipsInput = {
    where: FamilyWhereUniqueInput
    create: XOR<FamilyCreateWithoutMembershipsInput, FamilyUncheckedCreateWithoutMembershipsInput>
  }

  export type FamilyMemberPermissionCreateWithoutFamilyMemberInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: string
    grantedBy: string
    grantedAt?: Date | string
  }

  export type FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: string
    grantedBy: string
    grantedAt?: Date | string
  }

  export type FamilyMemberPermissionCreateOrConnectWithoutFamilyMemberInput = {
    where: FamilyMemberPermissionWhereUniqueInput
    create: XOR<FamilyMemberPermissionCreateWithoutFamilyMemberInput, FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput>
  }

  export type FamilyMemberPermissionCreateManyFamilyMemberInputEnvelope = {
    data: FamilyMemberPermissionCreateManyFamilyMemberInput | FamilyMemberPermissionCreateManyFamilyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutFamilyMembershipsInput = {
    update: XOR<MemberUpdateWithoutFamilyMembershipsInput, MemberUncheckedUpdateWithoutFamilyMembershipsInput>
    create: XOR<MemberCreateWithoutFamilyMembershipsInput, MemberUncheckedCreateWithoutFamilyMembershipsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutFamilyMembershipsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutFamilyMembershipsInput, MemberUncheckedUpdateWithoutFamilyMembershipsInput>
  }

  export type MemberUpdateWithoutFamilyMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutFamilyMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type FamilyUpsertWithoutMembershipsInput = {
    update: XOR<FamilyUpdateWithoutMembershipsInput, FamilyUncheckedUpdateWithoutMembershipsInput>
    create: XOR<FamilyCreateWithoutMembershipsInput, FamilyUncheckedCreateWithoutMembershipsInput>
    where?: FamilyWhereInput
  }

  export type FamilyUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: FamilyWhereInput
    data: XOR<FamilyUpdateWithoutMembershipsInput, FamilyUncheckedUpdateWithoutMembershipsInput>
  }

  export type FamilyUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutCreatedFamiliesNestedInput
    headOfFamily?: MemberUpdateOneWithoutHeadedFamiliesNestedInput
    parentFamily?: FamilyUpdateOneWithoutSubFamiliesNestedInput
    subFamilies?: FamilyUpdateManyWithoutParentFamilyNestedInput
    invitations?: InvitationUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    subFamilies?: FamilyUncheckedUpdateManyWithoutParentFamilyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyMemberPermissionUpsertWithWhereUniqueWithoutFamilyMemberInput = {
    where: FamilyMemberPermissionWhereUniqueInput
    update: XOR<FamilyMemberPermissionUpdateWithoutFamilyMemberInput, FamilyMemberPermissionUncheckedUpdateWithoutFamilyMemberInput>
    create: XOR<FamilyMemberPermissionCreateWithoutFamilyMemberInput, FamilyMemberPermissionUncheckedCreateWithoutFamilyMemberInput>
  }

  export type FamilyMemberPermissionUpdateWithWhereUniqueWithoutFamilyMemberInput = {
    where: FamilyMemberPermissionWhereUniqueInput
    data: XOR<FamilyMemberPermissionUpdateWithoutFamilyMemberInput, FamilyMemberPermissionUncheckedUpdateWithoutFamilyMemberInput>
  }

  export type FamilyMemberPermissionUpdateManyWithWhereWithoutFamilyMemberInput = {
    where: FamilyMemberPermissionScalarWhereInput
    data: XOR<FamilyMemberPermissionUpdateManyMutationInput, FamilyMemberPermissionUncheckedUpdateManyWithoutFamilyMemberInput>
  }

  export type FamilyMemberPermissionScalarWhereInput = {
    AND?: FamilyMemberPermissionScalarWhereInput | FamilyMemberPermissionScalarWhereInput[]
    OR?: FamilyMemberPermissionScalarWhereInput[]
    NOT?: FamilyMemberPermissionScalarWhereInput | FamilyMemberPermissionScalarWhereInput[]
    id?: StringFilter<"FamilyMemberPermission"> | string
    createdAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
    familyMemberId?: StringFilter<"FamilyMemberPermission"> | string
    permission?: StringFilter<"FamilyMemberPermission"> | string
    grantedBy?: StringFilter<"FamilyMemberPermission"> | string
    grantedAt?: DateTimeFilter<"FamilyMemberPermission"> | Date | string
  }

  export type FamilyCreateWithoutInvitationsInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: MemberCreateNestedOneWithoutCreatedFamiliesInput
    headOfFamily?: MemberCreateNestedOneWithoutHeadedFamiliesInput
    parentFamily?: FamilyCreateNestedOneWithoutSubFamiliesInput
    subFamilies?: FamilyCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipCreateNestedManyWithoutFamilyInput
  }

  export type FamilyUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    headOfFamilyId?: string | null
    parentFamilyId?: string | null
    subFamilies?: FamilyUncheckedCreateNestedManyWithoutParentFamilyInput
    memberships?: FamilyMembershipUncheckedCreateNestedManyWithoutFamilyInput
  }

  export type FamilyCreateOrConnectWithoutInvitationsInput = {
    where: FamilyWhereUniqueInput
    create: XOR<FamilyCreateWithoutInvitationsInput, FamilyUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutSentInvitationsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password: string
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    member?: MemberCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentInvitationsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    password: string
    emailVerified?: boolean
    phoneVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId?: string | null
  }

  export type UserCreateOrConnectWithoutSentInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
  }

  export type MemberCreateWithoutSentInvitationsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutSentInvitationsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutSentInvitationsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSentInvitationsInput, MemberUncheckedCreateWithoutSentInvitationsInput>
  }

  export type FamilyUpsertWithoutInvitationsInput = {
    update: XOR<FamilyUpdateWithoutInvitationsInput, FamilyUncheckedUpdateWithoutInvitationsInput>
    create: XOR<FamilyCreateWithoutInvitationsInput, FamilyUncheckedCreateWithoutInvitationsInput>
    where?: FamilyWhereInput
  }

  export type FamilyUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: FamilyWhereInput
    data: XOR<FamilyUpdateWithoutInvitationsInput, FamilyUncheckedUpdateWithoutInvitationsInput>
  }

  export type FamilyUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutCreatedFamiliesNestedInput
    headOfFamily?: MemberUpdateOneWithoutHeadedFamiliesNestedInput
    parentFamily?: FamilyUpdateOneWithoutSubFamiliesNestedInput
    subFamilies?: FamilyUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    subFamilies?: FamilyUncheckedUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUncheckedUpdateManyWithoutFamilyNestedInput
  }

  export type UserUpsertWithoutSentInvitationsInput = {
    update: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUpsertWithoutSentInvitationsInput = {
    update: XOR<MemberUpdateWithoutSentInvitationsInput, MemberUncheckedUpdateWithoutSentInvitationsInput>
    create: XOR<MemberCreateWithoutSentInvitationsInput, MemberUncheckedCreateWithoutSentInvitationsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutSentInvitationsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutSentInvitationsInput, MemberUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type MemberUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberCreateWithoutUploadedFilesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
  }

  export type MemberUncheckedCreateWithoutUploadedFilesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
  }

  export type MemberCreateOrConnectWithoutUploadedFilesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUploadedFilesInput, MemberUncheckedCreateWithoutUploadedFilesInput>
  }

  export type PostFileAttachmentCreateWithoutFileInput = {
    id?: string
    order?: number
    post: PostCreateNestedOneWithoutFileAttachmentsInput
  }

  export type PostFileAttachmentUncheckedCreateWithoutFileInput = {
    id?: string
    postId: string
    order?: number
  }

  export type PostFileAttachmentCreateOrConnectWithoutFileInput = {
    where: PostFileAttachmentWhereUniqueInput
    create: XOR<PostFileAttachmentCreateWithoutFileInput, PostFileAttachmentUncheckedCreateWithoutFileInput>
  }

  export type PostFileAttachmentCreateManyFileInputEnvelope = {
    data: PostFileAttachmentCreateManyFileInput | PostFileAttachmentCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type CommentFileAttachmentCreateWithoutFileInput = {
    id?: string
    comment: CommentCreateNestedOneWithoutFileAttachmentsInput
  }

  export type CommentFileAttachmentUncheckedCreateWithoutFileInput = {
    id?: string
    commentId: string
  }

  export type CommentFileAttachmentCreateOrConnectWithoutFileInput = {
    where: CommentFileAttachmentWhereUniqueInput
    create: XOR<CommentFileAttachmentCreateWithoutFileInput, CommentFileAttachmentUncheckedCreateWithoutFileInput>
  }

  export type CommentFileAttachmentCreateManyFileInputEnvelope = {
    data: CommentFileAttachmentCreateManyFileInput | CommentFileAttachmentCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutUploadedFilesInput = {
    update: XOR<MemberUpdateWithoutUploadedFilesInput, MemberUncheckedUpdateWithoutUploadedFilesInput>
    create: XOR<MemberCreateWithoutUploadedFilesInput, MemberUncheckedCreateWithoutUploadedFilesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutUploadedFilesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutUploadedFilesInput, MemberUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type MemberUpdateWithoutUploadedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutUploadedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
  }

  export type PostFileAttachmentUpsertWithWhereUniqueWithoutFileInput = {
    where: PostFileAttachmentWhereUniqueInput
    update: XOR<PostFileAttachmentUpdateWithoutFileInput, PostFileAttachmentUncheckedUpdateWithoutFileInput>
    create: XOR<PostFileAttachmentCreateWithoutFileInput, PostFileAttachmentUncheckedCreateWithoutFileInput>
  }

  export type PostFileAttachmentUpdateWithWhereUniqueWithoutFileInput = {
    where: PostFileAttachmentWhereUniqueInput
    data: XOR<PostFileAttachmentUpdateWithoutFileInput, PostFileAttachmentUncheckedUpdateWithoutFileInput>
  }

  export type PostFileAttachmentUpdateManyWithWhereWithoutFileInput = {
    where: PostFileAttachmentScalarWhereInput
    data: XOR<PostFileAttachmentUpdateManyMutationInput, PostFileAttachmentUncheckedUpdateManyWithoutFileInput>
  }

  export type PostFileAttachmentScalarWhereInput = {
    AND?: PostFileAttachmentScalarWhereInput | PostFileAttachmentScalarWhereInput[]
    OR?: PostFileAttachmentScalarWhereInput[]
    NOT?: PostFileAttachmentScalarWhereInput | PostFileAttachmentScalarWhereInput[]
    id?: StringFilter<"PostFileAttachment"> | string
    postId?: StringFilter<"PostFileAttachment"> | string
    fileId?: StringFilter<"PostFileAttachment"> | string
    order?: IntFilter<"PostFileAttachment"> | number
  }

  export type CommentFileAttachmentUpsertWithWhereUniqueWithoutFileInput = {
    where: CommentFileAttachmentWhereUniqueInput
    update: XOR<CommentFileAttachmentUpdateWithoutFileInput, CommentFileAttachmentUncheckedUpdateWithoutFileInput>
    create: XOR<CommentFileAttachmentCreateWithoutFileInput, CommentFileAttachmentUncheckedCreateWithoutFileInput>
  }

  export type CommentFileAttachmentUpdateWithWhereUniqueWithoutFileInput = {
    where: CommentFileAttachmentWhereUniqueInput
    data: XOR<CommentFileAttachmentUpdateWithoutFileInput, CommentFileAttachmentUncheckedUpdateWithoutFileInput>
  }

  export type CommentFileAttachmentUpdateManyWithWhereWithoutFileInput = {
    where: CommentFileAttachmentScalarWhereInput
    data: XOR<CommentFileAttachmentUpdateManyMutationInput, CommentFileAttachmentUncheckedUpdateManyWithoutFileInput>
  }

  export type CommentFileAttachmentScalarWhereInput = {
    AND?: CommentFileAttachmentScalarWhereInput | CommentFileAttachmentScalarWhereInput[]
    OR?: CommentFileAttachmentScalarWhereInput[]
    NOT?: CommentFileAttachmentScalarWhereInput | CommentFileAttachmentScalarWhereInput[]
    id?: StringFilter<"CommentFileAttachment"> | string
    commentId?: StringFilter<"CommentFileAttachment"> | string
    fileId?: StringFilter<"CommentFileAttachment"> | string
  }

  export type PostCreateWithoutFileAttachmentsInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    author: MemberCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutFileAttachmentsInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    authorId: string
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutFileAttachmentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutFileAttachmentsInput, PostUncheckedCreateWithoutFileAttachmentsInput>
  }

  export type FileCreateWithoutPostAttachmentsInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: MemberCreateNestedOneWithoutUploadedFilesInput
    commentAttachments?: CommentFileAttachmentCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutPostAttachmentsInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: string
    commentAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutPostAttachmentsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutPostAttachmentsInput, FileUncheckedCreateWithoutPostAttachmentsInput>
  }

  export type PostUpsertWithoutFileAttachmentsInput = {
    update: XOR<PostUpdateWithoutFileAttachmentsInput, PostUncheckedUpdateWithoutFileAttachmentsInput>
    create: XOR<PostCreateWithoutFileAttachmentsInput, PostUncheckedCreateWithoutFileAttachmentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutFileAttachmentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutFileAttachmentsInput, PostUncheckedUpdateWithoutFileAttachmentsInput>
  }

  export type PostUpdateWithoutFileAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutFileAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    authorId?: StringFieldUpdateOperationsInput | string
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FileUpsertWithoutPostAttachmentsInput = {
    update: XOR<FileUpdateWithoutPostAttachmentsInput, FileUncheckedUpdateWithoutPostAttachmentsInput>
    create: XOR<FileCreateWithoutPostAttachmentsInput, FileUncheckedCreateWithoutPostAttachmentsInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutPostAttachmentsInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutPostAttachmentsInput, FileUncheckedUpdateWithoutPostAttachmentsInput>
  }

  export type FileUpdateWithoutPostAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: MemberUpdateOneRequiredWithoutUploadedFilesNestedInput
    commentAttachments?: CommentFileAttachmentUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutPostAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    commentAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutFileNestedInput
  }

  export type CommentCreateWithoutFileAttachmentsInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likesCount?: number
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutFileAttachmentsInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    authorId: string
    parentCommentId?: string | null
    likesCount?: number
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutFileAttachmentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutFileAttachmentsInput, CommentUncheckedCreateWithoutFileAttachmentsInput>
  }

  export type FileCreateWithoutCommentAttachmentsInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: MemberCreateNestedOneWithoutUploadedFilesInput
    postAttachments?: PostFileAttachmentCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutCommentAttachmentsInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: string
    postAttachments?: PostFileAttachmentUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutCommentAttachmentsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutCommentAttachmentsInput, FileUncheckedCreateWithoutCommentAttachmentsInput>
  }

  export type CommentUpsertWithoutFileAttachmentsInput = {
    update: XOR<CommentUpdateWithoutFileAttachmentsInput, CommentUncheckedUpdateWithoutFileAttachmentsInput>
    create: XOR<CommentCreateWithoutFileAttachmentsInput, CommentUncheckedCreateWithoutFileAttachmentsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutFileAttachmentsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutFileAttachmentsInput, CommentUncheckedUpdateWithoutFileAttachmentsInput>
  }

  export type CommentUpdateWithoutFileAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutFileAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type FileUpsertWithoutCommentAttachmentsInput = {
    update: XOR<FileUpdateWithoutCommentAttachmentsInput, FileUncheckedUpdateWithoutCommentAttachmentsInput>
    create: XOR<FileCreateWithoutCommentAttachmentsInput, FileUncheckedCreateWithoutCommentAttachmentsInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutCommentAttachmentsInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutCommentAttachmentsInput, FileUncheckedUpdateWithoutCommentAttachmentsInput>
  }

  export type FileUpdateWithoutCommentAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: MemberUpdateOneRequiredWithoutUploadedFilesNestedInput
    postAttachments?: PostFileAttachmentUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutCommentAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    postAttachments?: PostFileAttachmentUncheckedUpdateManyWithoutFileNestedInput
  }

  export type MemberCreateWithoutPostsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutPostsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutPostsInput, MemberUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likesCount?: number
    author: MemberCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    parentCommentId?: string | null
    likesCount?: number
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeUncheckedCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostLikeCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    member: MemberCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    memberId: string
  }

  export type PostLikeCreateOrConnectWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeCreateManyPostInputEnvelope = {
    data: PostLikeCreateManyPostInput | PostLikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostFileAttachmentCreateWithoutPostInput = {
    id?: string
    order?: number
    file: FileCreateNestedOneWithoutPostAttachmentsInput
  }

  export type PostFileAttachmentUncheckedCreateWithoutPostInput = {
    id?: string
    fileId: string
    order?: number
  }

  export type PostFileAttachmentCreateOrConnectWithoutPostInput = {
    where: PostFileAttachmentWhereUniqueInput
    create: XOR<PostFileAttachmentCreateWithoutPostInput, PostFileAttachmentUncheckedCreateWithoutPostInput>
  }

  export type PostFileAttachmentCreateManyPostInputEnvelope = {
    data: PostFileAttachmentCreateManyPostInput | PostFileAttachmentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutPostsInput = {
    update: XOR<MemberUpdateWithoutPostsInput, MemberUncheckedUpdateWithoutPostsInput>
    create: XOR<MemberCreateWithoutPostsInput, MemberUncheckedCreateWithoutPostsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutPostsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutPostsInput, MemberUncheckedUpdateWithoutPostsInput>
  }

  export type MemberUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostLikeUpsertWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutPostInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutPostInput>
  }

  export type PostFileAttachmentUpsertWithWhereUniqueWithoutPostInput = {
    where: PostFileAttachmentWhereUniqueInput
    update: XOR<PostFileAttachmentUpdateWithoutPostInput, PostFileAttachmentUncheckedUpdateWithoutPostInput>
    create: XOR<PostFileAttachmentCreateWithoutPostInput, PostFileAttachmentUncheckedCreateWithoutPostInput>
  }

  export type PostFileAttachmentUpdateWithWhereUniqueWithoutPostInput = {
    where: PostFileAttachmentWhereUniqueInput
    data: XOR<PostFileAttachmentUpdateWithoutPostInput, PostFileAttachmentUncheckedUpdateWithoutPostInput>
  }

  export type PostFileAttachmentUpdateManyWithWhereWithoutPostInput = {
    where: PostFileAttachmentScalarWhereInput
    data: XOR<PostFileAttachmentUpdateManyMutationInput, PostFileAttachmentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    author: MemberCreateNestedOneWithoutPostsInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
    fileAttachments?: PostFileAttachmentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    authorId: string
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    fileAttachments?: PostFileAttachmentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type MemberCreateWithoutCommentsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutCommentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likesCount?: number
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    likes?: CommentLikeCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    authorId: string
    parentCommentId?: string | null
    likesCount?: number
    likes?: CommentLikeUncheckedCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentCommentInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likesCount?: number
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutParentCommentInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    authorId: string
    likesCount?: number
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    likes?: CommentLikeUncheckedCreateNestedManyWithoutCommentInput
    fileAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentCreateManyParentCommentInputEnvelope = {
    data: CommentCreateManyParentCommentInput | CommentCreateManyParentCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommentLikeCreateWithoutCommentInput = {
    id?: string
    createdAt?: Date | string
    member: MemberCreateNestedOneWithoutCommentLikesInput
  }

  export type CommentLikeUncheckedCreateWithoutCommentInput = {
    id?: string
    createdAt?: Date | string
    memberId: string
  }

  export type CommentLikeCreateOrConnectWithoutCommentInput = {
    where: CommentLikeWhereUniqueInput
    create: XOR<CommentLikeCreateWithoutCommentInput, CommentLikeUncheckedCreateWithoutCommentInput>
  }

  export type CommentLikeCreateManyCommentInputEnvelope = {
    data: CommentLikeCreateManyCommentInput | CommentLikeCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommentFileAttachmentCreateWithoutCommentInput = {
    id?: string
    file: FileCreateNestedOneWithoutCommentAttachmentsInput
  }

  export type CommentFileAttachmentUncheckedCreateWithoutCommentInput = {
    id?: string
    fileId: string
  }

  export type CommentFileAttachmentCreateOrConnectWithoutCommentInput = {
    where: CommentFileAttachmentWhereUniqueInput
    create: XOR<CommentFileAttachmentCreateWithoutCommentInput, CommentFileAttachmentUncheckedCreateWithoutCommentInput>
  }

  export type CommentFileAttachmentCreateManyCommentInputEnvelope = {
    data: CommentFileAttachmentCreateManyCommentInput | CommentFileAttachmentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    fileAttachments?: PostFileAttachmentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    authorId?: StringFieldUpdateOperationsInput | string
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    fileAttachments?: PostFileAttachmentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type MemberUpsertWithoutCommentsInput = {
    update: XOR<MemberUpdateWithoutCommentsInput, MemberUncheckedUpdateWithoutCommentsInput>
    create: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCommentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCommentsInput, MemberUncheckedUpdateWithoutCommentsInput>
  }

  export type MemberUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    likes?: CommentLikeUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    likes?: CommentLikeUncheckedUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentCommentInput>
  }

  export type CommentLikeUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentLikeWhereUniqueInput
    update: XOR<CommentLikeUpdateWithoutCommentInput, CommentLikeUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentLikeCreateWithoutCommentInput, CommentLikeUncheckedCreateWithoutCommentInput>
  }

  export type CommentLikeUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentLikeWhereUniqueInput
    data: XOR<CommentLikeUpdateWithoutCommentInput, CommentLikeUncheckedUpdateWithoutCommentInput>
  }

  export type CommentLikeUpdateManyWithWhereWithoutCommentInput = {
    where: CommentLikeScalarWhereInput
    data: XOR<CommentLikeUpdateManyMutationInput, CommentLikeUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentFileAttachmentUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentFileAttachmentWhereUniqueInput
    update: XOR<CommentFileAttachmentUpdateWithoutCommentInput, CommentFileAttachmentUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentFileAttachmentCreateWithoutCommentInput, CommentFileAttachmentUncheckedCreateWithoutCommentInput>
  }

  export type CommentFileAttachmentUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentFileAttachmentWhereUniqueInput
    data: XOR<CommentFileAttachmentUpdateWithoutCommentInput, CommentFileAttachmentUncheckedUpdateWithoutCommentInput>
  }

  export type CommentFileAttachmentUpdateManyWithWhereWithoutCommentInput = {
    where: CommentFileAttachmentScalarWhereInput
    data: XOR<CommentFileAttachmentUpdateManyMutationInput, CommentFileAttachmentUncheckedUpdateManyWithoutCommentInput>
  }

  export type PostCreateWithoutLikesInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    author: MemberCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    fileAttachments?: PostFileAttachmentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLikesInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    authorId: string
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    fileAttachments?: PostFileAttachmentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
  }

  export type MemberCreateWithoutPostLikesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutPostLikesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutPostLikesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutPostLikesInput, MemberUncheckedCreateWithoutPostLikesInput>
  }

  export type PostUpsertWithoutLikesInput = {
    update: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
  }

  export type PostUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    fileAttachments?: PostFileAttachmentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    authorId?: StringFieldUpdateOperationsInput | string
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    fileAttachments?: PostFileAttachmentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type MemberUpsertWithoutPostLikesInput = {
    update: XOR<MemberUpdateWithoutPostLikesInput, MemberUncheckedUpdateWithoutPostLikesInput>
    create: XOR<MemberCreateWithoutPostLikesInput, MemberUncheckedCreateWithoutPostLikesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutPostLikesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutPostLikesInput, MemberUncheckedUpdateWithoutPostLikesInput>
  }

  export type MemberUpdateWithoutPostLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutPostLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type CommentCreateWithoutLikesInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likesCount?: number
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    fileAttachments?: CommentFileAttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutLikesInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    authorId: string
    parentCommentId?: string | null
    likesCount?: number
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    fileAttachments?: CommentFileAttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutLikesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
  }

  export type MemberCreateWithoutCommentLikesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutCommentLikesInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutCommentLikesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCommentLikesInput, MemberUncheckedCreateWithoutCommentLikesInput>
  }

  export type CommentUpsertWithoutLikesInput = {
    update: XOR<CommentUpdateWithoutLikesInput, CommentUncheckedUpdateWithoutLikesInput>
    create: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutLikesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutLikesInput, CommentUncheckedUpdateWithoutLikesInput>
  }

  export type CommentUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    fileAttachments?: CommentFileAttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    fileAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type MemberUpsertWithoutCommentLikesInput = {
    update: XOR<MemberUpdateWithoutCommentLikesInput, MemberUncheckedUpdateWithoutCommentLikesInput>
    create: XOR<MemberCreateWithoutCommentLikesInput, MemberUncheckedCreateWithoutCommentLikesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCommentLikesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCommentLikesInput, MemberUncheckedUpdateWithoutCommentLikesInput>
  }

  export type MemberUpdateWithoutCommentLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutCommentLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberCreateWithoutNotificationsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    triggeredNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutNotificationsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutNotificationsInput, MemberUncheckedCreateWithoutNotificationsInput>
  }

  export type MemberCreateWithoutTriggeredNotificationsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberCreateNestedManyWithoutChildrenInput
    children?: MemberCreateNestedManyWithoutParentsInput
    spouses?: MemberCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipCreateNestedManyWithoutMemberInput
    user?: UserCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeCreateNestedManyWithoutMemberInput
    notifications?: NotificationCreateNestedManyWithoutMemberInput
    uploadedFiles?: FileCreateNestedManyWithoutUploaderInput
  }

  export type MemberUncheckedCreateWithoutTriggeredNotificationsInput = {
    id?: string
    name: string
    gender?: $Enums.Gender | null
    status?: $Enums.MemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: string | null
    parentColors?: MemberCreateparentColorsInput | string[]
    parents?: MemberUncheckedCreateNestedManyWithoutChildrenInput
    children?: MemberUncheckedCreateNestedManyWithoutParentsInput
    spouses?: MemberUncheckedCreateNestedManyWithoutSpousesReverseInput
    spousesReverse?: MemberUncheckedCreateNestedManyWithoutSpousesInput
    familyMemberships?: FamilyMembershipUncheckedCreateNestedManyWithoutMemberInput
    user?: UserUncheckedCreateNestedOneWithoutMemberInput
    sentInvitations?: InvitationUncheckedCreateNestedManyWithoutInviterMemberInput
    createdFamilies?: FamilyUncheckedCreateNestedManyWithoutCreatorInput
    headedFamilies?: FamilyUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutMemberInput
    commentLikes?: CommentLikeUncheckedCreateNestedManyWithoutMemberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMemberInput
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type MemberCreateOrConnectWithoutTriggeredNotificationsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutTriggeredNotificationsInput, MemberUncheckedCreateWithoutTriggeredNotificationsInput>
  }

  export type MemberUpsertWithoutNotificationsInput = {
    update: XOR<MemberUpdateWithoutNotificationsInput, MemberUncheckedUpdateWithoutNotificationsInput>
    create: XOR<MemberCreateWithoutNotificationsInput, MemberUncheckedCreateWithoutNotificationsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutNotificationsInput, MemberUncheckedUpdateWithoutNotificationsInput>
  }

  export type MemberUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUpsertWithoutTriggeredNotificationsInput = {
    update: XOR<MemberUpdateWithoutTriggeredNotificationsInput, MemberUncheckedUpdateWithoutTriggeredNotificationsInput>
    create: XOR<MemberCreateWithoutTriggeredNotificationsInput, MemberUncheckedCreateWithoutTriggeredNotificationsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutTriggeredNotificationsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutTriggeredNotificationsInput, MemberUncheckedUpdateWithoutTriggeredNotificationsInput>
  }

  export type MemberUpdateWithoutTriggeredNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutTriggeredNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type FamilyMembershipCreateWithoutFamilyMemberPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
    member: MemberCreateNestedOneWithoutFamilyMembershipsInput
    family: FamilyCreateNestedOneWithoutMembershipsInput
  }

  export type FamilyMembershipUncheckedCreateWithoutFamilyMemberPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    familyId: string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
  }

  export type FamilyMembershipCreateOrConnectWithoutFamilyMemberPermissionsInput = {
    where: FamilyMembershipWhereUniqueInput
    create: XOR<FamilyMembershipCreateWithoutFamilyMemberPermissionsInput, FamilyMembershipUncheckedCreateWithoutFamilyMemberPermissionsInput>
  }

  export type FamilyMembershipUpsertWithoutFamilyMemberPermissionsInput = {
    update: XOR<FamilyMembershipUpdateWithoutFamilyMemberPermissionsInput, FamilyMembershipUncheckedUpdateWithoutFamilyMemberPermissionsInput>
    create: XOR<FamilyMembershipCreateWithoutFamilyMemberPermissionsInput, FamilyMembershipUncheckedCreateWithoutFamilyMemberPermissionsInput>
    where?: FamilyMembershipWhereInput
  }

  export type FamilyMembershipUpdateToOneWithWhereWithoutFamilyMemberPermissionsInput = {
    where?: FamilyMembershipWhereInput
    data: XOR<FamilyMembershipUpdateWithoutFamilyMemberPermissionsInput, FamilyMembershipUncheckedUpdateWithoutFamilyMemberPermissionsInput>
  }

  export type FamilyMembershipUpdateWithoutFamilyMemberPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutFamilyMembershipsNestedInput
    family?: FamilyUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type FamilyMembershipUncheckedUpdateWithoutFamilyMemberPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateManyInviterUserInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    familyId: string
    inviterMemberId?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationUpdateWithoutInviterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
    family?: FamilyUpdateOneRequiredWithoutInvitationsNestedInput
    inviterMember?: MemberUpdateOneWithoutSentInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutInviterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    familyId?: StringFieldUpdateOperationsInput | string
    inviterMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationUncheckedUpdateManyWithoutInviterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    familyId?: StringFieldUpdateOperationsInput | string
    inviterMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FamilyMembershipCreateManyMemberInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    familyId: string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
  }

  export type InvitationCreateManyInviterMemberInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    familyId: string
    inviterUserId?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FamilyCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    headOfFamilyId?: string | null
    parentFamilyId?: string | null
  }

  export type FamilyCreateManyHeadOfFamilyInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    parentFamilyId?: string | null
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    content: string
    imageUrls?: PostCreateimageUrlsInput | string[]
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    visibility?: $Enums.PostVisibility
    familyId?: string | null
    likesCount?: number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    parentCommentId?: string | null
    likesCount?: number
  }

  export type PostLikeCreateManyMemberInput = {
    id?: string
    createdAt?: Date | string
    postId: string
  }

  export type CommentLikeCreateManyMemberInput = {
    id?: string
    createdAt?: Date | string
    commentId: string
  }

  export type NotificationCreateManyMemberInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    relatedMemberId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyRelatedMemberInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    memberId: string
    relatedPostId?: string | null
    relatedCommentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FileCreateManyUploaderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
  }

  export type MemberUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
  }

  export type MemberUpdateWithoutSpousesReverseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spouses?: MemberUpdateManyWithoutSpousesReverseNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutSpousesReverseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spouses?: MemberUncheckedUpdateManyWithoutSpousesReverseNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutSpousesReverseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
  }

  export type MemberUpdateWithoutSpousesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUpdateManyWithoutChildrenNestedInput
    children?: MemberUpdateManyWithoutParentsNestedInput
    spousesReverse?: MemberUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUpdateManyWithoutMemberNestedInput
    user?: UserUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateWithoutSpousesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
    parents?: MemberUncheckedUpdateManyWithoutChildrenNestedInput
    children?: MemberUncheckedUpdateManyWithoutParentsNestedInput
    spousesReverse?: MemberUncheckedUpdateManyWithoutSpousesNestedInput
    familyMemberships?: FamilyMembershipUncheckedUpdateManyWithoutMemberNestedInput
    user?: UserUncheckedUpdateOneWithoutMemberNestedInput
    sentInvitations?: InvitationUncheckedUpdateManyWithoutInviterMemberNestedInput
    createdFamilies?: FamilyUncheckedUpdateManyWithoutCreatorNestedInput
    headedFamilies?: FamilyUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutMemberNestedInput
    commentLikes?: CommentLikeUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMemberNestedInput
    triggeredNotifications?: NotificationUncheckedUpdateManyWithoutRelatedMemberNestedInput
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutSpousesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalInfo?: NullableJsonNullValueInput | InputJsonValue
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentColors?: MemberUpdateparentColorsInput | string[]
  }

  export type FamilyMembershipUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    family?: FamilyUpdateOneRequiredWithoutMembershipsNestedInput
    familyMemberPermissions?: FamilyMemberPermissionUpdateManyWithoutFamilyMemberNestedInput
  }

  export type FamilyMembershipUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyId?: StringFieldUpdateOperationsInput | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberPermissions?: FamilyMemberPermissionUncheckedUpdateManyWithoutFamilyMemberNestedInput
  }

  export type FamilyMembershipUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyId?: StringFieldUpdateOperationsInput | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutInviterMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
    family?: FamilyUpdateOneRequiredWithoutInvitationsNestedInput
    inviterUser?: UserUpdateOneWithoutSentInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutInviterMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    familyId?: StringFieldUpdateOperationsInput | string
    inviterUserId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationUncheckedUpdateManyWithoutInviterMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    familyId?: StringFieldUpdateOperationsInput | string
    inviterUserId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FamilyUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    headOfFamily?: MemberUpdateOneWithoutHeadedFamiliesNestedInput
    parentFamily?: FamilyUpdateOneWithoutSubFamiliesNestedInput
    subFamilies?: FamilyUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    subFamilies?: FamilyUncheckedUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUncheckedUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FamilyUpdateWithoutHeadOfFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutCreatedFamiliesNestedInput
    parentFamily?: FamilyUpdateOneWithoutSubFamiliesNestedInput
    subFamilies?: FamilyUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateWithoutHeadOfFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    subFamilies?: FamilyUncheckedUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUncheckedUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateManyWithoutHeadOfFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    parentFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
    fileAttachments?: PostFileAttachmentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    fileAttachments?: PostFileAttachmentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrls?: PostUpdateimageUrlsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    familyId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    editHistory?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUncheckedUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
  }

  export type PostLikeUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikeUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutLikesNestedInput
  }

  export type CommentLikeUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikeUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    relatedMember?: MemberUpdateOneWithoutTriggeredNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateWithoutRelatedMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    member?: MemberUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRelatedMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyWithoutRelatedMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    relatedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FileUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAttachments?: PostFileAttachmentUpdateManyWithoutFileNestedInput
    commentAttachments?: CommentFileAttachmentUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAttachments?: PostFileAttachmentUncheckedUpdateManyWithoutFileNestedInput
    commentAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyCreateManyParentFamilyInput = {
    id?: string
    name: string
    description?: string | null
    isSubFamily?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    headOfFamilyId?: string | null
  }

  export type FamilyMembershipCreateManyFamilyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberId: string
    role?: $Enums.FamilyRole
    type?: $Enums.MembershipType
    autoEnrolled?: boolean
    manuallyEdited?: boolean
    isActive?: boolean
    joinDate?: Date | string
  }

  export type InvitationCreateManyFamilyInput = {
    id?: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
    status?: $Enums.InvitationStatus
    usedAt?: Date | string | null
    acceptedBy?: string | null
    inviterUserId?: string | null
    inviterMemberId?: string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FamilyUpdateWithoutParentFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: MemberUpdateOneRequiredWithoutCreatedFamiliesNestedInput
    headOfFamily?: MemberUpdateOneWithoutHeadedFamiliesNestedInput
    subFamilies?: FamilyUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateWithoutParentFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    subFamilies?: FamilyUncheckedUpdateManyWithoutParentFamilyNestedInput
    memberships?: FamilyMembershipUncheckedUpdateManyWithoutFamilyNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutFamilyNestedInput
  }

  export type FamilyUncheckedUpdateManyWithoutParentFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSubFamily?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FamilyMembershipUpdateWithoutFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutFamilyMembershipsNestedInput
    familyMemberPermissions?: FamilyMemberPermissionUpdateManyWithoutFamilyMemberNestedInput
  }

  export type FamilyMembershipUncheckedUpdateWithoutFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberPermissions?: FamilyMemberPermissionUncheckedUpdateManyWithoutFamilyMemberNestedInput
  }

  export type FamilyMembershipUncheckedUpdateManyWithoutFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
    role?: EnumFamilyRoleFieldUpdateOperationsInput | $Enums.FamilyRole
    type?: EnumMembershipTypeFieldUpdateOperationsInput | $Enums.MembershipType
    autoEnrolled?: BoolFieldUpdateOperationsInput | boolean
    manuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
    inviterUser?: UserUpdateOneWithoutSentInvitationsNestedInput
    inviterMember?: MemberUpdateOneWithoutSentInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inviterUserId?: NullableStringFieldUpdateOperationsInput | string | null
    inviterMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InvitationUncheckedUpdateManyWithoutFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inviterUserId?: NullableStringFieldUpdateOperationsInput | string | null
    inviterMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    memberStub?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FamilyMemberPermissionCreateManyFamilyMemberInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: string
    grantedBy: string
    grantedAt?: Date | string
  }

  export type FamilyMemberPermissionUpdateWithoutFamilyMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberPermissionUncheckedUpdateWithoutFamilyMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberPermissionUncheckedUpdateManyWithoutFamilyMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: StringFieldUpdateOperationsInput | string
    grantedBy?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostFileAttachmentCreateManyFileInput = {
    id?: string
    postId: string
    order?: number
  }

  export type CommentFileAttachmentCreateManyFileInput = {
    id?: string
    commentId: string
  }

  export type PostFileAttachmentUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutFileAttachmentsNestedInput
  }

  export type PostFileAttachmentUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PostFileAttachmentUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CommentFileAttachmentUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: CommentUpdateOneRequiredWithoutFileAttachmentsNestedInput
  }

  export type CommentFileAttachmentUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentFileAttachmentUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    parentCommentId?: string | null
    likesCount?: number
  }

  export type PostLikeCreateManyPostInput = {
    id?: string
    createdAt?: Date | string
    memberId: string
  }

  export type PostFileAttachmentCreateManyPostInput = {
    id?: string
    fileId: string
    order?: number
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUncheckedUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    likesCount?: IntFieldUpdateOperationsInput | number
  }

  export type PostLikeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type PostFileAttachmentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    file?: FileUpdateOneRequiredWithoutPostAttachmentsNestedInput
  }

  export type PostFileAttachmentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PostFileAttachmentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyParentCommentInput = {
    id?: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: string
    authorId: string
    likesCount?: number
  }

  export type CommentLikeCreateManyCommentInput = {
    id?: string
    createdAt?: Date | string
    memberId: string
  }

  export type CommentFileAttachmentCreateManyCommentInput = {
    id?: string
    fileId: string
  }

  export type CommentUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    likes?: CommentLikeUncheckedUpdateManyWithoutCommentNestedInput
    fileAttachments?: CommentFileAttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
  }

  export type CommentLikeUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: MemberUpdateOneRequiredWithoutCommentLikesNestedInput
  }

  export type CommentLikeUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikeUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentFileAttachmentUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    file?: FileUpdateOneRequiredWithoutCommentAttachmentsNestedInput
  }

  export type CommentFileAttachmentUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentFileAttachmentUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}